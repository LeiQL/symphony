
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>activations: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/activations/activations-cleanup-manager.go (40.5%)</option>
				
				<option value="file1">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/activations/activations-manager.go (80.5%)</option>
				
				<option value="file2">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/campaigns/campaigns-manager.go (75.0%)</option>
				
				<option value="file3">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/configs/configs-manager.go (19.3%)</option>
				
				<option value="file4">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/devices/devices-manager.go (85.7%)</option>
				
				<option value="file5">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/instances/instances-manager.go (78.1%)</option>
				
				<option value="file6">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/jobs/jobs-manager.go (73.7%)</option>
				
				<option value="file7">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/reference/reference-manager.go (78.1%)</option>
				
				<option value="file8">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/sites/sites-manager.go (72.3%)</option>
				
				<option value="file9">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/solution/solution-manager-state.go (95.5%)</option>
				
				<option value="file10">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/solution/solution-manager.go (70.0%)</option>
				
				<option value="file11">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/solutions/solutions-manager.go (78.0%)</option>
				
				<option value="file12">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/stage/stage-manager.go (69.2%)</option>
				
				<option value="file13">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/staging/staging-manager.go (60.6%)</option>
				
				<option value="file14">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/target/target-manager.go (68.7%)</option>
				
				<option value="file15">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/targets/targets-manager.go (81.1%)</option>
				
				<option value="file16">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/users/users-manager.go (86.8%)</option>
				
				<option value="file17">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/binding.go (100.0%)</option>
				
				<option value="file18">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/campaign.go (23.9%)</option>
				
				<option value="file19">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/catalog.go (0.0%)</option>
				
				<option value="file20">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/component.go (83.3%)</option>
				
				<option value="file21">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/deployment.go (80.9%)</option>
				
				<option value="file22">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/device.go (100.0%)</option>
				
				<option value="file23">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/edge.go (0.0%)</option>
				
				<option value="file24">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/filter.go (90.0%)</option>
				
				<option value="file25">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/instance.go (98.0%)</option>
				
				<option value="file26">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/model.go (0.0%)</option>
				
				<option value="file27">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/node.go (0.0%)</option>
				
				<option value="file28">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/plan.go (0.0%)</option>
				
				<option value="file29">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/route.go (91.7%)</option>
				
				<option value="file30">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/site.go (0.0%)</option>
				
				<option value="file31">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/skill.go (0.0%)</option>
				
				<option value="file32">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/solution.go (100.0%)</option>
				
				<option value="file33">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/summary.go (0.0%)</option>
				
				<option value="file34">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/target.go (95.0%)</option>
				
				<option value="file35">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/utils.go (69.2%)</option>
				
				<option value="file36">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/validationrule.go (48.5%)</option>
				
				<option value="file37">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file38">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/config/catalog/catalogprovider.go (0.0%)</option>
				
				<option value="file39">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/graph/memory/memorygraph.go (56.3%)</option>
				
				<option value="file40">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/counter/counter.go (69.5%)</option>
				
				<option value="file41">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/create/create.go (0.0%)</option>
				
				<option value="file42">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/http/http.go (46.4%)</option>
				
				<option value="file43">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/patch/patch.go (0.0%)</option>
				
				<option value="file44">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/script/script.go (49.5%)</option>
				
				<option value="file45">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/states/k8s/k8s.go (16.0%)</option>
				
				<option value="file46">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/adb/adb.go (87.8%)</option>
				
				<option value="file47">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/azure/adu/adu.go (70.9%)</option>
				
				<option value="file48">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/azure/iotedge/iotedge.go (71.1%)</option>
				
				<option value="file49">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/configmap/configmap.go (72.4%)</option>
				
				<option value="file50">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/conformance/target_conformance.go (90.0%)</option>
				
				<option value="file51">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/docker/docker.go (69.1%)</option>
				
				<option value="file52">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/helm/helm.go (45.3%)</option>
				
				<option value="file53">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/http/http.go (82.9%)</option>
				
				<option value="file54">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/ingress/ingress.go (25.5%)</option>
				
				<option value="file55">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/k8s/k8s.go (70.0%)</option>
				
				<option value="file56">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/k8s/projectors/noop.go (100.0%)</option>
				
				<option value="file57">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/kubectl/kubectl.go (16.4%)</option>
				
				<option value="file58">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/mock/mock.go (85.0%)</option>
				
				<option value="file59">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/mqtt/mqtt.go (18.3%)</option>
				
				<option value="file60">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/proxy/proxy.go (81.8%)</option>
				
				<option value="file61">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/script/script.go (81.5%)</option>
				
				<option value="file62">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/staging/staging.go (73.8%)</option>
				
				<option value="file63">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/win10/sideload/sideload.go (79.0%)</option>
				
				<option value="file64">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils/parser.go (71.4%)</option>
				
				<option value="file65">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils/schema.go (75.0%)</option>
				
				<option value="file66">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils/symphony-api.go (17.2%)</option>
				
				<option value="file67">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils/utils.go (41.6%)</option>
				
				<option value="file68">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/activations-vendor.go (0.0%)</option>
				
				<option value="file69">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/agent-vendor.go (92.8%)</option>
				
				<option value="file70">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/backgroundjob-vendor.go (0.0%)</option>
				
				<option value="file71">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/campaigns-vendor.go (0.0%)</option>
				
				<option value="file72">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/catalogs-vendor.go (0.0%)</option>
				
				<option value="file73">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/devices-vendor.go (94.3%)</option>
				
				<option value="file74">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/echovendor.go (0.0%)</option>
				
				<option value="file75">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/federation-vendor.go (0.0%)</option>
				
				<option value="file76">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/instances-vendor.go (0.0%)</option>
				
				<option value="file77">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/job-vendor.go (0.0%)</option>
				
				<option value="file78">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/models-vendor.go (0.0%)</option>
				
				<option value="file79">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/settings-vendor.go (94.9%)</option>
				
				<option value="file80">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/skills-vendor.go (0.0%)</option>
				
				<option value="file81">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/solution-vendor.go (50.7%)</option>
				
				<option value="file82">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/solutions-vendor.go (0.0%)</option>
				
				<option value="file83">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/stage-vendor.go (0.0%)</option>
				
				<option value="file84">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/staging-vendor.go (0.0%)</option>
				
				<option value="file85">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/targets-vendor.go (0.0%)</option>
				
				<option value="file86">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/trails-vendor.go (0.0%)</option>
				
				<option value="file87">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/users-vendor.go (89.5%)</option>
				
				<option value="file88">github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/vendors/vendorfactory.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package activations

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
)

const (
        // DefaultRetentionInMinutes is the default time to cleanup completed activations
        DefaultRetentionInMinutes = 1440
)

type ActivationsCleanupManager struct {
        ActivationsManager
        RetentionInMinutes int
}

func (s *ActivationsCleanupManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.ActivationsManager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set activation cleanup interval after they are done. If not set, use default 60 minutes.
        <span class="cov0" title="0">if val, ok := config.Properties["RetentionInMinutes"]; ok </span><span class="cov0" title="0">{
                s.RetentionInMinutes, err = strconv.Atoi(val)
                if err != nil </span><span class="cov0" title="0">{
                        s.RetentionInMinutes = DefaultRetentionInMinutes
                }</span>
        } else<span class="cov0" title="0"> {
                s.RetentionInMinutes = DefaultRetentionInMinutes
        }</span>
        <span class="cov0" title="0">log.Info("M (Activation Cleanup): Initialize RetentionInMinutes as " + fmt.Sprint(s.RetentionInMinutes))
        return nil</span>
}

func (s *ActivationsCleanupManager) Enabled() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *ActivationsCleanupManager) Poll() []error <span class="cov8" title="1">{
        log.Info("M (Activation Cleanup): Polling activations")
        activations, err := s.ActivationsManager.ListSpec(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>
        <span class="cov8" title="1">ret := []error{}
        for _, activation := range activations </span><span class="cov8" title="1">{
                if activation.Status.Status != v1alpha2.Done </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if activation.Status.UpdateTime == "" </span><span class="cov0" title="0">{
                        // Ugrade scenario: update time is not set for activations created before. Set it to now and the activation will be deleted later.
                        // UpdateTime will be set in ReportStatus function
                        err = s.ActivationsManager.ReportStatus(context.Background(), activation.Id, *activation.Status)
                        if err != nil </span><span class="cov0" title="0">{
                                // Delete activation immediately if update time cannot be set? Cx may be confused why activations disappeared
                                // Just leave those activations as it is and let Cx delete them manually
                                log.Error("M (Activation Cleanup): Cannot set update time for activation "+activation.Id+" since update time cannot be set: %+v", err)
                                ret = append(ret, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check update time of completed activations.
                <span class="cov8" title="1">updateTime, err := time.Parse(time.RFC3339, activation.Status.UpdateTime)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: should not happen, force update time to Time.Now() ?
                        log.Info("M (Activation Cleanup): Cannot parse update time of " + activation.Id)
                        ret = append(ret, err)
                }</span>
                <span class="cov8" title="1">duration := time.Since(updateTime)
                if duration &gt; time.Duration(s.RetentionInMinutes)*time.Minute </span><span class="cov8" title="1">{
                        log.Info("M (Activation Cleanup): Deleting activation " + activation.Id + " since it has completed for " + duration.String())
                        err = s.ActivationsManager.DeleteSpec(context.Background(), activation.Id)
                        if err != nil </span><span class="cov0" title="0">{
                                ret = append(ret, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

func (s *ActivationsCleanupManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package activations

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var lock sync.Mutex

var log = logger.NewLogger("coa.runtime")

type ActivationsManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *ActivationsManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ActivationsManager) GetSpec(ctx context.Context, name string) (model.ActivationState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Activations Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: name,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "activations",
                },
        }
        entry, err := m.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                return model.ActivationState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getActivationState(name, entry.Body, entry.ETag)
        if err != nil </span><span class="cov0" title="0">{
                return model.ActivationState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func getActivationState(id string, body interface{}, etag string) (model.ActivationState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]
        status := dict["status"]
        j, _ := json.Marshal(spec)
        var rSpec model.ActivationSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.ActivationState{}, err
        }</span>
        <span class="cov8" title="1">j, _ = json.Marshal(status)
        var rStatus model.ActivationStatus
        err = json.Unmarshal(j, &amp;rStatus)
        if err != nil </span><span class="cov0" title="0">{
                return model.ActivationState{}, err
        }</span>
        <span class="cov8" title="1">rSpec.Generation = etag
        state := model.ActivationState{
                Id:     id,
                Spec:   &amp;rSpec,
                Status: &amp;rStatus,
        }
        return state, nil</span>
}

func (m *ActivationsManager) UpsertSpec(ctx context.Context, name string, spec model.ActivationSpec) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Activations Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.WorkflowGroup + "/v1",
                                "kind":       "Activation",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                        ETag: spec.Generation,
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Activation", "metadata": {"name": "${{$activation()}}"}}`, model.WorkflowGroup),
                        "scope":    "",
                        "group":    model.WorkflowGroup,
                        "version":  "v1",
                        "resource": "activations",
                },
        }
        _, err = m.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *ActivationsManager) DeleteSpec(ctx context.Context, name string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Activations Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = m.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    "",
                        "group":    model.WorkflowGroup,
                        "version":  "v1",
                        "resource": "activations",
                },
        })
        return err
}</span>

func (t *ActivationsManager) ListSpec(ctx context.Context) ([]model.ActivationState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Activations Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "activations",
                },
        }
        solutions, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.ActivationState, 0)
        for _, t := range solutions </span><span class="cov8" title="1">{
                var rt model.ActivationState
                rt, err = getActivationState(t.ID, t.Body, t.ETag)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (t *ActivationsManager) ReportStatus(ctx context.Context, name string, current model.ActivationStatus) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Activations Manager", ctx, &amp;map[string]string{
                "method": "ReportStatus",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        lock.Lock()
        defer lock.Unlock()
        getRequest := states.GetRequest{
                ID: name,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "activations",
                },
        }
        entry, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dict := entry.Body.(map[string]interface{})
        delete(dict, "spec")
        current.UpdateTime = time.Now().Format(time.RFC3339)
        dict["status"] = current
        entry.Body = dict
        upsertRequest := states.UpsertRequest{
                Value: entry,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "activations",
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package campaigns

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
)

type CampaignsManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *CampaignsManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetCampaign retrieves a CampaignSpec object by name
func (m *CampaignsManager) GetSpec(ctx context.Context, name string) (model.CampaignState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Campaigns Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: name,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "campaigns",
                },
        }
        entry, err := m.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov0" title="0">{
                return model.CampaignState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getCampaignState(name, entry.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.CampaignState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func getCampaignState(id string, body interface{}) (model.CampaignState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]

        j, _ := json.Marshal(spec)
        var rSpec model.CampaignSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.CampaignState{}, err
        }</span>
        <span class="cov8" title="1">state := model.CampaignState{
                Id:   id,
                Spec: &amp;rSpec,
        }
        return state, nil</span>
}

func (m *CampaignsManager) UpsertSpec(ctx context.Context, name string, spec model.CampaignSpec) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Campaigns Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.WorkflowGroup + "/v1",
                                "kind":       "Campaign",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Campaign", "metadata": {"name": "${{$campaign()}}"}}`, model.WorkflowGroup),
                        "scope":    "",
                        "group":    model.WorkflowGroup,
                        "version":  "v1",
                        "resource": "campaigns",
                },
        }
        _, err = m.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *CampaignsManager) DeleteSpec(ctx context.Context, name string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Campaigns Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = m.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    "",
                        "group":    model.WorkflowGroup,
                        "version":  "v1",
                        "resource": "campaigns",
                },
        })
        return err
}</span>

func (t *CampaignsManager) ListSpec(ctx context.Context) ([]model.CampaignState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Campaigns Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.WorkflowGroup,
                        "resource": "campaigns",
                },
        }
        solutions, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.CampaignState, 0)
        for _, t := range solutions </span><span class="cov8" title="1">{
                var rt model.CampaignState
                rt, err = getCampaignState(t.ID, t.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package configs

import (
        "fmt"
        "strings"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/config"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")

type ConfigsManager struct {
        managers.Manager
        ConfigProviders map[string]config.IConfigProvider
        Precedence      []string
}

func (s *ConfigsManager) Init(context *contexts.VendorContext, cfg managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        log.Debug(" M (Config): Init")
        err := s.Manager.Init(context, cfg, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.ConfigProviders = make(map[string]config.IConfigProvider)
        for key, provider := range providers </span><span class="cov0" title="0">{
                if cProvider, ok := provider.(config.IConfigProvider); ok </span><span class="cov0" title="0">{
                        s.ConfigProviders[key] = cProvider
                }</span>
        }
        <span class="cov0" title="0">if val, ok := cfg.Properties["precedence"]; ok </span><span class="cov0" title="0">{
                s.Precedence = strings.Split(val, ",")
        }</span>
        <span class="cov0" title="0">if len(s.ConfigProviders) == 0 </span><span class="cov0" title="0">{
                log.Error(" M (Config): No config providers found")
                return v1alpha2.NewCOAError(nil, "No config providers found", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if len(s.ConfigProviders) &gt; 0 &amp;&amp; len(s.Precedence) &lt; len(s.ConfigProviders) &amp;&amp; len(s.ConfigProviders) &gt; 1 </span><span class="cov0" title="0">{
                log.Error(" M (Config): Not enough precedence values")
                return v1alpha2.NewCOAError(nil, "Not enough precedence values", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if _, ok := s.ConfigProviders[key]; !ok </span><span class="cov0" title="0">{
                        log.Error(" M (Config): Invalid precedence value: %s", key)
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid precedence value: %s", key), v1alpha2.BadConfig)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (s *ConfigsManager) Get(object string, field string, overlays []string, localContext interface{}) (interface{}, error) <span class="cov8" title="1">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        if field == "" </span><span class="cov0" title="0">{
                                configObj, err := s.getObjectWithOverlay(provider, parts[1], overlays, localContext)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">return configObj, nil</span>
                        } else<span class="cov0" title="0"> {
                                return s.getWithOverlay(provider, parts[1], field, overlays, localContext)
                        }</span>
                }
                <span class="cov0" title="0">return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov8" title="1">if len(s.ConfigProviders) == 1 </span><span class="cov8" title="1">{
                for _, provider := range s.ConfigProviders </span><span class="cov8" title="1">{
                        if field == "" </span><span class="cov0" title="0">{
                                configObj, err := s.getObjectWithOverlay(provider, object, overlays, localContext)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">return configObj, nil</span>
                        } else<span class="cov8" title="1"> {
                                if value, err := s.getWithOverlay(provider, object, field, overlays, localContext); err == nil </span><span class="cov8" title="1">{
                                        return value, nil
                                }</span> else<span class="cov0" title="0"> {
                                        return "", err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, key := range s.Precedence </span><span class="cov8" title="1">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov8" title="1">{
                        if field == "" </span><span class="cov0" title="0">{
                                configObj, err := s.getObjectWithOverlay(provider, object, overlays, localContext)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">return configObj, nil</span>
                        } else<span class="cov8" title="1"> {
                                if value, err := s.getWithOverlay(provider, object, field, overlays, localContext); err == nil </span><span class="cov8" title="1">{
                                        return value, nil
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object or key: %s, %s", object, field), v1alpha2.BadRequest)</span>
}
func (s *ConfigsManager) getWithOverlay(provider config.IConfigProvider, object string, field string, overlays []string, localContext interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(overlays) &gt; 0 </span><span class="cov8" title="1">{
                for _, overlay := range overlays </span><span class="cov8" title="1">{
                        if overlayObject, err := provider.Read(overlay, field, localContext); err == nil </span><span class="cov8" title="1">{
                                return overlayObject, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return provider.Read(object, field, localContext)</span>
}

func (s *ConfigsManager) GetObject(object string, overlays []string, localContext interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        return s.getObjectWithOverlay(provider, parts[1], overlays, localContext)
                }</span>
                <span class="cov0" title="0">return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov8" title="1">if len(s.ConfigProviders) == 1 </span><span class="cov8" title="1">{
                for _, provider := range s.ConfigProviders </span><span class="cov8" title="1">{
                        if value, err := s.getObjectWithOverlay(provider, object, overlays, localContext); err == nil </span><span class="cov8" title="1">{
                                return value, nil
                        }</span> else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov0" title="0">{
                        if value, err := s.getObjectWithOverlay(provider, object, overlays, localContext); err == nil </span><span class="cov0" title="0">{
                                return value, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object: %s", object), v1alpha2.BadRequest)</span>
}
func (s *ConfigsManager) getObjectWithOverlay(provider config.IConfigProvider, object string, overlays []string, localContext interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if len(overlays) &gt; 0 </span><span class="cov0" title="0">{
                for _, overlay := range overlays </span><span class="cov0" title="0">{
                        if overlayObject, err := provider.ReadObject(overlay, localContext); err == nil </span><span class="cov0" title="0">{
                                return overlayObject, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return provider.ReadObject(object, localContext)</span>
}
func (s *ConfigsManager) Set(object string, field string, value interface{}) error <span class="cov8" title="1">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        return provider.Set(parts[1], field, value)
                }</span>
                <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov8" title="1">if len(s.ConfigProviders) == 1 </span><span class="cov8" title="1">{
                for _, provider := range s.ConfigProviders </span><span class="cov8" title="1">{
                        return provider.Set(object, field, value)
                }</span>
        }
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov0" title="0">{
                        if err := provider.Set(object, field, value); err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object or key: %s, %s", object, field), v1alpha2.BadRequest)</span>
}
func (s *ConfigsManager) SetObject(object string, values map[string]interface{}) error <span class="cov0" title="0">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        return provider.SetObject(parts[1], values)
                }</span>
                <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov0" title="0">if len(s.ConfigProviders) == 1 </span><span class="cov0" title="0">{
                for _, provider := range s.ConfigProviders </span><span class="cov0" title="0">{
                        return provider.SetObject(object, values)
                }</span>
        }
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov0" title="0">{
                        if err := provider.SetObject(object, values); err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object: %s", object), v1alpha2.BadRequest)</span>
}
func (s *ConfigsManager) Delete(object string, field string) error <span class="cov0" title="0">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        return provider.Remove(parts[1], field)
                }</span>
                <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov0" title="0">if len(s.ConfigProviders) == 1 </span><span class="cov0" title="0">{
                for _, provider := range s.ConfigProviders </span><span class="cov0" title="0">{
                        return provider.Remove(object, field)
                }</span>
        }
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov0" title="0">{
                        if err := provider.Remove(object, field); err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object or key: %s, %s", object, field), v1alpha2.BadRequest)</span>
}
func (s *ConfigsManager) DeleteObject(object string) error <span class="cov0" title="0">{
        if strings.Index(object, ":") &gt; 0 </span><span class="cov0" title="0">{
                parts := strings.Split(object, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid object: %s", object), v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">if provider, ok := s.ConfigProviders[parts[0]]; ok </span><span class="cov0" title="0">{
                        return provider.RemoveObject(parts[1])
                }</span>
                <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid provider: %s", parts[0]), v1alpha2.BadRequest)</span>
        }
        <span class="cov0" title="0">if len(s.ConfigProviders) == 1 </span><span class="cov0" title="0">{
                for _, provider := range s.ConfigProviders </span><span class="cov0" title="0">{
                        return provider.RemoveObject(object)
                }</span>
        }
        <span class="cov0" title="0">for _, key := range s.Precedence </span><span class="cov0" title="0">{
                if provider, ok := s.ConfigProviders[key]; ok </span><span class="cov0" title="0">{
                        if err := provider.RemoveObject(object); err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, fmt.Sprintf("Invalid config object: %s", object), v1alpha2.BadRequest)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package devices

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"

        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
)

type DevicesManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *DevicesManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov8" title="1">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *DevicesManager) DeleteSpec(ctx context.Context, name string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Devices Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = t.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    "",
                        "group":    model.FabricGroup,
                        "version":  "v1",
                        "resource": "devices",
                },
        })
        return err
}</span>

func (t *DevicesManager) UpsertSpec(ctx context.Context, name string, spec model.DeviceSpec) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Devices Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.FabricGroup + "/v1",
                                "kind":       "device",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion": "%s/v1", "kind": "Device", "metadata": {"name": "${{$device()}}"}}`, model.FabricGroup),
                        "scope":    "",
                        "group":    model.FabricGroup,
                        "version":  "v1",
                        "resource": "devices",
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *DevicesManager) ListSpec(ctx context.Context) ([]model.DeviceState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Devices Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "devices",
                },
        }
        solutions, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.DeviceState, 0)
        for _, t := range solutions </span><span class="cov8" title="1">{
                var rt model.DeviceState
                rt, err = getDeviceState(t.ID, t.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func getDeviceState(id string, body interface{}) (model.DeviceState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]

        j, _ := json.Marshal(spec)
        var rSpec model.DeviceSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.DeviceState{}, err
        }</span>
        <span class="cov8" title="1">state := model.DeviceState{
                Id:   id,
                Spec: &amp;rSpec,
        }
        return state, nil</span>
}

func (t *DevicesManager) GetSpec(ctx context.Context, id string) (model.DeviceState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Devices Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: id,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "devices",
                },
        }
        target, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov0" title="0">{
                return model.DeviceState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getDeviceState(id, target.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.DeviceState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package instances

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"

        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
)

type InstancesManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *InstancesManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *InstancesManager) DeleteSpec(ctx context.Context, name string, scope string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Instances Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = t.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    scope,
                        "group":    model.SolutionGroup,
                        "version":  "v1",
                        "resource": "instances",
                },
        })
        return err
}</span>

func (t *InstancesManager) UpsertSpec(ctx context.Context, name string, spec model.InstanceSpec, scope string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Instances Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.SolutionGroup + "/v1",
                                "kind":       "Instance",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                        ETag: spec.Generation,
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Instance", "metadata": {"name": "${{$instance()}}"}}`, model.SolutionGroup),
                        "scope":    scope,
                        "group":    model.SolutionGroup,
                        "version":  "v1",
                        "resource": "instances",
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *InstancesManager) ListSpec(ctx context.Context, scope string) ([]model.InstanceState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Instances Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.SolutionGroup,
                        "resource": "instances",
                        "scope":    scope,
                },
        }
        instances, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.InstanceState, 0)
        for _, t := range instances </span><span class="cov8" title="1">{
                var rt model.InstanceState
                rt, err = getInstanceState(t.ID, t.Body, t.ETag)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func getInstanceState(id string, body interface{}, etag string) (model.InstanceState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]
        status := dict["status"]

        j, _ := json.Marshal(spec)
        var rSpec model.InstanceSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.InstanceState{}, err
        }</span>

        <span class="cov8" title="1">j, _ = json.Marshal(status)
        var rStatus map[string]interface{}
        err = json.Unmarshal(j, &amp;rStatus)
        if err != nil </span><span class="cov0" title="0">{
                return model.InstanceState{}, err
        }</span>
        <span class="cov8" title="1">j, _ = json.Marshal(rStatus["properties"])
        var rProperties map[string]string
        err = json.Unmarshal(j, &amp;rProperties)
        if err != nil </span><span class="cov0" title="0">{
                return model.InstanceState{}, err
        }</span>
        <span class="cov8" title="1">rSpec.Generation = etag

        scope, exist := dict["scope"]
        var s string
        if !exist </span><span class="cov8" title="1">{
                s = "default"
        }</span> else<span class="cov0" title="0"> {
                s = scope.(string)
        }</span>

        <span class="cov8" title="1">state := model.InstanceState{
                Id:     id,
                Scope:  s,
                Spec:   &amp;rSpec,
                Status: rProperties,
        }
        return state, nil</span>
}

func (t *InstancesManager) GetSpec(ctx context.Context, id string, scope string) (model.InstanceState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Instances Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: id,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.SolutionGroup,
                        "resource": "instances",
                        "scope":    scope,
                },
        }
        instance, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                return model.InstanceState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getInstanceState(id, instance.Body, instance.ETag)
        if err != nil </span><span class="cov0" title="0">{
                return model.InstanceState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package jobs

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")

type JobsManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

type LastSuccessTime struct {
        Time time.Time `json:"time"`
}

func (s *JobsManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov8" title="1">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *JobsManager) Enabled() bool <span class="cov8" title="1">{
        return s.Config.Properties["poll.enabled"] == "true" || s.Config.Properties["schedule.enabled"] == "true"
}</span>

func (s *JobsManager) pollObjects() []error <span class="cov8" title="1">{
        context, span := observability.StartSpan("Job Manager", context.Background(), &amp;map[string]string{
                "method": "pollObjects",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        baseUrl, err := utils.GetString(s.Manager.Config.Properties, "baseUrl")
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>
        <span class="cov8" title="1">user, err := utils.GetString(s.Manager.Config.Properties, "user")
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>
        <span class="cov8" title="1">password, err := utils.GetString(s.Manager.Config.Properties, "password")
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>
        <span class="cov8" title="1">interval := utils.ReadInt32(s.Manager.Config.Properties, "interval", 0)
        if interval == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">instances, err := utils.GetInstancesForAllScope(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return []error{err}
        }</span>
        <span class="cov8" title="1">for _, instance := range instances </span><span class="cov8" title="1">{
                var entry states.StateEntry
                entry, err = s.StateProvider.Get(context, states.GetRequest{
                        ID: "i_" + instance.Id,
                })
                needsPub := true
                if err == nil </span><span class="cov0" title="0">{
                        if stamp, ok := entry.Body.(LastSuccessTime); ok </span><span class="cov0" title="0">{
                                if time.Since(stamp.Time) &gt; time.Duration(interval)*time.Second </span><span class="cov0" title="0">{ //TODO: compare object hash as well?
                                        needsPub = true
                                }</span> else<span class="cov0" title="0"> {
                                        needsPub = false
                                }</span>
                        }
                }
                <span class="cov8" title="1">if needsPub </span><span class="cov8" title="1">{
                        s.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "instance",
                                },
                                Body: v1alpha2.JobData{
                                        Id:     instance.Id,
                                        Action: "UPDATE",
                                },
                        })
                }</span>
        }
        <span class="cov8" title="1">targets, err := utils.GetTargetsForAllScope(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return []error{err}
        }</span>
        <span class="cov8" title="1">for _, target := range targets </span><span class="cov8" title="1">{
                var entry states.StateEntry
                entry, err = s.StateProvider.Get(context, states.GetRequest{
                        ID: "t_" + target.Id,
                })
                needsPub := true
                if err == nil </span><span class="cov0" title="0">{
                        var stamp LastSuccessTime
                        jData, _ := json.Marshal(entry.Body)
                        err = json.Unmarshal(jData, &amp;stamp)
                        if err == nil </span><span class="cov0" title="0">{
                                if time.Since(stamp.Time) &gt; time.Duration(interval)*time.Second </span><span class="cov0" title="0">{ //TODO: compare object hash as well?
                                        needsPub = true
                                }</span> else<span class="cov0" title="0"> {
                                        needsPub = false
                                }</span>
                        }
                }
                <span class="cov8" title="1">if needsPub </span><span class="cov8" title="1">{
                        s.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "target",
                                },
                                Body: v1alpha2.JobData{
                                        Id:     target.Id,
                                        Action: "UPDATE",
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
func (s *JobsManager) Poll() []error <span class="cov8" title="1">{
        // TODO: do these in parallel?
        if s.Config.Properties["poll.enabled"] == "true" </span><span class="cov8" title="1">{
                errors := s.pollObjects()
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        return errors
                }</span>
        }
        <span class="cov8" title="1">if s.Config.Properties["schedule.enabled"] == "true" </span><span class="cov8" title="1">{
                errors := s.pollSchedules()
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        return errors
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *JobsManager) pollSchedules() []error <span class="cov8" title="1">{
        context, span := observability.StartSpan("Job Manager", context.Background(), &amp;map[string]string{
                "method": "pollSchedules",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        //TODO: use filters and continue tokens
        list, _, err := s.StateProvider.List(context, states.ListRequest{})
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>

        <span class="cov8" title="1">for _, entry := range list </span><span class="cov8" title="1">{
                var activationData v1alpha2.ActivationData
                entryData, _ := json.Marshal(entry.Body)
                err = json.Unmarshal(entryData, &amp;activationData)
                if err != nil </span><span class="cov0" title="0">{
                        return []error{err}
                }</span>
                <span class="cov8" title="1">if activationData.Schedule != nil </span><span class="cov8" title="1">{
                        var fire bool
                        fire, err = activationData.Schedule.ShouldFireNow()
                        if err != nil </span><span class="cov0" title="0">{
                                return []error{err}
                        }</span>
                        <span class="cov8" title="1">if fire </span><span class="cov8" title="1">{
                                activationData.Schedule = nil
                                err = s.StateProvider.Delete(context, states.DeleteRequest{
                                        ID: entry.ID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return []error{err}
                                }</span>
                                <span class="cov8" title="1">s.Context.Publish("trigger", v1alpha2.Event{
                                        Body: activationData,
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *JobsManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>
func (s *JobsManager) HandleHeartBeatEvent(ctx context.Context, event v1alpha2.Event) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Job Manager", ctx, &amp;map[string]string{
                "method": "HandleHeartBeatEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        var heartbeat v1alpha2.HeartBeatData
        jData, _ := json.Marshal(event.Body)
        err = json.Unmarshal(jData, &amp;heartbeat)
        if err != nil </span><span class="cov0" title="0">{
                err = v1alpha2.NewCOAError(nil, "event body is not a heart beat", v1alpha2.BadRequest)
                return err
        }</span>
        // TODO: the heart beat data should contain a "finished" field so data can be cleared
        <span class="cov8" title="1">_, err = s.StateProvider.Upsert(ctx, states.UpsertRequest{
                Value: states.StateEntry{
                        ID:   "h_" + heartbeat.JobId,
                        Body: heartbeat,
                },
        })
        return err</span>
}

func (s *JobsManager) DelayOrSkipJob(ctx context.Context, objectType string, job v1alpha2.JobData) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Job Manager", ctx, &amp;map[string]string{
                "method": "DelayOrSkipJob",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        key := "h_" + job.Id
        if objectType == "target" </span><span class="cov8" title="1">{
                key = fmt.Sprintf("h_%s-%s", "target-runtime", job.Id)
        }</span>
        //check if a manager is working on the job
        <span class="cov8" title="1">entry, err := s.StateProvider.Get(ctx, states.GetRequest{
                ID: key,
        })
        if err != nil </span><span class="cov8" title="1">{
                if !v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span> // no heartbeat
        }
        <span class="cov8" title="1">var heartbeat v1alpha2.HeartBeatData
        jData, _ := json.Marshal(entry.Body)
        err = json.Unmarshal(jData, &amp;heartbeat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if time.Since(heartbeat.Time) &gt; time.Duration(60)*time.Second </span><span class="cov8" title="1">{ //TODO: make this configurable
                // heartbeat is too old
                return nil
        }</span>
        // job.Action is upper case and heartbeat.Action is lower case, use case insensitive comparison
        <span class="cov8" title="1">if strings.EqualFold(job.Action, "delete") &amp;&amp; strings.EqualFold(heartbeat.Action, "update") </span><span class="cov0" title="0">{
                err = v1alpha2.NewCOAError(nil, "delete job is delayed", v1alpha2.Delayed)
                return err
        }</span>
        <span class="cov8" title="1">err = v1alpha2.NewCOAError(nil, "existing job in progress", v1alpha2.Untouched)
        return err</span>
}
func (s *JobsManager) HandleScheduleEvent(ctx context.Context, event v1alpha2.Event) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Job Manager", ctx, &amp;map[string]string{
                "method": "HandleScheduleEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        var activationData v1alpha2.ActivationData
        jData, _ := json.Marshal(event.Body)
        err = json.Unmarshal(jData, &amp;activationData)
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "event body is not a activation data", v1alpha2.BadRequest)
        }</span>
        <span class="cov8" title="1">key := fmt.Sprintf("sch_%s-%s", activationData.Campaign, activationData.Activation)
        _, err = s.StateProvider.Upsert(ctx, states.UpsertRequest{
                Value: states.StateEntry{
                        ID:   key,
                        Body: activationData,
                },
        })
        return err</span>
}
func (s *JobsManager) HandleJobEvent(ctx context.Context, event v1alpha2.Event) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Job Manager", ctx, &amp;map[string]string{
                "method": "HandleJobEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        scope := model.ReadProperty(event.Metadata, "scope", nil)
        if scope == "" </span><span class="cov8" title="1">{
                scope = "default"
        }</span>

        <span class="cov8" title="1">if objectType, ok := event.Metadata["objectType"]; ok </span><span class="cov8" title="1">{
                var job v1alpha2.JobData
                var baseUrl string
                var user string
                var password string
                jData, _ := json.Marshal(event.Body)
                err = json.Unmarshal(jData, &amp;job)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, "event body is not a job", v1alpha2.BadRequest)
                }</span>

                <span class="cov8" title="1">err = s.DelayOrSkipJob(ctx, objectType, job)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">baseUrl, err = utils.GetString(s.Manager.Config.Properties, "baseUrl")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">user, err = utils.GetString(s.Manager.Config.Properties, "user")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">password, err = utils.GetString(s.Manager.Config.Properties, "password")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">switch objectType </span>{
                case "instance":<span class="cov8" title="1">
                        instanceName := job.Id
                        var instance model.InstanceState
                        //get intance
                        instance, err := utils.GetInstance(ctx, baseUrl, instanceName, user, password, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                return err //TODO: instance is gone
                        }</span>

                        <span class="cov8" title="1">if instance.Status == nil </span><span class="cov8" title="1">{
                                instance.Status = make(map[string]string)
                        }</span>

                        //get solution
                        <span class="cov8" title="1">solution, err := utils.GetSolution(ctx, baseUrl, instance.Spec.Solution, user, password, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                solution = model.SolutionState{
                                        Id: instance.Spec.Solution,
                                        Spec: &amp;model.SolutionSpec{
                                                Components: make([]model.ComponentSpec, 0),
                                        },
                                }
                        }</span>

                        //get targets
                        <span class="cov8" title="1">var targets []model.TargetState
                        targets, err = utils.GetTargets(ctx, baseUrl, user, password, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                targets = make([]model.TargetState, 0)
                        }</span>

                        //get target candidates
                        <span class="cov8" title="1">targetCandidates := utils.MatchTargets(instance, targets)

                        //create deployment spec
                        var deployment model.DeploymentSpec
                        deployment, err = utils.CreateSymphonyDeployment(instance, solution, targetCandidates, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        //call api
                        <span class="cov8" title="1">if job.Action == "UPDATE" </span><span class="cov8" title="1">{
                                _, err := utils.Reconcile(ctx, baseUrl, user, password, deployment, scope, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov8" title="1"> {
                                        s.StateProvider.Upsert(ctx, states.UpsertRequest{
                                                Value: states.StateEntry{
                                                        ID: "i_" + instance.Id,
                                                        Body: LastSuccessTime{
                                                                Time: time.Now().UTC(),
                                                        },
                                                },
                                        })
                                }</span>
                        }
                        <span class="cov8" title="1">if job.Action == "DELETE" </span><span class="cov0" title="0">{
                                _, err := utils.Reconcile(ctx, baseUrl, user, password, deployment, scope, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov0" title="0"> {
                                        return utils.DeleteInstance(ctx, baseUrl, deployment.Instance.Name, user, password, scope)
                                }</span>
                        }
                case "target":<span class="cov8" title="1">
                        targetName := job.Id
                        target, err := utils.GetTarget(ctx, baseUrl, targetName, user, password, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">var deployment model.DeploymentSpec
                        deployment, err = utils.CreateSymphonyDeploymentFromTarget(target)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if job.Action == "UPDATE" </span><span class="cov8" title="1">{
                                _, err := utils.Reconcile(ctx, baseUrl, user, password, deployment, scope, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov8" title="1"> {
                                        // TODO: how to handle status updates?
                                        s.StateProvider.Upsert(ctx, states.UpsertRequest{
                                                Value: states.StateEntry{
                                                        ID: "t_" + targetName,
                                                        Body: LastSuccessTime{
                                                                Time: time.Now().UTC(),
                                                        },
                                                },
                                        })
                                }</span>
                        }
                        <span class="cov8" title="1">if job.Action == "DELETE" </span><span class="cov0" title="0">{
                                _, err := utils.Reconcile(ctx, baseUrl, user, password, deployment, scope, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov0" title="0"> {
                                        return utils.DeleteTarget(ctx, baseUrl, targetName, user, password, scope)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package reference

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/reference"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/reporter"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/oliveagle/jsonpath"
)

type ReferenceManager struct {
        managers.Manager
        ReferenceProviders map[string]reference.IReferenceProvider
        StateProvider      states.IStateProvider
        Reporter           reporter.IReporter
        CacheLifespan      uint64
}

type CachedItem struct {
        Created time.Time
        Item    interface{}
}

func (s *ReferenceManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov8" title="1">{

        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">stateProvider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.StateProvider = stateProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">reportProvider, err := managers.GetReporter(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.Reporter = reportProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">ctx := contexts.ManagerContext{}
        err = ctx.Init(context, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.CacheLifespan = 60
        if val, ok := config.Properties["cacheLifespan"]; ok </span><span class="cov8" title="1">{
                if i, err := strconv.ParseUint(val, 10, 32); err == nil </span><span class="cov8" title="1">{
                        s.CacheLifespan = i
                }</span>
        }

        <span class="cov8" title="1">s.Context = &amp;ctx

        s.ReferenceProviders = make(map[string]reference.IReferenceProvider)

        for _, p := range providers </span><span class="cov8" title="1">{
                if kp, ok := p.(reference.IReferenceProvider); ok </span><span class="cov8" title="1">{
                        s.ReferenceProviders[kp.ReferenceType()] = kp
                        s.ReferenceProviders[kp.ReferenceType()].SetContext(s.Context)
                }</span>
        }

        <span class="cov8" title="1">s.StateProvider.SetContext(s.Context)
        return nil</span>
}

func (s *ReferenceManager) GetExt(refType string, namespace string, id1 string, group1 string, kind1 string, version1 string, id2 string, group2 string, kind2 string, version2 string, iteration string, alias string) ([]byte, error) <span class="cov8" title="1">{
        if group2 != "download" </span><span class="cov8" title="1">{
                data1, err := s.Get(refType, id1, namespace, group1, kind1, version1, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data2, err := s.Get(refType, id2, namespace, group2, kind2, version2, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return fillParameters(data1, data2, id1, alias)</span>
        } else<span class="cov8" title="1"> {
                data1, err := s.Get(refType, id1, namespace, group1, kind1, version1, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">obj := make(map[string]interface{}, 0)
                err = json.Unmarshal(data1, &amp;obj)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var specData []byte
                if v, ok := obj["spec"]; ok </span><span class="cov8" title="1">{
                        specData, err = json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, v1alpha2.NewCOAError(nil, "resolved object doesn't contain a 'spec' property", v1alpha2.InternalError)
                }</span>

                <span class="cov8" title="1">model := model.ModelSpec{}
                err = json.Unmarshal(specData, &amp;model)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">modelType := safeRead("model.type", model.Properties)
                if modelType != "customvision" </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, "only 'customvision' model type is supported", v1alpha2.InternalError)
                }</span>
                <span class="cov8" title="1">modelProject := safeRead("model.project", model.Properties)
                if modelProject == "" </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, "property 'model.project' is not found", v1alpha2.InternalError)
                }</span>
                <span class="cov8" title="1">modelEndpoint := safeRead("model.endpoint", model.Properties)
                if modelEndpoint == "" </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, "property 'model.endpoint' is not found", v1alpha2.InternalError)
                }</span>
                <span class="cov8" title="1">modelVersions := make(map[string]string)
                for k, v := range model.Properties </span><span class="cov8" title="1">{
                        if strings.HasPrefix(k, "model.version.") </span><span class="cov8" title="1">{
                                modelVersions[k] = v
                        }</span>
                }
                <span class="cov8" title="1">if len(modelVersions) == 0 </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, "no model version are found", v1alpha2.InternalError)
                }</span>
                <span class="cov8" title="1">selection := ""
                if iteration == "latest" </span><span class="cov8" title="1">{
                        selection = findLatest(modelVersions)
                }</span> else<span class="cov0" title="0"> {
                        if v, ok := modelVersions["model.version."+iteration]; ok </span><span class="cov0" title="0">{
                                selection = v
                        }</span>
                }
                <span class="cov8" title="1">if selection == "" </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("requested version 'model.version.%s' is not found", iteration), v1alpha2.InternalError)
                }</span>

                <span class="cov8" title="1">downloadData, err := s.Get("v1alpha2.CustomVision", modelProject, modelEndpoint, kind2, version2, selection, "", "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return downloadData, nil</span>
        }
}
func findLatest(dict map[string]string) string <span class="cov8" title="1">{
        largest := 0
        ret := ""
        for k, v := range dict </span><span class="cov8" title="1">{
                vk := k[14:]
                i, err := strconv.Atoi(vk)
                if err == nil &amp;&amp; i &gt;= largest </span><span class="cov8" title="1">{
                        largest = i
                        ret = v
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func safeRead(key string, dict map[string]string) string <span class="cov8" title="1">{
        if v, ok := dict[key]; ok </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (s *ReferenceManager) Get(refType string, id string, namespace string, group string, kind string, version string, labelSelector string, fieldSelector string) ([]byte, error) <span class="cov8" title="1">{
        var entityId string
        if labelSelector != "" || fieldSelector != "" </span><span class="cov0" title="0">{
                entityId = fmt.Sprintf("%s-%s-%s-%s-%s-%s-%s", refType, labelSelector, fieldSelector, namespace, group, kind, version)
        }</span> else<span class="cov8" title="1"> {
                entityId = fmt.Sprintf("%s-%s-%s-%s-%s-%s", refType, id, namespace, group, kind, version)
        }</span>
        <span class="cov8" title="1">entity, err := s.StateProvider.Get(context.TODO(), states.GetRequest{
                ID: entityId,
        })
        if err == nil </span><span class="cov8" title="1">{
                data, _ := json.Marshal(entity.Body)
                cachedItem := CachedItem{}
                if err == nil </span><span class="cov8" title="1">{
                        err := json.Unmarshal(data, &amp;cachedItem)
                        if err == nil </span><span class="cov8" title="1">{
                                if time.Since(cachedItem.Created).Seconds() &lt;= float64(s.CacheLifespan) </span><span class="cov8" title="1">{
                                        cacheData, _ := json.Marshal(cachedItem.Item)
                                        return cacheData, nil
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">var provider reference.IReferenceProvider
        if p, ok := s.ReferenceProviders[refType]; ok </span><span class="cov8" title="1">{
                provider = p
        }</span> else<span class="cov8" title="1"> if len(s.ReferenceProviders) == 1 </span><span class="cov8" title="1">{
                for _, v := range s.ReferenceProviders </span><span class="cov8" title="1">{
                        provider = v
                        break</span>
                }
        } else<span class="cov0" title="0"> {
                return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("reference provider for '%s' is not configured", refType), v1alpha2.InternalError)
        }</span>

        <span class="cov8" title="1">var ref interface{}
        if labelSelector != "" || fieldSelector != "" </span><span class="cov0" title="0">{
                ref, err = provider.List(labelSelector, fieldSelector, namespace, group, kind, version, refType)
        }</span> else<span class="cov8" title="1"> {
                ref, err = provider.Get(id, namespace, group, kind, version, refType)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">s.StateProvider.Upsert(context.Background(), states.UpsertRequest{
                Value: states.StateEntry{
                        ID: entityId,
                        Body: CachedItem{
                                Created: time.Now(),
                                Item:    ref,
                        },
                },
        })
        refData, _ := json.Marshal(ref)
        return refData, nil</span>

}

func (s *ReferenceManager) Report(id string, namespace string, group string, kind string, version string, properties map[string]string, overwrite bool) error <span class="cov0" title="0">{
        return s.Reporter.Report(id, namespace, group, kind, version, properties, overwrite)
}</span>
func (s *ReferenceManager) Enabled() bool <span class="cov8" title="1">{
        return s.Config.Properties["poll.enabled"] == "true"
}</span>
func (s *ReferenceManager) Poll() []error <span class="cov8" title="1">{
        return nil
}</span>

func (s *ReferenceManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>

func fillParameters(data1 []byte, data2 []byte, id string, alias string) ([]byte, error) <span class="cov8" title="1">{
        params1, err := getParameterMap(data1, "", "") //parameters in skill
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">params2, err := getParameterMap(data2, id, alias) // parameters in instance
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // for k, _ := range params1 {
        //         key := id + "." + k
        //         if alias != "" {
        //                 key = id + "." + alias + "." + k
        //         }
        //         if v2, ok := params2[key]; ok {
        //                 params1[k] = v2
        //         }
        // }
        <span class="cov8" title="1">for k, _ := range params1 </span><span class="cov8" title="1">{
                if v2, ok := params2[k]; ok </span><span class="cov8" title="1">{
                        params1[k] = v2
                }</span>
        }
        <span class="cov8" title="1">strData := string(data1)
        for k, v := range params1 </span><span class="cov8" title="1">{
                strData = strings.ReplaceAll(strData, "$param("+k+")", v) //TODO: this needs to use property expression syntax instead of string replaces
        }</span>
        <span class="cov8" title="1">return []byte(strData), nil</span>
}
func getParameterMap(data []byte, skill string, alias string) (map[string]string, error) <span class="cov8" title="1">{
        var obj interface{}
        dict := make(map[string]string)
        err := json.Unmarshal(data, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">params, err := jsonpath.JsonPathLookup(obj, "$.parameters")
        if err == nil </span><span class="cov8" title="1">{
                coll := params.(map[string]interface{})
                for k, p := range coll </span><span class="cov8" title="1">{
                        dict[k] = p.(string)
                }</span>
        }
        <span class="cov8" title="1">params, err = jsonpath.JsonPathLookup(obj, "$.spec.parameters")
        if err == nil </span><span class="cov0" title="0">{
                coll := params.(map[string]interface{})
                for k, p := range coll </span><span class="cov0" title="0">{
                        dict[k] = p.(string)
                }</span>
        }
        <span class="cov8" title="1">if skill != "" &amp;&amp; alias != "" </span><span class="cov8" title="1">{
                params, err = jsonpath.JsonPathLookup(obj, fmt.Sprintf("$.pipelines[?(@.name == '%s' &amp;&amp; @.skill == '%s')].parameters", skill, alias))
                if err == nil </span><span class="cov8" title="1">{
                        coll := params.([]interface{})
                        for _, p := range coll </span><span class="cov8" title="1">{
                                pk := p.(map[string]interface{})
                                for k, v := range pk </span><span class="cov8" title="1">{
                                        dict[k] = v.(string)
                                }</span>
                        }
                }
                <span class="cov8" title="1">params, err = jsonpath.JsonPathLookup(obj, fmt.Sprintf("$.spec.pipelines[?(@.name == '%s' &amp;&amp; @.skill == '%s')].parameters", skill, alias))
                if err == nil </span><span class="cov0" title="0">{
                        coll := params.([]interface{})
                        for _, p := range coll </span><span class="cov0" title="0">{
                                pk := p.(map[string]interface{})
                                for k, v := range pk </span><span class="cov0" title="0">{
                                        dict[k] = v.(string)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return dict, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package sites

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
)

type SitesManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *SitesManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetCampaign retrieves a CampaignSpec object by name
func (m *SitesManager) GetSpec(ctx context.Context, name string) (model.SiteState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Sites Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: name,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "sites",
                },
        }
        entry, err := m.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                return model.SiteState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getSiteState(name, entry.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.SiteState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func getSiteState(id string, body interface{}) (model.SiteState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]
        status := dict["status"]

        j, _ := json.Marshal(spec)
        var rSpec model.SiteSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.SiteState{}, err
        }</span>

        <span class="cov8" title="1">var rStatus model.SiteStatus

        if status != nil </span><span class="cov8" title="1">{
                j, _ = json.Marshal(status)
                err = json.Unmarshal(j, &amp;rStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return model.SiteState{}, err
                }</span>
        }
        <span class="cov8" title="1">state := model.SiteState{
                Id:     id,
                Spec:   &amp;rSpec,
                Status: &amp;rStatus,
        }
        return state, nil</span>
}

func (t *SitesManager) ReportState(ctx context.Context, current model.SiteState) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Sites Manager", ctx, &amp;map[string]string{
                "method": "ReportState",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        current.Metadata = map[string]string{
                "version":  "v1",
                "group":    model.FederationGroup,
                "resource": "sites",
        }
        getRequest := states.GetRequest{
                ID: current.Id,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "sites",
                },
        }

        entry, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                if !v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = t.UpsertSpec(ctx, current.Id, *current.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">entry, err = t.StateProvider.Get(ctx, getRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // This copy is necessary becasue otherwise you could be modifying data in memory stage provider
        <span class="cov8" title="1">jTransfer, _ := json.Marshal(entry.Body)
        var dict map[string]interface{}
        json.Unmarshal(jTransfer, &amp;dict)

        delete(dict, "spec")
        status := dict["status"]

        j, _ := json.Marshal(status)
        var rStatus model.SiteStatus
        err = json.Unmarshal(j, &amp;rStatus)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // if current.Status is not nil, update the status using new IsOnline, InstanceStatuses and TargetStatuses
        // otherwise, only update LastReported as time.Now()
        <span class="cov8" title="1">if current.Status != nil </span><span class="cov8" title="1">{
                rStatus.IsOnline = current.Status.IsOnline
                rStatus.InstanceStatuses = current.Status.InstanceStatuses
                rStatus.TargetStatuses = current.Status.TargetStatuses
        }</span>
        <span class="cov8" title="1">rStatus.LastReported = time.Now().UTC().Format(time.RFC3339)
        dict["status"] = rStatus

        entry.Body = dict

        updateRequest := states.UpsertRequest{
                Value:    entry,
                Metadata: current.Metadata,
        }

        _, err = t.StateProvider.Upsert(ctx, updateRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *SitesManager) UpsertSpec(ctx context.Context, name string, spec model.SiteSpec) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Sites Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.FederationGroup + "/v1",
                                "kind":       "Site",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Site", "metadata": {"name": "${{$site()}}"}}`, model.FederationGroup),
                        "scope":    "",
                        "group":    model.FederationGroup,
                        "version":  "v1",
                        "resource": "sites",
                },
        }
        _, err = m.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *SitesManager) DeleteSpec(ctx context.Context, name string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Sites Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = m.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    "",
                        "group":    model.FederationGroup,
                        "version":  "v1",
                        "resource": "sites",
                },
        })

        return err
}</span>

func (t *SitesManager) ListSpec(ctx context.Context) ([]model.SiteState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Sites Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "sites",
                },
        }
        sites, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.SiteState, 0)
        for _, t := range sites </span><span class="cov8" title="1">{
                var rt model.SiteState
                rt, err = getSiteState(t.ID, t.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (s *SitesManager) Enabled() bool <span class="cov0" title="0">{
        return s.VendorContext.SiteInfo.ParentSite.BaseUrl != ""
}</span>
func (s *SitesManager) Poll() []error <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("Sites Manager", context.Background(), &amp;map[string]string{
                "method": "Poll",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        thisSite, err := s.GetSpec(ctx, s.VendorContext.SiteInfo.SiteId)
        if err != nil </span><span class="cov0" title="0">{
                //TOOD: only ignore not found, and log the error
                return nil
        }</span>
        <span class="cov0" title="0">thisSite.Spec.IsSelf = false
        jData, _ := json.Marshal(thisSite)
        utils.UpdateSite(
                ctx,
                s.VendorContext.SiteInfo.ParentSite.BaseUrl,
                s.VendorContext.SiteInfo.SiteId,
                s.VendorContext.SiteInfo.ParentSite.Username,
                s.VendorContext.SiteInfo.ParentSite.Password,
                jData,
        )
        return nil</span>
}
func (s *SitesManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package solution

import (
        "fmt"
        "sort"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
)

func PlanForDeployment(deployment model.DeploymentSpec, state model.DeploymentState) (model.DeploymentPlan, error) <span class="cov8" title="1">{
        ret := model.DeploymentPlan{
                Steps: make([]model.DeploymentStep, 0),
        }
        for _, c := range state.Components </span><span class="cov8" title="1">{
                for _, t := range state.Targets </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%s::%s", c.Name, t.Name) //TODO: this assumes provider/component keys don't contain "::"
                        if v, ok := state.TargetComponent[key]; ok </span><span class="cov8" title="1">{
                                role := c.Type
                                if role == "" </span><span class="cov8" title="1">{
                                        role = "instance"
                                }</span>
                                <span class="cov8" title="1">action := "update"
                                if strings.HasPrefix(v, "-") </span><span class="cov0" title="0">{
                                        action = "delete"
                                }</span>
                                <span class="cov8" title="1">index := ret.FindLastTargetRole(t.Name, c.Type)
                                if index &lt; 0 || !ret.CanAppendToStep(index, c) </span><span class="cov8" title="1">{
                                        ret.Steps = append(ret.Steps, model.DeploymentStep{
                                                Target:  t.Name,
                                                Role:    role,
                                                IsFirst: index &lt; 0,
                                                Components: []model.ComponentStep{
                                                        {
                                                                Action:    action,
                                                                Component: c,
                                                        },
                                                },
                                        })
                                }</span> else<span class="cov8" title="1"> {
                                        ret.Steps[index].Components = append(ret.Steps[index].Components, model.ComponentStep{
                                                Action:    action,
                                                Component: c,
                                        })
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret.RevisedForDeletion(), nil</span>
}

func NewDeploymentState(deployment model.DeploymentSpec) (model.DeploymentState, error) <span class="cov8" title="1">{
        ret := model.DeploymentState{
                Components:      make([]model.ComponentSpec, 0),
                Targets:         make([]model.TargetDesc, 0),
                TargetComponent: make(map[string]string),
        }

        components, err := sortByDepedencies(deployment.Solution.Components)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">for _, component := range components </span><span class="cov8" title="1">{
                ret.Components = append(ret.Components, component)

                providers := findComponentProviders(component.Name, deployment)
                for k, v := range providers </span><span class="cov8" title="1">{
                        found := false
                        for _, t := range ret.Targets </span><span class="cov8" title="1">{
                                if t.Name == k </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                ret.Targets = append(ret.Targets, model.TargetDesc{Name: k, Spec: v})
                        }</span>
                        <span class="cov8" title="1">t := component.Type
                        if t == "" </span><span class="cov8" title="1">{
                                t = "instance"
                        }</span>
                        <span class="cov8" title="1">ret.TargetComponent[fmt.Sprintf("%s::%s", component.Name, k)] = t</span> //TODO: this assumes provider/component keys don't contain "::"
                }
        }

        <span class="cov8" title="1">sort.Sort(model.ByTargetName(ret.Targets)) //sort target by name for easier testing

        return ret, nil</span>
}
func MergeDeploymentStates(previous *model.DeploymentState, current model.DeploymentState) model.DeploymentState <span class="cov8" title="1">{
        if previous == nil </span><span class="cov0" title="0">{
                return current
        }</span>
        // merge components
        <span class="cov8" title="1">for _, c := range previous.Components </span><span class="cov8" title="1">{
                found := false
                for _, cc := range current.Components </span><span class="cov8" title="1">{
                        if cc.Name == c.Name </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        current.Components = append(current.Components, c)
                }</span>
        }
        // merge targets
        <span class="cov8" title="1">for _, t := range previous.Targets </span><span class="cov8" title="1">{
                found := false
                for _, tt := range current.Targets </span><span class="cov8" title="1">{
                        if tt.Name == t.Name </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        current.Targets = append(current.Targets, t)
                }</span>
        }
        // merge state matrix
        <span class="cov8" title="1">for k, v := range previous.TargetComponent </span><span class="cov8" title="1">{
                if _, ok := current.TargetComponent[k]; !ok </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(v, "-") </span><span class="cov8" title="1">{
                                current.TargetComponent[k] = "-" + v
                        }</span>
                }
        }
        <span class="cov8" title="1">return current</span>
}
func findComponentProviders(component string, deployment model.DeploymentSpec) map[string]model.TargetSpec <span class="cov8" title="1">{
        ret := make(map[string]model.TargetSpec)
        for k, v := range deployment.Assignments </span><span class="cov8" title="1">{
                if v != "" </span><span class="cov8" title="1">{
                        if strings.Contains(v, "{"+component+"}") </span><span class="cov8" title="1">{
                                if t, ok := deployment.Targets[k]; ok </span><span class="cov8" title="1">{
                                        ret[k] = t
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package solution

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        sp "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers"
        tgt "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target"
        api_utils "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        config "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/config"
        secret "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/secret"
        states "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")
var lock sync.Mutex

const (
        SYMPHONY_AGENT string = "/symphony-agent:"
        ENV_NAME       string = "SYMPHONY_AGENT_ADDRESS"
)

type SolutionManager struct {
        managers.Manager
        TargetProviders map[string]tgt.ITargetProvider
        StateProvider   states.IStateProvider
        ConfigProvider  config.IExtConfigProvider
        SecretProvoider secret.ISecretProvider
}

type SolutionManagerDeploymentState struct {
        Spec  model.DeploymentSpec  `json:"spec,omitempty"`
        State model.DeploymentState `json:"state,omitempty"`
}

func (s *SolutionManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{

        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.TargetProviders = make(map[string]tgt.ITargetProvider)
        for k, v := range providers </span><span class="cov0" title="0">{
                if p, ok := v.(tgt.ITargetProvider); ok </span><span class="cov0" title="0">{
                        s.TargetProviders[k] = p
                }</span>
        }

        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov0" title="0">configProvider, err := managers.GetExtConfigProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.ConfigProvider = configProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov0" title="0">secretProvider, err := managers.GetSecretProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.SecretProvoider = secretProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SolutionManager) getPreviousState(ctx context.Context, instance string, scope string) *SolutionManagerDeploymentState <span class="cov8" title="1">{
        state, err := s.StateProvider.Get(ctx, states.GetRequest{
                ID: instance,
                Metadata: map[string]string{
                        "scope": scope,
                },
        })
        if err == nil </span><span class="cov8" title="1">{
                var managerState SolutionManagerDeploymentState
                jData, _ := json.Marshal(state.Body)
                err = json.Unmarshal(jData, &amp;managerState)
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;managerState
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (s *SolutionManager) GetSummary(ctx context.Context, key string, scope string) (model.SummaryResult, error) <span class="cov8" title="1">{
        // lock.Lock()
        // defer lock.Unlock()

        iCtx, span := observability.StartSpan("Solution Manager", ctx, &amp;map[string]string{
                "method": "GetSummary",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Info(" M (Solution): get summary")

        state, err := s.StateProvider.Get(iCtx, states.GetRequest{
                ID: fmt.Sprintf("%s-%s", "summary", key),
                Metadata: map[string]string{
                        "scope": scope,
                },
        })
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf(" M (Solution): failed to get deployment summary[%s]: %+v", key, err)
                return model.SummaryResult{}, err
        }</span>

        <span class="cov8" title="1">var result model.SummaryResult
        jData, _ := json.Marshal(state.Body)
        err = json.Unmarshal(jData, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(" M (Solution): failed to deserailze deployment summary[%s]: %+v", key, err)
                return model.SummaryResult{}, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (s *SolutionManager) sendHeartbeat(id string, remove bool, stopCh chan struct{}) <span class="cov8" title="1">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        action := "update"
        if remove </span><span class="cov0" title="0">{
                action = "delete"
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.VendorContext.Publish("heartbeat", v1alpha2.Event{
                                Body: v1alpha2.HeartBeatData{
                                        JobId:  id,
                                        Action: action,
                                        Time:   time.Now().UTC(),
                                },
                        })</span>
                case &lt;-stopCh:<span class="cov8" title="1">
                        return</span> // Exit the goroutine when the stop signal is received
                }
        }
}

func (s *SolutionManager) Reconcile(ctx context.Context, deployment model.DeploymentSpec, remove bool, scope string) (model.SummarySpec, error) <span class="cov8" title="1">{
        lock.Lock()
        defer lock.Unlock()

        stopCh := make(chan struct{})
        defer close(stopCh)
        go s.sendHeartbeat(deployment.Instance.Name, remove, stopCh)

        iCtx, span := observability.StartSpan("Solution Manager", ctx, &amp;map[string]string{
                "method": "Reconcile",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Info(" M (Solution): reconciling")

        summary := model.SummarySpec{
                TargetResults: make(map[string]model.TargetResultSpec),
                TargetCount:   len(deployment.Targets),
                SuccessCount:  0,
        }

        if s.VendorContext != nil &amp;&amp; s.VendorContext.EvaluationContext != nil </span><span class="cov0" title="0">{
                context := s.VendorContext.EvaluationContext.Clone()
                context.DeploymentSpec = deployment
                context.Value = deployment
                context.Component = ""
                deployment, err = api_utils.EvaluateDeployment(*context)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if remove </span><span class="cov0" title="0">{
                        log.Infof(" M (Solution): skipped failure to evaluate deployment spec: %+v", err)
                }</span> else<span class="cov0" title="0"> {
                        summary.SummaryMessage = "failed to evaluate deployment spec: " + err.Error()
                        log.Errorf(" M (Solution): failed to evaluate deployment spec: %+v", err)
                        s.saveSummary(iCtx, deployment, summary, scope)
                        return summary, err
                }</span>
        }

        <span class="cov8" title="1">previousDesiredState := s.getPreviousState(iCtx, deployment.Instance.Name, scope)
        currentDesiredState, err := NewDeploymentState(deployment)
        if err != nil </span><span class="cov0" title="0">{
                summary.SummaryMessage = "failed to create target manager state from deployment spec: " + err.Error()
                log.Errorf(" M (Solution): failed to create target manager state from deployment spec: %+v", err)
                s.saveSummary(iCtx, deployment, summary, scope)
                return summary, err
        }</span>
        <span class="cov8" title="1">currentState, _, err := s.Get(iCtx, deployment)
        if err != nil </span><span class="cov8" title="1">{
                summary.SummaryMessage = "failed to get current state: " + err.Error()
                log.Errorf(" M (Solution): failed to get current state: %+v", err)
                s.saveSummary(iCtx, deployment, summary, scope)
                return summary, err
        }</span>

        <span class="cov8" title="1">desiredState := currentDesiredState
        if previousDesiredState != nil </span><span class="cov8" title="1">{
                desiredState = MergeDeploymentStates(&amp;previousDesiredState.State, currentDesiredState)
        }</span>

        <span class="cov8" title="1">if remove </span><span class="cov0" title="0">{
                desiredState.MarkRemoveAll()
        }</span>

        <span class="cov8" title="1">mergedState := MergeDeploymentStates(&amp;currentState, desiredState)

        plan, err := PlanForDeployment(deployment, mergedState)
        if err != nil </span><span class="cov0" title="0">{
                summary.SummaryMessage = "failed to plan for deployment: " + err.Error()
                log.Errorf(" M (Solution): failed to plan for deployment: %+v", err)
                s.saveSummary(iCtx, deployment, summary, scope)
                return summary, err
        }</span>

        <span class="cov8" title="1">col := api_utils.MergeCollection(deployment.Solution.Metadata, deployment.Instance.Metadata)
        dep := deployment
        dep.Instance.Metadata = col
        someStepsRan := false

        for _, step := range plan.Steps </span><span class="cov8" title="1">{
                dep.ActiveTarget = step.Target
                agent := findAgent(deployment.Targets[step.Target])
                if agent != "" </span><span class="cov0" title="0">{
                        col[ENV_NAME] = agent
                }</span> else<span class="cov8" title="1"> {
                        delete(col, ENV_NAME)
                }</span>
                <span class="cov8" title="1">var override tgt.ITargetProvider
                if v, ok := s.TargetProviders[step.Target]; ok </span><span class="cov0" title="0">{
                        override = v
                }</span>
                <span class="cov8" title="1">var provider providers.IProvider
                provider, err = sp.CreateProviderForTargetRole(s.Context, step.Role, deployment.Targets[step.Target], override)
                if err != nil </span><span class="cov0" title="0">{
                        summary.SummaryMessage = "failed to create provider:" + err.Error()
                        log.Errorf(" M (Solution): failed to create provider: %+v", err)
                        s.saveSummary(ctx, deployment, summary, scope)
                        return summary, err
                }</span>

                <span class="cov8" title="1">if previousDesiredState != nil </span><span class="cov8" title="1">{
                        testState := MergeDeploymentStates(&amp;previousDesiredState.State, currentState)
                        if s.canSkipStep(iCtx, step, step.Target, provider.(tgt.ITargetProvider), previousDesiredState.State.Components, testState) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">someStepsRan = true
                retryCount := 1
                //TODO: set to 1 for now. Although retrying can help to handle transient errors, in more cases
                // an error condition can't be resolved quickly.
                var stepError error
                var componentResults map[string]model.ComponentResultSpec

                // for _, component := range step.Components {
                //         for k, v := range component.Component.Properties {
                //                 if strV, ok := v.(string); ok {
                //                         parser := api_utils.NewParser(strV)
                //                         eCtx := s.VendorContext.EvaluationContext.Clone()
                //                         eCtx.DeploymentSpec = deployment
                //                         eCtx.Component = component.Component.Name
                //                         val, err := parser.Eval(*eCtx)
                //                         if err == nil {
                //                                 component.Component.Properties[k] = val
                //                         } else {
                //                                 log.Errorf(" M (Solution): failed to evaluate property: %+v", err)
                //                                 summary.SummaryMessage = fmt.Sprintf("failed to evaluate property '%s' on component '%s: %s", k, component.Component.Name, err.Error())
                //                                 s.saveSummary(ctx, deployment, summary)
                //                                 observ_utils.CloseSpanWithError(span, &amp;err)
                //                                 return summary, err
                //                         }
                //                 }
                //         }
                // }

                for i := 0; i &lt; retryCount; i++ </span><span class="cov8" title="1">{
                        componentResults, stepError = (provider.(tgt.ITargetProvider)).Apply(iCtx, dep, step, false)
                        if stepError == nil </span><span class="cov8" title="1">{
                                summary.UpdateTargetResult(step.Target, model.TargetResultSpec{Status: "OK", Message: "", ComponentResults: componentResults})
                                break</span>
                        } else<span class="cov0" title="0"> {
                                summary.UpdateTargetResult(step.Target, model.TargetResultSpec{Status: "Error", Message: stepError.Error(), ComponentResults: componentResults}) // TODO: this keeps only the last error on the target
                                time.Sleep(5 * time.Second)                                                                                                                      //TODO: make this configurable?
                        }</span>
                }
                <span class="cov8" title="1">if stepError != nil </span><span class="cov0" title="0">{
                        log.Errorf(" M (Solution): failed to execute deployment step: %+v", stepError)
                        s.saveSummary(iCtx, deployment, summary, scope)
                        err = stepError
                        return summary, err
                }</span>
        }

        <span class="cov8" title="1">mergedState.ClearAllRemoved()

        // TODO: delete the state if the mergedState is empty (doesn't have any ComponentTarget assignements)
        s.StateProvider.Upsert(iCtx, states.UpsertRequest{
                Value: states.StateEntry{
                        ID: deployment.Instance.Name,
                        Body: SolutionManagerDeploymentState{
                                Spec:  deployment,
                                State: mergedState,
                        },
                },
                Metadata: map[string]string{
                        "scope": scope,
                },
        })

        summary.Skipped = !someStepsRan
        if summary.Skipped </span><span class="cov8" title="1">{
                summary.SuccessCount = summary.TargetCount
        }</span>
        <span class="cov8" title="1">summary.IsRemoval = remove
        s.saveSummary(iCtx, deployment, summary, scope)
        return summary, nil</span>
}
func (s *SolutionManager) saveSummary(ctx context.Context, deployment model.DeploymentSpec, summary model.SummarySpec, scope string) <span class="cov8" title="1">{
        // TODO: delete this state when time expires. This should probably be invoked by the vendor (via GetSummary method, for instance)
        s.StateProvider.Upsert(ctx, states.UpsertRequest{
                Value: states.StateEntry{
                        ID: fmt.Sprintf("%s-%s", "summary", deployment.Instance.Name),
                        Body: model.SummaryResult{
                                Summary:    summary,
                                Generation: deployment.Generation,
                                Time:       time.Now().UTC(),
                        },
                },
                Metadata: map[string]string{
                        "scope": scope,
                },
        })
}</span>
func (s *SolutionManager) canSkipStep(ctx context.Context, step model.DeploymentStep, target string, provider tgt.ITargetProvider, currentComponents []model.ComponentSpec, state model.DeploymentState) bool <span class="cov8" title="1">{

        for _, newCom := range step.Components </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s::%s", newCom.Component.Name, target)
                if newCom.Action == "delete" </span><span class="cov0" title="0">{
                        for _, c := range currentComponents </span><span class="cov0" title="0">{
                                if c.Name == newCom.Component.Name &amp;&amp; state.TargetComponent[key] != "" </span><span class="cov0" title="0">{
                                        return false // current component still exists, desired is to remove it. The step can't be skipped
                                }</span>
                        }

                } else<span class="cov8" title="1"> {
                        found := false
                        for _, c := range currentComponents </span><span class="cov8" title="1">{
                                if c.Name == newCom.Component.Name &amp;&amp; state.TargetComponent[key] != "" &amp;&amp; !strings.HasPrefix(state.TargetComponent[key], "-") </span><span class="cov8" title="1">{
                                        found = true
                                        rule := provider.GetValidationRule(ctx)
                                        if rule.IsComponentChanged(c, newCom.Component) </span><span class="cov0" title="0">{
                                                return false // component has changed, can't skip the step
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                return false //current component doesn't exist, desired is to update it. The step can't be skipped
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}
func (s *SolutionManager) Get(ctx context.Context, deployment model.DeploymentSpec) (model.DeploymentState, []model.ComponentSpec, error) <span class="cov8" title="1">{
        iCtx, span := observability.StartSpan("Solution Manager", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        log.Info(" M (Solution): getting deployment")

        ret := model.DeploymentState{}

        state, err := NewDeploymentState(deployment)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(" M (Solution): failed to create manager state for deployment: %+v", err)
                return ret, nil, err
        }</span>
        <span class="cov8" title="1">plan, err := PlanForDeployment(deployment, state)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(" M (Solution): failed to plan for deployment: %+v", err)
                return ret, nil, err
        }</span>
        <span class="cov8" title="1">ret = state
        ret.TargetComponent = make(map[string]string)
        retComponents := make([]model.ComponentSpec, 0)
        for _, step := range plan.Steps </span><span class="cov8" title="1">{
                var override tgt.ITargetProvider
                if v, ok := s.TargetProviders[step.Target]; ok </span><span class="cov0" title="0">{
                        override = v
                }</span>
                <span class="cov8" title="1">var provider providers.IProvider
                provider, err = sp.CreateProviderForTargetRole(s.Context, step.Role, deployment.Targets[step.Target], override)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf(" M (Solution): failed to create provider: %+v", err)
                        return ret, nil, err
                }</span>
                <span class="cov8" title="1">var components []model.ComponentSpec
                components, err = (provider.(tgt.ITargetProvider)).Get(iCtx, deployment, step.Components)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf(" M (Solution): failed to get: %+v", err)
                        return ret, nil, err
                }</span>
                <span class="cov8" title="1">for _, c := range components </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%s::%s", c.Name, step.Target)
                        role := c.Type
                        if role == "" </span><span class="cov0" title="0">{
                                role = "container"
                        }</span>
                        <span class="cov8" title="1">ret.TargetComponent[key] = role
                        found := false
                        for _, rc := range retComponents </span><span class="cov8" title="1">{
                                if rc.Name == c.Name </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                retComponents = append(retComponents, c)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret, retComponents, nil</span>
}
func (s *SolutionManager) Enabled() bool <span class="cov0" title="0">{
        return false
}</span>
func (s *SolutionManager) Poll() []error <span class="cov0" title="0">{
        return nil
}</span>
func (s *SolutionManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>
func findAgent(target model.TargetSpec) string <span class="cov8" title="1">{
        for _, c := range target.Components </span><span class="cov8" title="1">{
                if v, ok := c.Properties[model.ContainerImage]; ok </span><span class="cov8" title="1">{
                        if strings.Contains(fmt.Sprintf("%v", v), SYMPHONY_AGENT) </span><span class="cov8" title="1">{
                                return c.Name
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}
func sortByDepedencies(components []model.ComponentSpec) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        size := len(components)
        inDegrees := make([]int, size)
        queue := make([]int, 0)
        for i, c := range components </span><span class="cov8" title="1">{
                inDegrees[i] = len(c.Dependencies)
                if inDegrees[i] == 0 </span><span class="cov8" title="1">{
                        queue = append(queue, i)
                }</span>
        }
        <span class="cov8" title="1">ret := make([]model.ComponentSpec, 0)
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                ret = append(ret, components[queue[0]])
                queue = queue[1:]
                for i, c := range components </span><span class="cov8" title="1">{
                        found := false
                        for _, d := range c.Dependencies </span><span class="cov8" title="1">{
                                if d == ret[len(ret)-1].Name </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                                inDegrees[i] -= 1
                                if inDegrees[i] == 0 </span><span class="cov8" title="1">{
                                        queue = append(queue, i)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if len(ret) != size </span><span class="cov8" title="1">{
                return nil, errors.New("circular dependencies or unresolved dependencies detected in components")
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package solutions

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"

        observability "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
)

type SolutionsManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

func (s *SolutionsManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *SolutionsManager) DeleteSpec(ctx context.Context, name string, scope string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solutions Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = t.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    scope,
                        "group":    model.SolutionGroup,
                        "version":  "v1",
                        "resource": "solutions",
                },
        })
        return err
}</span>

func (t *SolutionsManager) UpsertSpec(ctx context.Context, name string, spec model.SolutionSpec, scope string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solutions Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.SolutionGroup + "/v1",
                                "kind":       "Solution",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Solution", "metadata": {"name": "${{$solution()}}"}}`, model.SolutionGroup),
                        "scope":    scope,
                        "group":    model.SolutionGroup,
                        "version":  "v1",
                        "resource": "solutions",
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        return err
}</span>

func (t *SolutionsManager) ListSpec(ctx context.Context, scope string) ([]model.SolutionState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solutions Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.SolutionGroup,
                        "resource": "solutions",
                        "scope":    scope,
                },
        }
        solutions, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.SolutionState, 0)
        for _, t := range solutions </span><span class="cov8" title="1">{
                var rt model.SolutionState
                rt, err = getSolutionState(t.ID, t.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func getSolutionState(id string, body interface{}) (model.SolutionState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]

        j, _ := json.Marshal(spec)
        var rSpec model.SolutionSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.SolutionState{}, err
        }</span>
        <span class="cov8" title="1">scope, exist := dict["scope"]
        var s string
        if !exist </span><span class="cov8" title="1">{
                s = "default"
        }</span> else<span class="cov0" title="0"> {
                s = scope.(string)
        }</span>

        <span class="cov8" title="1">state := model.SolutionState{
                Id:    id,
                Scope: s,
                Spec:  &amp;rSpec,
        }
        return state, nil</span>
}

func (t *SolutionsManager) GetSpec(ctx context.Context, id string, scope string) (model.SolutionState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solutions Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: id,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.SolutionGroup,
                        "resource": "solutions",
                        "scope":    scope,
                },
        }
        target, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                return model.SolutionState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getSolutionState(id, target.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.SolutionState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package stage

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "sync"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        symproviders "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/remote"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")

type StageManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

type TaskResult struct {
        Outputs map[string]interface{}
        Site    string
        Error   error
}

func (t *TaskResult) GetError() error <span class="cov8" title="1">{
        if t.Error != nil </span><span class="cov8" title="1">{
                return t.Error
        }</span>
        <span class="cov8" title="1">if v, ok := t.Outputs["__status"]; ok </span><span class="cov8" title="1">{
                switch sv := v.(type) </span>{
                case v1alpha2.State:<span class="cov8" title="1">
                        break</span>
                case int:<span class="cov8" title="1">
                        state := v1alpha2.State(sv)
                        stateValue := reflect.ValueOf(state)
                        if stateValue.Type() != reflect.TypeOf(v1alpha2.State(0)) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid state %d", sv)
                        }</span>
                        <span class="cov8" title="1">t.Outputs["__status"] = state</span>
                case string:<span class="cov8" title="1">
                        vInt, err := strconv.ParseInt(sv, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid state %s", sv)
                        }</span>
                        <span class="cov8" title="1">state := v1alpha2.State(vInt)
                        stateValue := reflect.ValueOf(state)
                        if stateValue.Type() != reflect.TypeOf(v1alpha2.State(0)) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid state %d", vInt)
                        }</span>
                        <span class="cov8" title="1">t.Outputs["__status"] = state</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid state %v", v)</span>
                }

                <span class="cov8" title="1">if t.Outputs["__status"] != v1alpha2.OK </span><span class="cov8" title="1">{
                        if v, ok := t.Outputs["__error"]; ok </span><span class="cov8" title="1">{
                                return v1alpha2.NewCOAError(nil, v.(string), t.Outputs["__status"].(v1alpha2.State))
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Errorf("stage returned unsuccessful status without an error")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

type PendingTask struct {
        Sites         []string                          `json:"sites"`
        OutputContext map[string]map[string]interface{} `json:"outputContext,omitempty"`
}

func (s *StageManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (s *StageManager) Enabled() bool <span class="cov0" title="0">{
        return s.Config.Properties["poll.enabled"] == "true"
}</span>
func (s *StageManager) Poll() []error <span class="cov0" title="0">{
        return nil
}</span>
func (s *StageManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>
func (s *StageManager) ResumeStage(status model.ActivationStatus, cam model.CampaignSpec) (*v1alpha2.ActivationData, error) <span class="cov8" title="1">{
        log.Debugf(" M (Stage): ResumeStage: %v\n", status)
        campaign := status.Outputs["__campaign"].(string)
        activation := status.Outputs["__activation"].(string)
        activationGeneration := status.Outputs["__activationGeneration"].(string)
        site := status.Outputs["__site"].(string)
        stage := status.Outputs["__stage"].(string)

        entry, err := s.StateProvider.Get(context.TODO(), states.GetRequest{
                ID: fmt.Sprintf("%s-%s-%s", campaign, activation, activationGeneration),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">jData, _ := json.Marshal(entry.Body)
        var p PendingTask
        err = json.Unmarshal(jData, &amp;p)
        if err == nil </span><span class="cov8" title="1">{
                // //find site in p.Sites
                // found := false
                // for _, s := range p.Sites {
                //         if s == site {
                //                 found = true
                //                 break
                //         }
                // }
                // if !found {
                //         return nil, fmt.Errorf("site %s is not found in pending task", site)
                // }
                //remove site from p.Sites
                newSites := make([]string, 0)
                for _, s := range p.Sites </span><span class="cov8" title="1">{
                        if s != site </span><span class="cov0" title="0">{
                                newSites = append(newSites, s)
                        }</span>
                }
                <span class="cov8" title="1">if len(newSites) == 0 </span><span class="cov8" title="1">{
                        err := s.StateProvider.Delete(context.TODO(), states.DeleteRequest{
                                ID: fmt.Sprintf("%s-%s-%s", campaign, activation, activationGeneration),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        //find the next stage
                        <span class="cov8" title="1">if cam.SelfDriving </span><span class="cov8" title="1">{
                                outputs := p.OutputContext
                                if outputs == nil </span><span class="cov0" title="0">{
                                        outputs = make(map[string]map[string]interface{})
                                }</span>
                                <span class="cov8" title="1">outputs[stage] = status.Outputs
                                nextStage := ""
                                if currentStage, ok := cam.Stages[stage]; ok </span><span class="cov8" title="1">{
                                        parser := utils.NewParser(currentStage.StageSelector)

                                        eCtx := s.VendorContext.EvaluationContext.Clone()
                                        eCtx.Inputs = status.Inputs
                                        log.Debugf(" M (Stage): ResumeStage evaluation inputs: %v", eCtx.Inputs)
                                        if eCtx.Inputs != nil </span><span class="cov0" title="0">{
                                                if v, ok := eCtx.Inputs["context"]; ok </span><span class="cov0" title="0">{
                                                        eCtx.Value = v
                                                }</span>
                                        }
                                        <span class="cov8" title="1">eCtx.Outputs = outputs
                                        val, err := parser.Eval(*eCtx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">sVal := ""
                                        if val != nil </span><span class="cov8" title="1">{
                                                sVal = val.(string)
                                        }</span>
                                        <span class="cov8" title="1">if sVal != "" </span><span class="cov8" title="1">{
                                                if _, ok := cam.Stages[sVal]; ok </span><span class="cov8" title="1">{
                                                        nextStage = sVal
                                                }</span> else<span class="cov0" title="0"> {
                                                        return nil, fmt.Errorf("stage %s is not found", sVal)
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">if nextStage != "" </span><span class="cov8" title="1">{
                                        activationData := &amp;v1alpha2.ActivationData{
                                                Campaign:             campaign,
                                                Activation:           activation,
                                                ActivationGeneration: activationGeneration,
                                                Stage:                nextStage,
                                                Inputs:               status.Inputs,
                                                Provider:             cam.Stages[nextStage].Provider,
                                                Config:               cam.Stages[nextStage].Config,
                                                Outputs:              outputs,
                                                TriggeringStage:      stage,
                                                Schedule:             cam.Stages[nextStage].Schedule,
                                        }
                                        log.Debugf(" M (Stage): Activating next stage: %s\n", activationData.Stage)
                                        return activationData, nil
                                }</span> else<span class="cov0" title="0"> {
                                        log.Debugf(" M (Stage): No next stage found\n")
                                        return nil, nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, nil</span>
                } else<span class="cov0" title="0"> {
                        p.Sites = newSites
                        _, err := s.StateProvider.Upsert(context.TODO(), states.UpsertRequest{
                                Value: states.StateEntry{
                                        ID:   fmt.Sprintf("%s-%s-%s", campaign, activation, activationGeneration),
                                        Body: p,
                                },
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("invalid pending task")
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}
func (s *StageManager) HandleDirectTriggerEvent(ctx context.Context, triggerData v1alpha2.ActivationData) model.ActivationStatus <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Stage Manager", ctx, &amp;map[string]string{
                "method": "HandleDirectTriggerEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        status := model.ActivationStatus{
                Stage:        "",
                NextStage:    "",
                Outputs:      map[string]interface{}{},
                Status:       v1alpha2.Untouched,
                ErrorMessage: "",
                IsActive:     true,
        }
        factory := symproviders.SymphonyProviderFactory{}
        provider, err := factory.CreateProvider(triggerData.Provider, triggerData.Config)
        if err != nil </span><span class="cov0" title="0">{
                status.Status = v1alpha2.InternalError
                status.ErrorMessage = err.Error()
                status.IsActive = false
                return status
        }</span>

        <span class="cov8" title="1">if _, ok := provider.(contexts.IWithManagerContext); ok </span><span class="cov8" title="1">{
                provider.(contexts.IWithManagerContext).SetContext(s.Manager.Context)
        }</span> else<span class="cov0" title="0"> {
                log.Errorf(" M (Stage): provider %s does not implement IWithManagerContext", triggerData.Provider)
        }</span>

        <span class="cov8" title="1">isRemote := false
        if _, ok := provider.(*remote.RemoteStageProvider); ok </span><span class="cov0" title="0">{
                isRemote = true
                provider.(*remote.RemoteStageProvider).SetOutputsContext(triggerData.Outputs)
        }</span>

        <span class="cov8" title="1">if triggerData.Schedule != nil &amp;&amp; !isRemote </span><span class="cov8" title="1">{
                s.Context.Publish("schedule", v1alpha2.Event{
                        Body: triggerData,
                })
                status.Outputs["__status"] = v1alpha2.Delayed
                status.Status = v1alpha2.Paused
                status.IsActive = false
                return status
        }</span>

        <span class="cov8" title="1">outputs, _, err := provider.(stage.IStageProvider).Process(ctx, *s.Manager.Context, triggerData.Inputs)

        result := TaskResult{
                Outputs: outputs,
                Error:   err,
                Site:    s.VendorContext.SiteInfo.SiteId,
        }

        err = result.GetError()
        if err != nil </span><span class="cov0" title="0">{
                status.Status = v1alpha2.InternalError
                status.ErrorMessage = err.Error()
                status.IsActive = false
                status.Outputs = carryOutPutsToErrorStatus(outputs, err, "")
                result.Outputs = carryOutPutsToErrorStatus(outputs, err, "")
                return status
        }</span>
        <span class="cov8" title="1">status.Outputs = outputs
        status.Outputs["__status"] = v1alpha2.OK
        status.Outputs["__campaign"] = triggerData.Campaign
        status.Outputs["__activation"] = triggerData.Activation
        status.Outputs["__activationGeneration"] = triggerData.ActivationGeneration
        status.Outputs["__stage"] = triggerData.Stage
        status.Outputs["__site"] = s.VendorContext.SiteInfo.SiteId
        status.Status = v1alpha2.Done
        status.IsActive = false
        return status</span>
}
func carryOutPutsToErrorStatus(outputs map[string]interface{}, err error, site string) map[string]interface{} <span class="cov8" title="1">{
        ret := make(map[string]interface{})
        statusKey := "__status"
        if site != "" </span><span class="cov0" title="0">{
                statusKey = fmt.Sprintf("%s.%s", statusKey, site)
        }</span>
        <span class="cov8" title="1">errorKey := "__error"
        if site != "" </span><span class="cov0" title="0">{
                errorKey = fmt.Sprintf("%s.%s", errorKey, site)
        }</span>
        <span class="cov8" title="1">for k, v := range outputs </span><span class="cov0" title="0">{
                ret[k] = v
        }</span>
        <span class="cov8" title="1">if _, ok := ret[statusKey]; !ok </span><span class="cov8" title="1">{
                if cErr, ok := err.(v1alpha2.COAError); ok </span><span class="cov8" title="1">{
                        ret[statusKey] = cErr.State
                }</span> else<span class="cov8" title="1"> {
                        ret[statusKey] = v1alpha2.InternalError
                }</span>
        }
        <span class="cov8" title="1">if _, ok := ret[errorKey]; !ok </span><span class="cov8" title="1">{
                ret[errorKey] = err.Error()
        }</span>
        <span class="cov8" title="1">return ret</span>
}
func (s *StageManager) HandleTriggerEvent(ctx context.Context, campaign model.CampaignSpec, triggerData v1alpha2.ActivationData) (model.ActivationStatus, *v1alpha2.ActivationData) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Stage Manager", ctx, &amp;map[string]string{
                "method": "HandleTriggerEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Info(" M (Stage): HandleTriggerEvent")
        status := model.ActivationStatus{
                Stage:        triggerData.Stage,
                NextStage:    "",
                Outputs:      nil,
                Status:       v1alpha2.Untouched,
                ErrorMessage: "",
                IsActive:     true,
        }
        var activationData *v1alpha2.ActivationData
        if currentStage, ok := campaign.Stages[triggerData.Stage]; ok </span><span class="cov8" title="1">{
                sites := make([]string, 0)
                if currentStage.Contexts != "" </span><span class="cov8" title="1">{
                        parser := utils.NewParser(currentStage.Contexts)

                        eCtx := s.VendorContext.EvaluationContext.Clone()
                        eCtx.Inputs = triggerData.Inputs
                        log.Debugf(" M (Stage): HandleTriggerEvent evaluation inputs 1: %v", eCtx.Inputs)
                        if eCtx.Inputs != nil </span><span class="cov8" title="1">{
                                if v, ok := eCtx.Inputs["context"]; ok </span><span class="cov0" title="0">{
                                        eCtx.Value = v
                                }</span>
                        }
                        <span class="cov8" title="1">eCtx.Outputs = triggerData.Outputs
                        var val interface{}
                        val, err = parser.Eval(*eCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                status.Status = v1alpha2.InternalError
                                status.ErrorMessage = err.Error()
                                status.IsActive = false
                                log.Errorf(" M (Stage): failed to evaluate context: %v", err)
                                return status, activationData
                        }</span>
                        <span class="cov8" title="1">if _, ok := val.([]string); ok </span><span class="cov0" title="0">{
                                sites = val.([]string)
                        }</span> else<span class="cov8" title="1"> if _, ok := val.([]interface{}); ok </span><span class="cov0" title="0">{
                                for _, v := range val.([]interface{}) </span><span class="cov0" title="0">{
                                        sites = append(sites, v.(string))
                                }</span>
                        } else<span class="cov8" title="1"> if _, ok := val.(string); ok </span><span class="cov8" title="1">{
                                sites = append(sites, val.(string))
                        }</span> else<span class="cov0" title="0"> {
                                status.Status = v1alpha2.InternalError
                                status.ErrorMessage = fmt.Sprintf("invalid context %s", currentStage.Contexts)
                                status.IsActive = false
                                log.Errorf(" M (Stage): invalid context: %v", currentStage.Contexts)
                                return status, activationData
                        }</span>
                } else<span class="cov8" title="1"> {
                        sites = append(sites, s.VendorContext.SiteInfo.SiteId)
                }</span>

                <span class="cov8" title="1">inputs := triggerData.Inputs
                if inputs == nil </span><span class="cov8" title="1">{
                        inputs = make(map[string]interface{})
                }</span>

                <span class="cov8" title="1">if currentStage.Inputs != nil </span><span class="cov8" title="1">{
                        for k, v := range currentStage.Inputs </span><span class="cov8" title="1">{
                                inputs[k] = v
                        }</span>
                }

                <span class="cov8" title="1">log.Debugf(" M (Stage): HandleTriggerEvent before evaluation inputs 2: %v", inputs)

                // inject default inputs
                inputs["__campaign"] = triggerData.Campaign
                inputs["__activation"] = triggerData.Activation
                inputs["__stage"] = triggerData.Stage
                inputs["__activationGeneration"] = triggerData.ActivationGeneration
                inputs["__previousStage"] = triggerData.TriggeringStage
                inputs["__site"] = s.VendorContext.SiteInfo.SiteId
                if triggerData.Schedule != nil </span><span class="cov8" title="1">{
                        jSchedule, _ := json.Marshal(triggerData.Schedule)
                        inputs["__schedule"] = string(jSchedule)
                }</span>
                <span class="cov8" title="1">for k, v := range inputs </span><span class="cov8" title="1">{
                        var val interface{}
                        val, err = s.traceValue(v, inputs, triggerData.Outputs)
                        if err != nil </span><span class="cov0" title="0">{
                                status.Status = v1alpha2.InternalError
                                status.ErrorMessage = err.Error()
                                status.IsActive = false
                                log.Errorf(" M (Stage): failed to evaluate input: %v", err)
                                return status, activationData
                        }</span>
                        <span class="cov8" title="1">inputs[k] = val</span>
                }

                <span class="cov8" title="1">if triggerData.Outputs != nil </span><span class="cov8" title="1">{
                        if v, ok := triggerData.Outputs[triggerData.Stage]; ok </span><span class="cov8" title="1">{
                                if vs, ok := v["__state"]; ok </span><span class="cov8" title="1">{
                                        inputs["__state"] = vs
                                }</span>
                        }
                }

                <span class="cov8" title="1">log.Debugf(" M (Stage): HandleTriggerEvent after evaluation inputs 2: %v", inputs)

                factory := symproviders.SymphonyProviderFactory{}
                var provider providers.IProvider
                provider, err = factory.CreateProvider(triggerData.Provider, triggerData.Config)
                if err != nil </span><span class="cov0" title="0">{
                        status.Status = v1alpha2.InternalError
                        status.ErrorMessage = err.Error()
                        status.IsActive = false
                        log.Errorf(" M (Stage): failed to create provider: %v", err)
                        return status, activationData
                }</span>

                <span class="cov8" title="1">if _, ok := provider.(contexts.IWithManagerContext); ok </span><span class="cov8" title="1">{
                        provider.(contexts.IWithManagerContext).SetContext(s.Manager.Context)
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf(" M (Stage): provider %s does not implement IWithManagerContext", triggerData.Provider)
                }</span>

                <span class="cov8" title="1">numTasks := len(sites)
                waitGroup := sync.WaitGroup{}
                results := make(chan TaskResult, numTasks)
                pauseRequested := false

                for _, site := range sites </span><span class="cov8" title="1">{
                        waitGroup.Add(1)
                        go func(wg *sync.WaitGroup, site string, results chan&lt;- TaskResult) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                inputCopy := make(map[string]interface{})
                                for k, v := range inputs </span><span class="cov8" title="1">{
                                        inputCopy[k] = v
                                }</span>
                                <span class="cov8" title="1">inputCopy["__site"] = site

                                for k, v := range inputCopy </span><span class="cov8" title="1">{
                                        var val interface{}
                                        val, err = s.traceValue(v, inputCopy, triggerData.Outputs)
                                        if err != nil </span><span class="cov0" title="0">{
                                                status.Status = v1alpha2.InternalError
                                                status.ErrorMessage = err.Error()
                                                status.IsActive = false
                                                log.Errorf(" M (Stage): failed to evaluate input: %v", err)
                                                results &lt;- TaskResult{
                                                        Outputs: nil,
                                                        Error:   err,
                                                        Site:    site,
                                                }
                                                return
                                        }</span>
                                        <span class="cov8" title="1">inputCopy[k] = val</span>
                                }

                                <span class="cov8" title="1">if _, ok := provider.(*remote.RemoteStageProvider); ok </span><span class="cov0" title="0">{
                                        provider.(*remote.RemoteStageProvider).SetOutputsContext(triggerData.Outputs)
                                }</span>

                                <span class="cov8" title="1">if triggerData.Schedule != nil </span><span class="cov8" title="1">{
                                        s.Context.Publish("schedule", v1alpha2.Event{
                                                Body: triggerData,
                                        })
                                        pauseRequested = true
                                        results &lt;- TaskResult{
                                                Outputs: nil,
                                                Error:   nil,
                                                Site:    site,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        var outputs map[string]interface{}
                                        var pause bool
                                        outputs, pause, err = provider.(stage.IStageProvider).Process(ctx, *s.Manager.Context, inputCopy)

                                        if pause </span><span class="cov0" title="0">{
                                                pauseRequested = true
                                        }</span>
                                        <span class="cov8" title="1">results &lt;- TaskResult{
                                                Outputs: outputs,
                                                Error:   err,
                                                Site:    site,
                                        }</span>
                                }
                        }(&amp;waitGroup, site, results)
                }

                <span class="cov8" title="1">waitGroup.Wait()
                close(results)

                outputs := make(map[string]interface{})
                delayedExit := false
                for result := range results </span><span class="cov8" title="1">{
                        err = result.GetError()
                        if err != nil </span><span class="cov8" title="1">{
                                status.Status = v1alpha2.InternalError
                                status.ErrorMessage = fmt.Sprintf("%s: %s", result.Site, err.Error())
                                status.IsActive = false
                                site := result.Site
                                if result.Site == s.Context.SiteInfo.SiteId </span><span class="cov8" title="1">{
                                        site = ""
                                }</span>
                                <span class="cov8" title="1">status.Outputs = carryOutPutsToErrorStatus(nil, err, site)
                                result.Outputs = carryOutPutsToErrorStatus(nil, err, site)
                                log.Errorf(" M (Stage): failed to process stage outputs: %v", err)
                                delayedExit = true</span>
                        }
                        <span class="cov8" title="1">for k, v := range result.Outputs </span><span class="cov8" title="1">{
                                if result.Site == s.Context.SiteInfo.SiteId </span><span class="cov8" title="1">{
                                        outputs[k] = v
                                }</span> else<span class="cov0" title="0"> {
                                        outputs[fmt.Sprintf("%s.%s", result.Site, k)] = v
                                }</span>
                        }
                        <span class="cov8" title="1">if result.Site == s.Context.SiteInfo.SiteId </span><span class="cov8" title="1">{
                                if _, ok := result.Outputs["__status"]; !ok </span><span class="cov8" title="1">{
                                        outputs["__status"] = v1alpha2.OK
                                }</span>
                        } else<span class="cov0" title="0"> {
                                key := fmt.Sprintf("%s.__status", result.Site)
                                if _, ok := result.Outputs[key]; !ok </span><span class="cov0" title="0">{
                                        outputs[fmt.Sprintf("%s.__status", result.Site)] = v1alpha2.OK
                                }</span>
                        }
                }
                <span class="cov8" title="1">outputs["__campaign"] = triggerData.Campaign
                outputs["__activation"] = triggerData.Activation
                outputs["__activationGeneration"] = triggerData.ActivationGeneration
                outputs["__stage"] = triggerData.Stage
                outputs["__site"] = s.VendorContext.SiteInfo.SiteId
                status.Outputs = outputs //TODO: This is newly added 10/3/2023, is this correct?
                if triggerData.Outputs == nil </span><span class="cov8" title="1">{
                        triggerData.Outputs = make(map[string]map[string]interface{})
                }</span>
                <span class="cov8" title="1">triggerData.Outputs[triggerData.Stage] = outputs
                if campaign.SelfDriving </span><span class="cov8" title="1">{
                        if pauseRequested </span><span class="cov8" title="1">{
                                pendingTask := PendingTask{
                                        Sites:         sites,
                                        OutputContext: triggerData.Outputs,
                                }
                                _, err = s.StateProvider.Upsert(ctx, states.UpsertRequest{
                                        Value: states.StateEntry{
                                                ID:   fmt.Sprintf("%s-%s-%s", triggerData.Campaign, triggerData.Activation, triggerData.ActivationGeneration),
                                                Body: pendingTask,
                                        },
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        status.Status = v1alpha2.InternalError
                                        status.ErrorMessage = err.Error()
                                        status.IsActive = false
                                        log.Errorf(" M (Stage): failed to save pending task: %v", err)
                                        return status, activationData
                                }</span>
                                <span class="cov8" title="1">status.Status = v1alpha2.Paused
                                status.IsActive = false
                                return status, activationData</span>
                        }

                        <span class="cov8" title="1">parser := utils.NewParser(currentStage.StageSelector)
                        eCtx := s.VendorContext.EvaluationContext.Clone()
                        eCtx.Inputs = triggerData.Inputs
                        if eCtx.Inputs != nil </span><span class="cov8" title="1">{
                                if v, ok := eCtx.Inputs["context"]; ok </span><span class="cov0" title="0">{
                                        eCtx.Value = v
                                }</span>
                        }
                        <span class="cov8" title="1">eCtx.Outputs = triggerData.Outputs
                        var val interface{}
                        val, err = parser.Eval(*eCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                status.Status = v1alpha2.InternalError
                                status.ErrorMessage = err.Error()
                                status.IsActive = false
                                log.Errorf(" M (Stage): failed to evaluate stage selector: %v", err)
                                return status, activationData
                        }</span>
                        <span class="cov8" title="1">sVal := ""
                        if val != nil </span><span class="cov8" title="1">{
                                sVal = val.(string)
                        }</span>
                        <span class="cov8" title="1">if sVal != "" </span><span class="cov8" title="1">{
                                if nextStage, ok := campaign.Stages[sVal]; ok </span><span class="cov8" title="1">{
                                        if !delayedExit || nextStage.HandleErrors </span><span class="cov8" title="1">{
                                                status.NextStage = sVal
                                                activationData = &amp;v1alpha2.ActivationData{
                                                        Campaign:             triggerData.Campaign,
                                                        Activation:           triggerData.Activation,
                                                        ActivationGeneration: triggerData.ActivationGeneration,
                                                        Stage:                sVal,
                                                        Inputs:               triggerData.Inputs,
                                                        Outputs:              triggerData.Outputs,
                                                        Provider:             nextStage.Provider,
                                                        Config:               nextStage.Config,
                                                        TriggeringStage:      triggerData.Stage,
                                                        Schedule:             nextStage.Schedule,
                                                }
                                        }</span> else<span class="cov8" title="1"> {
                                                status.Status = v1alpha2.InternalError
                                                status.ErrorMessage = fmt.Sprintf("stage %s failed", triggerData.Stage)
                                                status.IsActive = false
                                                log.Errorf(" M (Stage): failed to process stage outputs: %v", status.ErrorMessage)
                                                return status, activationData
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        err = v1alpha2.NewCOAError(nil, status.ErrorMessage, v1alpha2.BadRequest)
                                        status.Status = v1alpha2.BadRequest
                                        status.ErrorMessage = fmt.Sprintf("stage %s is not found", sVal)
                                        status.IsActive = false
                                        log.Errorf(" M (Stage): failed to find next stage: %v", err)
                                        return status, activationData
                                }</span>
                        }
                        <span class="cov8" title="1">status.NextStage = sVal
                        if sVal == "" </span><span class="cov8" title="1">{
                                status.IsActive = false
                                status.Status = v1alpha2.Done
                        }</span> else<span class="cov8" title="1"> {
                                if pauseRequested </span><span class="cov0" title="0">{
                                        status.IsActive = false
                                        status.Status = v1alpha2.Paused
                                }</span> else<span class="cov8" title="1"> {
                                        status.IsActive = true
                                        status.Status = v1alpha2.Running
                                }</span>
                        }
                        <span class="cov8" title="1">log.Infof(" M (Stage): stage %s is done", triggerData.Stage)
                        return status, activationData</span>
                } else<span class="cov0" title="0"> {
                        status.Status = v1alpha2.Done
                        status.NextStage = ""
                        status.IsActive = false
                        log.Infof(" M (Stage): stage %s is done (no next stage)", triggerData.Stage)
                        return status, activationData
                }</span>
        }
        <span class="cov0" title="0">err = v1alpha2.NewCOAError(nil, fmt.Sprintf("stage %s is not found", triggerData.Stage), v1alpha2.BadRequest)
        status.Status = v1alpha2.InternalError
        status.ErrorMessage = err.Error()
        status.IsActive = false
        log.Errorf(" M (Stage): failed to find stage: %v", err)
        return status, activationData</span>
}

func (s *StageManager) traceValue(v interface{}, inputs map[string]interface{}, outputs map[string]map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                parser := utils.NewParser(val)
                context := s.Context.VencorContext.EvaluationContext.Clone()
                context.DeploymentSpec = s.Context.VencorContext.EvaluationContext.DeploymentSpec
                context.Inputs = inputs
                context.Outputs = outputs
                if context.Inputs != nil </span><span class="cov8" title="1">{
                        if v, ok := context.Inputs["context"]; ok </span><span class="cov0" title="0">{
                                context.Value = v
                        }</span>
                }
                <span class="cov8" title="1">v, err := parser.Eval(*context)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">switch vt := v.(type) </span>{
                case string:<span class="cov8" title="1">
                        return vt, nil</span>
                default:<span class="cov8" title="1">
                        return s.traceValue(v, inputs, outputs)</span>
                }
        case []interface{}:<span class="cov0" title="0">
                ret := []interface{}{}
                for _, v := range val </span><span class="cov0" title="0">{
                        tv, err := s.traceValue(v, inputs, outputs)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">ret = append(ret, tv)</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        case map[string]interface{}:<span class="cov8" title="1">
                ret := map[string]interface{}{}
                for k, v := range val </span><span class="cov8" title="1">{
                        tv, err := s.traceValue(v, inputs, outputs)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">ret[k] = tv</span>
                }
                <span class="cov8" title="1">return ret, nil</span>
        default:<span class="cov8" title="1">
                return val, nil</span>
        }
}

func (s *StageManager) HandleActivationEvent(ctx context.Context, actData v1alpha2.ActivationData, campaign model.CampaignSpec, activation model.ActivationState) (*v1alpha2.ActivationData, error) <span class="cov8" title="1">{
        stage := actData.Stage
        if _, ok := campaign.Stages[stage]; !ok </span><span class="cov8" title="1">{
                stage = campaign.FirstStage
        }</span>
        <span class="cov8" title="1">if stage == "" </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(nil, "no stage found", v1alpha2.BadRequest)
        }</span>
        <span class="cov8" title="1">if stageSpec, ok := campaign.Stages[stage]; ok </span><span class="cov8" title="1">{
                if activation.Status != nil &amp;&amp; activation.Status.Stage != "" &amp;&amp; activation.Status.NextStage != stage </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("stage %s is not the next stage", stage), v1alpha2.BadRequest)
                }</span>
                <span class="cov8" title="1">return &amp;v1alpha2.ActivationData{
                        Campaign:             actData.Campaign,
                        Activation:           actData.Activation,
                        ActivationGeneration: actData.ActivationGeneration,
                        Stage:                stage,
                        Inputs:               activation.Spec.Inputs,
                        Provider:             stageSpec.Provider,
                        Config:               stageSpec.Config,
                        TriggeringStage:      stage,
                        Schedule:             stageSpec.Schedule,
                }, nil</span>
        }
        <span class="cov0" title="0">return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("stage %s is not found", stage), v1alpha2.BadRequest)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package staging

import (
        "context"
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/queue"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"

        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
)

var log = logger.NewLogger("coa.runtime")

type StagingManager struct {
        managers.Manager
        QueueProvider queue.IQueueProvider
        StateProvider states.IStateProvider
}

const Site_Job_Queue = "site-job-queue"

func (s *StagingManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">queueProvider, err := managers.GetQueueProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.QueueProvider = queueProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (s *StagingManager) Enabled() bool <span class="cov0" title="0">{
        return s.Config.Properties["poll.enabled"] == "true"
}</span>
func (s *StagingManager) Poll() []error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Staging Manager", context.Background(), &amp;map[string]string{
                "method": "Poll",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Debug(" M (Staging): Polling...")
        if s.QueueProvider.Size(Site_Job_Queue) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">site, err := s.QueueProvider.Dequeue(Site_Job_Queue)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(" M (Staging): Failed to poll: %s", err.Error())
                return []error{err}
        }</span>
        <span class="cov8" title="1">siteId := site.(string)
        catalogs, err := utils.GetCatalogs(
                ctx,
                s.VendorContext.SiteInfo.CurrentSite.BaseUrl,
                s.VendorContext.SiteInfo.CurrentSite.Username,
                s.VendorContext.SiteInfo.CurrentSite.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(" M (Staging): Failed to get catalogs: %s", err.Error())
                observ_utils.CloseSpanWithError(span, &amp;err)
                return []error{err}
        }</span>
        <span class="cov8" title="1">for _, catalog := range catalogs </span><span class="cov8" title="1">{
                cacheId := siteId + "-" + catalog.Spec.Name
                getRequest := states.GetRequest{
                        ID: cacheId,
                        Metadata: map[string]string{
                                "version":  "v1",
                                "group":    model.FederationGroup,
                                "resource": "catalogs",
                        },
                }
                var entry states.StateEntry
                entry, err = s.StateProvider.Get(ctx, getRequest)
                if err == nil &amp;&amp; entry.Body != nil &amp;&amp; entry.Body.(string) == catalog.Spec.Generation </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if err != nil &amp;&amp; !v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Errorf(" M (Staging): Failed to get catalog %s: %s", catalog.Spec.Name, err.Error())
                }</span>
                <span class="cov8" title="1">s.QueueProvider.Enqueue(siteId, v1alpha2.JobData{
                        Id:     catalog.Spec.Name,
                        Action: "UPDATE",
                        Body:   catalog,
                })
                _, err = s.StateProvider.Upsert(ctx, states.UpsertRequest{
                        Value: states.StateEntry{
                                ID:   cacheId,
                                Body: catalog.Spec.Generation,
                        },
                        Metadata: map[string]string{
                                "version":  "v1",
                                "group":    model.FederationGroup,
                                "resource": "catalogs",
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf(" M (Staging): Failed to record catalog %s: %s", catalog.Spec.Name, err.Error())
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (s *StagingManager) Reconcil() []error <span class="cov0" title="0">{
        return nil
}</span>

func (s *StagingManager) HandleJobEvent(ctx context.Context, event v1alpha2.Event) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Staging Manager", ctx, &amp;map[string]string{
                "method": "HandleJobEvent",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        var job v1alpha2.JobData
        jData, _ := json.Marshal(event.Body)
        err = json.Unmarshal(jData, &amp;job)
        if err != nil </span><span class="cov0" title="0">{
                err = v1alpha2.NewCOAError(nil, "event body is not a job", v1alpha2.BadRequest)
                return err
        }</span>
        <span class="cov8" title="1">s.QueueProvider.Enqueue(Site_Job_Queue, event.Metadata["site"])
        return s.QueueProvider.Enqueue(event.Metadata["site"], job)</span>
}
func (s *StagingManager) GetABatchForSite(site string, count int) ([]v1alpha2.JobData, error) <span class="cov8" title="1">{
        //TODO: this should return a group of jobs as optimization
        s.QueueProvider.Enqueue(Site_Job_Queue, site)
        if s.QueueProvider.Size(site) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">items := []v1alpha2.JobData{}
        itemCount := 0
        for </span><span class="cov8" title="1">{
                stackElement, err := s.QueueProvider.Dequeue(site)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if job, ok := stackElement.(v1alpha2.JobData); ok </span><span class="cov8" title="1">{
                        items = append(items, job)
                        itemCount++
                }</span> else<span class="cov0" title="0"> {
                        s.QueueProvider.Enqueue(site, stackElement)
                }</span>
                <span class="cov8" title="1">if itemCount == count || s.QueueProvider.Size(site) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package target

import (
        "context"
        "encoding/json"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/probe"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/reference"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/reporter"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/uploader"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")
var lock sync.Mutex

type TargetManager struct {
        managers.Manager
        ReferenceProvider reference.IReferenceProvider
        ProbeProvider     probe.IProbeProvider
        UploaderProvider  uploader.IUploader
        Reporter          reporter.IReporter
}

type Device struct {
        Object Object
}
type Object struct {
        ApiVersion string                 `json:"apiVersion`
        Kind       string                 `json:"kind"`
        Metadata   map[string]interface{} `json:"metadata"`
        Spec       DeviceSpec             `json:"spec"`
}
type DeviceSpec struct {
        Properties map[string]string `json:"properties"`
}

func (s *TargetManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov8" title="1">{

        probeProvider, err := managers.GetProbeProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.ProbeProvider = probeProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">referenceProvider, err := managers.GetReferenceProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.ReferenceProvider = referenceProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">uploaderProvider, err := managers.GetUploaderProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.UploaderProvider = uploaderProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">reporterProvider, err := managers.GetReporter(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.Reporter = reporterProvider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *TargetManager) Apply(ctx context.Context, target model.TargetSpec) error <span class="cov8" title="1">{
        return nil
}</span>
func (s *TargetManager) Get(ctx context.Context) (model.TargetSpec, error) <span class="cov8" title="1">{
        return model.TargetSpec{}, nil
}</span>
func (s *TargetManager) Remove(ctx context.Context, target model.TargetSpec) error <span class="cov8" title="1">{
        return nil
}</span>
func (s *TargetManager) Enabled() bool <span class="cov8" title="1">{
        return s.Config.Properties["poll.enabled"] == "true"
}</span>
func (s *TargetManager) Poll() []error <span class="cov8" title="1">{
        target := s.ReferenceProvider.TargetID()

        ret, err := s.ReferenceProvider.List(target+"=true", "", "default", model.FabricGroup, "devices", "v1", "v1alpha2.ReferenceK8sCRD")
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>
        <span class="cov8" title="1">jsonData, _ := json.Marshal(ret)
        devices := make([]Device, 0)
        json.Unmarshal(jsonData, &amp;devices)
        log.Debugf("polling %d devices...", len(devices))
        errors := make([]error, 0)

        first := true
        for _, device := range devices </span><span class="cov8" title="1">{
                user := ""
                if u, ok := device.Object.Spec.Properties["user"]; ok </span><span class="cov8" title="1">{
                        user = u
                }</span>
                <span class="cov8" title="1">password := ""
                if p, ok := device.Object.Spec.Properties["password"]; ok </span><span class="cov8" title="1">{
                        password = p
                }</span>
                <span class="cov8" title="1">ip := ""
                if i, ok := device.Object.Spec.Properties["ip"]; ok </span><span class="cov8" title="1">{
                        ip = i
                }</span>
                <span class="cov8" title="1">name := device.Object.Metadata["name"].(string)
                if ip != "" </span><span class="cov8" title="1">{
                        if user != "" &amp;&amp; password != "" </span><span class="cov8" title="1">{
                                log.Debugf("taking snapshot from rtsp://%s:%s@%s...", user, "&lt;password&gt;", strings.ReplaceAll(ip, "rtsp://", ""))
                        }</span> else<span class="cov0" title="0"> {
                                log.Debugf("taking snapshot from rtsp://%s...", strings.ReplaceAll(ip, "rtsp://", ""))
                        }</span>
                        <span class="cov8" title="1">ret, err := s.ProbeProvider.Probe(user, password, ip, name)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("failed to probe device: %s", err.Error())
                                errors = append(errors, err)
                                errors = append(errors, s.reportStatus(name, target, "", "disconnected", "disconnected", first, err.Error())...)
                                continue</span>
                        }
                        <span class="cov8" title="1">if v, ok := ret["snapshot"]; ok </span><span class="cov8" title="1">{
                                file, err := os.Open(v)
                                if err != nil </span><span class="cov8" title="1">{
                                        log.Debugf("failed to open local file: %s", err.Error())
                                        errors = append(errors, err)
                                        errors = append(errors, s.reportStatus(name, target, "", "connected", "connected", first, err.Error())...)
                                        continue</span>
                                }
                                <span class="cov0" title="0">data, err := ioutil.ReadAll(file)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debugf("failed to read local file: %s", err.Error())
                                        errors = append(errors, err)
                                        errors = append(errors, s.reportStatus(name, target, "", "connected", "connected", first, err.Error())...)
                                        continue</span>
                                }
                                <span class="cov0" title="0">fileName := filepath.Base(v)
                                str, err := s.UploaderProvider.Upload(fileName, data)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debugf("failed to upload snapshot: %s", err.Error())
                                        errors = append(errors, err)
                                        errors = append(errors, s.reportStatus(name, target, "", "connected", "connected", first, err.Error())...)
                                        continue</span>
                                }
                                <span class="cov0" title="0">log.Debugf("file is uploaded to %s", str)
                                errors = append(errors, s.reportStatus(name, target, str, "connected", "connected", first, "")...)</span>
                        }
                } else<span class="cov0" title="0"> {
                        errors = append(errors, s.reportStatus(name, target, "", "disconnected", "disconnected", first, "device ip is not set")...)
                }</span>
                <span class="cov0" title="0">first = false</span>
        }
        <span class="cov8" title="1">return errors</span>
}
func (s *TargetManager) reportStatus(deviceName string, targetName string, snapshot string, targetStatus string, deviceStatus string, overwrite bool, errStr string) []error <span class="cov8" title="1">{
        ret := make([]error, 0)
        report := make(map[string]string)
        report[targetName+".status"] = targetStatus
        if snapshot != "" </span><span class="cov8" title="1">{
                report["snapshot"] = snapshot
        }</span>
        <span class="cov8" title="1">if errStr != "" </span><span class="cov8" title="1">{
                report[targetName+".err"] = errStr
        }</span>
        <span class="cov8" title="1">err := s.Reporter.Report(deviceName, "default", model.FabricGroup, "devices", "v1", report, false) //can't overwrite device state properties as other targets may be reporting as well
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("failed to report device status: %s", err.Error())
                ret = append(ret, err)
        }</span>
        <span class="cov8" title="1">report = make(map[string]string)
        report[deviceName+".status"] = deviceStatus
        if errStr != "" </span><span class="cov8" title="1">{
                report[deviceName+".err"] = errStr
        }</span>
        <span class="cov8" title="1">err = s.Reporter.Report(targetName, "default", model.FabricGroup, "targets", "v1", report, overwrite)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("failed to report target status: %s", err.Error())
                ret = append(ret, err)
        }</span>
        <span class="cov8" title="1">return ret</span>
}
func (s *TargetManager) Reconcil() []error <span class="cov8" title="1">{
        log.Debug("Rconciling....")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package targets

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/registry"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"

        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
)

type TargetsManager struct {
        managers.Manager
        StateProvider    states.IStateProvider
        RegistryProvider registry.IRegistryProvider
}

func (s *TargetsManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov0" title="0">{
        err := s.Manager.Init(context, config, providers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov0" title="0">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *TargetsManager) DeleteSpec(ctx context.Context, name string, scope string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Targets Manager", ctx, &amp;map[string]string{
                "method": "DeleteSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = t.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
                Metadata: map[string]string{
                        "scope":    scope,
                        "group":    model.FabricGroup,
                        "version":  "v1",
                        "resource": "targets",
                },
        })
        return err
}</span>

func (t *TargetsManager) UpsertSpec(ctx context.Context, name string, scope string, spec model.TargetSpec) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Targets Manager", ctx, &amp;map[string]string{
                "method": "UpsertSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: map[string]interface{}{
                                "apiVersion": model.FabricGroup + "/v1",
                                "kind":       "Target",
                                "metadata": map[string]interface{}{
                                        "name": name,
                                },
                                "spec": spec,
                        },
                        ETag: spec.Generation,
                },
                Metadata: map[string]string{
                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Target", "metadata": {"name": "${{$target()}}"}}`, model.FabricGroup),
                        "scope":    scope,
                        "group":    model.FabricGroup,
                        "version":  "v1",
                        "resource": "targets",
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        return err
}</span>

// Caller need to explicitly set scope in current.Metadata!
func (t *TargetsManager) ReportState(ctx context.Context, current model.TargetState) (model.TargetState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Targets Manager", ctx, &amp;map[string]string{
                "method": "ReportState",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID:       current.Id,
                Metadata: current.Metadata,
        }
        target, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov0" title="0">{
                observ_utils.CloseSpanWithError(span, &amp;err)
                return model.TargetState{}, err
        }</span>

        <span class="cov8" title="1">dict := target.Body.(map[string]interface{})

        specCol := dict["spec"].(model.TargetSpec)

        delete(dict, "spec")
        if dict["status"] == nil </span><span class="cov8" title="1">{
                dict["status"] = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">status := dict["status"]

        j, _ := json.Marshal(status)
        var rStatus map[string]interface{}
        err = json.Unmarshal(j, &amp;rStatus)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>
        <span class="cov8" title="1">j, _ = json.Marshal(rStatus["properties"])
        var rProperties map[string]string
        err = json.Unmarshal(j, &amp;rProperties)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>
        <span class="cov8" title="1">if rProperties == nil </span><span class="cov8" title="1">{
                rProperties = make(map[string]string)
        }</span>
        <span class="cov8" title="1">for k, v := range current.Status </span><span class="cov8" title="1">{
                rProperties[k] = v
        }</span>

        <span class="cov8" title="1">dict["status"].(map[string]interface{})["properties"] = rProperties

        target.Body = dict

        updateRequest := states.UpsertRequest{
                Value:    target,
                Metadata: current.Metadata,
        }

        _, err = t.StateProvider.Upsert(ctx, updateRequest)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>

        <span class="cov8" title="1">return model.TargetState{
                Id:       current.Id,
                Metadata: specCol.Metadata,
                Status:   rProperties,
        }, nil</span>
}
func (t *TargetsManager) ListSpec(ctx context.Context, scope string) ([]model.TargetState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Targets Manager", ctx, &amp;map[string]string{
                "method": "ListSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        listRequest := states.ListRequest{
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "targets",
                        "scope":    scope,
                },
        }
        targets, _, err := t.StateProvider.List(ctx, listRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.TargetState, 0)
        for _, t := range targets </span><span class="cov8" title="1">{
                var rt model.TargetState
                rt, err = getTargetState(t.ID, t.Body, t.ETag)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret = append(ret, rt)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func getTargetState(id string, body interface{}, etag string) (model.TargetState, error) <span class="cov8" title="1">{
        dict := body.(map[string]interface{})
        spec := dict["spec"]
        status := dict["status"]

        j, _ := json.Marshal(spec)
        var rSpec model.TargetSpec
        err := json.Unmarshal(j, &amp;rSpec)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>

        <span class="cov8" title="1">j, _ = json.Marshal(status)
        var rStatus map[string]interface{}
        err = json.Unmarshal(j, &amp;rStatus)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>
        <span class="cov8" title="1">j, _ = json.Marshal(rStatus["properties"])
        var rProperties map[string]string
        err = json.Unmarshal(j, &amp;rProperties)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>
        <span class="cov8" title="1">rSpec.Generation = etag

        scope, exist := dict["scope"]
        var s string
        if !exist </span><span class="cov8" title="1">{
                s = "default"
        }</span> else<span class="cov0" title="0"> {
                s = scope.(string)
        }</span>

        <span class="cov8" title="1">state := model.TargetState{
                Id:     id,
                Scope:  s,
                Spec:   &amp;rSpec,
                Status: rProperties,
        }
        return state, nil</span>
}

func (t *TargetsManager) GetSpec(ctx context.Context, id string, scope string) (model.TargetState, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Targets Manager", ctx, &amp;map[string]string{
                "method": "GetSpec",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        getRequest := states.GetRequest{
                ID: id,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "targets",
                        "scope":    scope,
                },
        }
        target, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov8" title="1">{
                return model.TargetState{}, err
        }</span>

        <span class="cov8" title="1">ret, err := getTargetState(id, target.Body, target.ETag)
        if err != nil </span><span class="cov0" title="0">{
                return model.TargetState{}, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package users

import (
        "context"
        "fmt"
        "hash/fnv"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var log = logger.NewLogger("coa.runtime")

type UsersManager struct {
        managers.Manager
        StateProvider states.IStateProvider
}

type UserState struct {
        Id           string   `json:"id"`
        PasswordHash string   `json:"passwordHash,omitempty"`
        Roles        []string `json:"roles,omitempty"`
}

func (s *UsersManager) Init(context *contexts.VendorContext, config managers.ManagerConfig, providers map[string]providers.IProvider) error <span class="cov8" title="1">{
        stateprovider, err := managers.GetStateProvider(config, providers)
        if err == nil </span><span class="cov8" title="1">{
                s.StateProvider = stateprovider
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
func (t *UsersManager) DeleteUser(ctx context.Context, name string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Users Manager", ctx, &amp;map[string]string{
                "method": "DeleteUser",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = t.StateProvider.Delete(ctx, states.DeleteRequest{
                ID: name,
        })
        return err
}</span>

func hash(name string, s string) string <span class="cov8" title="1">{
        h := fnv.New32a()
        h.Write([]byte(name + "." + s + ".salt"))
        return fmt.Sprintf("H%d", h.Sum32())
}</span>

func (t *UsersManager) UpsertUser(ctx context.Context, name string, password string, roles []string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Users Manager", ctx, &amp;map[string]string{
                "method": "UpsertUser",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Debug(" M (Users) : upsert user")
        upsertRequest := states.UpsertRequest{
                Value: states.StateEntry{
                        ID: name,
                        Body: UserState{
                                Id:           name,
                                PasswordHash: hash(name, password),
                                Roles:        roles,
                        },
                },
        }
        _, err = t.StateProvider.Upsert(ctx, upsertRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf(" M (Users) : failed to upsert user - %s", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (t *UsersManager) CheckUser(ctx context.Context, name string, password string) ([]string, bool) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Users Manager", ctx, &amp;map[string]string{
                "method": "CheckUser",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Debug(" M (Users) : check user")
        getRequest := states.GetRequest{
                ID: name,
        }
        user, err := t.StateProvider.Get(ctx, getRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf(" M (Users) : failed to read user - %s", err)
                return nil, false
        }</span>

        <span class="cov8" title="1">if v, ok := user.Body.(UserState); ok </span><span class="cov8" title="1">{
                if hash(name, password) == v.PasswordHash </span><span class="cov8" title="1">{
                        log.Debug(" M (Users) : user authenticated")
                        return v.Roles, true
                }</span>
        }
        <span class="cov8" title="1">log.Debug(" M (Users) : authentication failed")
        return nil, false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

// +kubebuilder:object:generate=true
type BindingSpec struct {
        Role     string            `json:"role"`
        Provider string            `json:"provider"`
        Config   map[string]string `json:"config,omitempty"`
}

func (c BindingSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(BindingSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a BindingSpec type")
        }</span>

        <span class="cov8" title="1">if c.Role != otherC.Role </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Provider != otherC.Provider </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Config, otherC.Config, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"
        "reflect"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
)

type CampaignState struct {
        Id   string        `json:"id"`
        Spec *CampaignSpec `json:"spec,omitempty"`
}

type ActivationState struct {
        Id       string            `json:"id"`
        Metadata map[string]string `json:"metadata,omitempty"`
        Spec     *ActivationSpec   `json:"spec,omitempty"`
        Status   *ActivationStatus `json:"status,omitempty"`
}
type StageSpec struct {
        Name          string                 `json:"name,omitempty"`
        Contexts      string                 `json:"contexts,omitempty"`
        Provider      string                 `json:"provider,omitempty"`
        Config        interface{}            `json:"config,omitempty"`
        StageSelector string                 `json:"stageSelector,omitempty"`
        Inputs        map[string]interface{} `json:"inputs,omitempty"`
        HandleErrors  bool                   `json:"handleErrors,omitempty"`
        Schedule      *v1alpha2.ScheduleSpec `json:"schedule,omitempty"`
}

func (s StageSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherS, ok := other.(StageSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a StageSpec type")
        }</span>

        <span class="cov0" title="0">if s.Name != otherS.Name </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if s.Provider != otherS.Provider </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(s.Config, otherS.Config) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if s.StageSelector != otherS.StageSelector </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(s.Inputs, otherS.Inputs) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(s.Schedule, otherS.Schedule) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

type ActivationStatus struct {
        Stage                string                 `json:"stage"`
        NextStage            string                 `json:"nextStage,omitempty"`
        Inputs               map[string]interface{} `json:"inputs,omitempty"`
        Outputs              map[string]interface{} `json:"outputs,omitempty"`
        Status               v1alpha2.State         `json:"status,omitempty"`
        ErrorMessage         string                 `json:"errorMessage,omitempty"`
        IsActive             bool                   `json:"isActive,omitempty"`
        ActivationGeneration string                 `json:"activationGeneration,omitempty"`
        UpdateTime           string                 `json:"updateTime,omitempty"`
}

type ActivationSpec struct {
        Campaign   string                 `json:"campaign,omitempty"`
        Name       string                 `json:"name,omitempty"`
        Stage      string                 `json:"stage,omitempty"`
        Inputs     map[string]interface{} `json:"inputs,omitempty"`
        Generation string                 `json:"generation,omitempty"`
}

func (c ActivationSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherC, ok := other.(ActivationSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a ActivationSpec type")
        }</span>

        <span class="cov0" title="0">if c.Campaign != otherC.Campaign </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if c.Name != otherC.Name </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if c.Stage != otherC.Stage </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(c.Inputs, otherC.Inputs) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

type CampaignSpec struct {
        Name        string               `json:"name,omitempty"`
        FirstStage  string               `json:"firstStage,omitempty"`
        Stages      map[string]StageSpec `json:"stages,omitempty"`
        SelfDriving bool                 `json:"selfDriving,omitempty"`
}

func (c CampaignSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(CampaignSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a CampaignSpec type")
        }</span>

        <span class="cov8" title="1">if c.Name != otherC.Name </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.FirstStage != otherC.FirstStage </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.SelfDriving != otherC.SelfDriving </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if len(c.Stages) != len(otherC.Stages) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if len(c.Stages) != len(otherC.Stages) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">for i, stage := range c.Stages </span><span class="cov0" title="0">{
                otherStage := otherC.Stages[i]

                if eq, err := stage.DeepEquals(otherStage); err != nil || !eq </span><span class="cov0" title="0">{
                        return eq, err
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"
        "reflect"
)

// TODO: all state objects should converge to this paradigm: id, spec and status
type CatalogState struct {
        Id     string         `json:"id"`
        Spec   *CatalogSpec   `json:"spec,omitempty"`
        Status *CatalogStatus `json:"status,omitempty"`
}

// +kubebuilder:object:generate=true
type ObjectRef struct {
        SiteId     string            `json:"siteId"`
        Name       string            `json:"name"`
        Group      string            `json:"group"`
        Version    string            `json:"version"`
        Kind       string            `json:"kind"`
        Scope      string            `json:"scope"`
        Address    string            `json:"address,omitempty"`
        Generation string            `json:"generation,omitempty"`
        Metadata   map[string]string `json:"metadata,omitempty"`
}
type CatalogSpec struct {
        SiteId     string                 `json:"siteId"`
        Name       string                 `json:"name"`
        Type       string                 `json:"type"`
        Properties map[string]interface{} `json:"properties"`
        Metadata   map[string]string      `json:"metadata,omitempty"`
        ParentName string                 `json:"parentName,omitempty"`
        ObjectRef  ObjectRef              `json:"objectRef,omitempty"`
        Generation string                 `json:"generation,omitempty"`
}

type CatalogStatus struct {
        Properties map[string]string `json:"properties"`
}

func (c CatalogSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherC, ok := other.(CatalogSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a CatalogSpec type")
        }</span>

        <span class="cov0" title="0">if c.SiteId != otherC.SiteId </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if c.Name != otherC.Name </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if c.ParentName != otherC.ParentName </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if c.Generation != otherC.Generation </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(c.Properties, otherC.Properties) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// INode interface
func (s CatalogState) GetId() string <span class="cov0" title="0">{
        return s.Id
}</span>
func (s CatalogState) GetParent() string <span class="cov0" title="0">{
        if s.Spec != nil </span><span class="cov0" title="0">{
                return s.Spec.ParentName
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func (s CatalogState) GetType() string <span class="cov0" title="0">{
        if s.Spec != nil </span><span class="cov0" title="0">{
                return s.Spec.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func (s CatalogState) GetProperties() map[string]interface{} <span class="cov0" title="0">{
        if s.Spec != nil </span><span class="cov0" title="0">{
                return s.Spec.Properties
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IEdge interface
func (s CatalogState) GetFrom() string <span class="cov0" title="0">{
        if s.Spec != nil </span><span class="cov0" title="0">{
                if s.Spec.Type == "edge" </span><span class="cov0" title="0">{
                        if s.Spec.Metadata != nil </span><span class="cov0" title="0">{
                                if from, ok := s.Spec.Metadata["from"]; ok </span><span class="cov0" title="0">{
                                        return from
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (s CatalogState) GetTo() string <span class="cov0" title="0">{
        if s.Spec != nil </span><span class="cov0" title="0">{
                if s.Spec.Type == "edge" </span><span class="cov0" title="0">{
                        if s.Spec.Metadata != nil </span><span class="cov0" title="0">{
                                if to, ok := s.Spec.Metadata["to"]; ok </span><span class="cov0" title="0">{
                                        return to
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"
        "reflect"
)

type ComponentSpec struct {
        Name         string                 `json:"name"`
        Type         string                 `json:"type,omitempty"`
        Metadata     map[string]string      `json:"metadata,omitempty"`
        Properties   map[string]interface{} `json:"properties,omitempty"`
        Parameters   map[string]string      `json:"parameters,omitempty"`
        Routes       []RouteSpec            `json:"routes,omitempty"`
        Constraints  string                 `json:"constraints,omitempty"`
        Dependencies []string               `json:"dependencies,omitempty"`
        Skills       []string               `json:"skills,omitempty"`
}

func (c ComponentSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{ // avoid using reflect, which has performance problems
        otherC, ok := other.(ComponentSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a ComponentSpec type")
        }</span>

        <span class="cov8" title="1">if c.Name != otherC.Name </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Properties, otherC.Properties) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if !StringMapsEqual(c.Metadata, otherC.Metadata, []string{"SYMPHONY_AGENT_ADDRESS"}) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Routes, otherC.Routes) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // if c.Constraints != otherC.Constraints {        Can't compare constraints as components from actual envrionments don't have constraints
        //         return false, nil
        // }
        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"

        go_slices "golang.org/x/exp/slices"
)

type DeploymentSpec struct {
        SolutionName        string                `json:"solutionName"`
        Solution            SolutionSpec          `json:"solution"`
        Instance            InstanceSpec          `json:"instance"`
        Targets             map[string]TargetSpec `json:"targets"`
        Devices             []DeviceSpec          `json:"devices,omitempty"`
        Assignments         map[string]string     `json:"assignments,omitempty"`
        ComponentStartIndex int                   `json:"componentStartIndex,omitempty"`
        ComponentEndIndex   int                   `json:"componentEndIndex,omitempty"`
        ActiveTarget        string                `json:"activeTarget,omitempty"`
        Generation          string                `json:"generation,omitempty"`
}

func (d DeploymentSpec) GetComponentSlice() []ComponentSpec <span class="cov8" title="1">{
        components := d.Solution.Components
        if d.ComponentStartIndex &gt;= 0 &amp;&amp; d.ComponentEndIndex &gt;= 0 &amp;&amp; d.ComponentEndIndex &gt; d.ComponentStartIndex </span><span class="cov8" title="1">{
                components = components[d.ComponentStartIndex:d.ComponentEndIndex]
        }</span>
        <span class="cov8" title="1">return components</span>
}

func (c DeploymentSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(DeploymentSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a DeploymentSpec type")
        }</span>

        <span class="cov8" title="1">if c.SolutionName != otherC.SolutionName </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">equal, err := c.Solution.DeepEquals(otherC.Solution)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if !equal </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">equal, err = c.Instance.DeepEquals(otherC.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if !equal </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !mapsEqual(c.Targets, otherC.Targets, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Devices, otherC.Devices) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Assignments, otherC.Assignments, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.ComponentStartIndex != otherC.ComponentStartIndex </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.ComponentEndIndex != otherC.ComponentEndIndex </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.ActiveTarget != otherC.ActiveTarget </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func mapsEqual(a map[string]TargetSpec, b map[string]TargetSpec, ignoredMissingKeys []string) bool <span class="cov8" title="1">{
        for k, v := range a </span><span class="cov8" title="1">{
                if bv, ok := b[k]; ok </span><span class="cov8" title="1">{
                        equal, err := bv.DeepEquals(v)
                        if err != nil || !equal </span><span class="cov8" title="1">{
                                return false
                        }</span>

                } else<span class="cov0" title="0"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov0" title="0">{
                                return false
                        }</span>

                }

        }

        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if bv, ok := a[k]; ok </span><span class="cov8" title="1">{
                        equal, err := bv.DeepEquals(v)
                        if err != nil || !equal </span><span class="cov0" title="0">{
                                return false
                        }</span>

                } else<span class="cov0" title="0"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov0" title="0">{
                                return false
                        }</span>

                }

        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

type (
        // DeviceState defines the current state of the device
        DeviceState struct {
                Id   string      `json:"id"`
                Spec *DeviceSpec `json:"spec,omitempty"`
        }
        // DeviceSpec defines the spec properties of the DeviceState
        // +kubebuilder:object:generate=true
        DeviceSpec struct {
                DisplayName string            `json:"displayName,omitempty"`
                Properties  map[string]string `json:"properties,omitempty"`
                Bindings    []BindingSpec     `json:"bindings,omitempty"`
        }
)

func (c DeviceSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(DeviceSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a DeviceSpec type")
        }</span>

        <span class="cov8" title="1">if c.DisplayName != otherC.DisplayName </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Properties, otherC.Properties, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Bindings, otherC.Bindings) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

type (
        ConnectionSpec struct {
                Node  string `json:"node"`
                Route string `json:"route"`
        }
        EdgeSpec struct {
                Source ConnectionSpec `json:"source"`
                Target ConnectionSpec `json:"target"`
        }
)

func (c ConnectionSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherSpec, ok := other.(*ConnectionSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if c.Node != otherSpec.Node </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if c.Route != otherSpec.Route </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
func (c EdgeSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherSpec, ok := other.(*EdgeSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">equal, err := c.Source.DeepEquals(&amp;otherSpec.Source)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if !equal </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">equal, err = c.Target.DeepEquals(&amp;otherSpec.Target)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if !equal </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

// +kubebuilder:object:generate=true
type FilterSpec struct {
        Direction  string            `json:"direction"`
        Type       string            `json:"type"`
        Parameters map[string]string `json:"parameters,omitempty"`
}

func (c FilterSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{ // avoid using reflect, which has performance problems
        otherC, ok := other.(FilterSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a FilterSpec type")
        }</span>

        <span class="cov8" title="1">if c.Direction != otherC.Direction </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Type != otherC.Type </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Parameters, otherC.Parameters, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

type (

        // InstanceState defines the current state of the instance
        InstanceState struct {
                Id     string            `json:"id"`
                Scope  string            `json:"scope"`
                Spec   *InstanceSpec     `json:"spec,omitempty"`
                Status map[string]string `json:"status,omitempty"`
        }

        // InstanceSpec defines the spec property of the InstanceState
        // +kubebuilder:object:generate=true
        InstanceSpec struct {
                Name        string                       `json:"name"`
                DisplayName string                       `json:"displayName,omitempty"`
                Scope       string                       `json:"scope,omitempty"`
                Parameters  map[string]string            `json:"parameters,omitempty"` //TODO: Do we still need this?
                Metadata    map[string]string            `json:"metadata,omitempty"`
                Solution    string                       `json:"solution"`
                Target      TargetSelector               `json:"target,omitempty"`
                Topologies  []TopologySpec               `json:"topologies,omitempty"`
                Pipelines   []PipelineSpec               `json:"pipelines,omitempty"`
                Arguments   map[string]map[string]string `json:"arguments,omitempty"`
                Generation  string                       `json:"generation,omitempty"`
                // Defines the version of a particular resource
                Version string `json:"version,omitempty"`
        }

        // TargertRefSpec defines the target the instance will deploy to
        // +kubebuilder:object:generate=true
        TargetSelector struct {
                Name     string            `json:"name,omitempty"`
                Selector map[string]string `json:"selector,omitempty"`
        }

        // PipelineSpec defines the desired pipeline of the instance
        // +kubebuilder:object:generate=true
        PipelineSpec struct {
                Name       string            `json:"name"`
                Skill      string            `json:"skill"`
                Parameters map[string]string `json:"parameters,omitempty"`
        }
)

func (c TargetSelector) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(TargetSelector)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a TargetSelector type")
        }</span>

        <span class="cov8" title="1">if c.Name != otherC.Name </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Selector, otherC.Selector, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (c TopologySpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(TopologySpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a TopologySpec type")
        }</span>

        <span class="cov8" title="1">if c.Device != otherC.Device </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Selector, otherC.Selector, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Bindings, otherC.Bindings) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (c PipelineSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(PipelineSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a PipelineSpec type")
        }</span>

        <span class="cov8" title="1">if c.Name != otherC.Name </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Skill != otherC.Skill </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Parameters, otherC.Parameters, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (c InstanceSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(InstanceSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a InstanceSpec type")
        }</span>

        <span class="cov8" title="1">if c.Name != otherC.Name </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.DisplayName != otherC.DisplayName </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Scope != otherC.Scope </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // TODO: These are not compared in current version. Metadata is usually not considred part of the state so
        // it's reasonable not to compare. The parameters (same arguments apply to arguments below) are dynamic so
        // comparision is unpredictable. Should we not compare the arguments as well? Or, should we get rid of the
        // dynamic things altoghter so everyting is explicitly declared? I feel we are mixing some templating features
        // into the object model.

        // if !StringMapsEqual(c.Parameters, otherC.Parameters, nil) {
        //         return false, nil
        // }

        // if !StringMapsEqual(c.Metadata, otherC.Metadata, nil) {
        //         return false, nil
        // }

        <span class="cov8" title="1">equal, err := c.Target.DeepEquals(otherC.Target)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if !equal </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Topologies, otherC.Topologies) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Pipelines, otherC.Pipelines) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringStringMapsEqual(c.Arguments, otherC.Arguments, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

type ModelState struct {
        Id   string     `json:"id"`
        Spec *ModelSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:generate=true
type ModelSpec struct {
        DisplayName string            `json:"displayName,omitempty"`
        Properties  map[string]string `json:"properties,omitempty"`
        Constraints string            `json:"constraints,omitempty"`
        Bindings    []BindingSpec     `json:"bindings,omitempty"`
}

const (
        AppPackage     = "app.package"
        AppImage       = "app.image"
        ContainerImage = "container.image"
)

func (c ModelSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherModelSpec, ok := other.(*ModelSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if c.DisplayName != otherModelSpec.DisplayName </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if c.Constraints != otherModelSpec.Constraints </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !StringMapsEqual(c.Properties, otherModelSpec.Properties, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(c.Bindings, otherModelSpec.Bindings) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

// +kubebuilder:object:generate=true
type NodeSpec struct {
        Id             string            `json:"id"`
        NodeType       string            `json:"type"`
        Name           string            `json:"name"`
        Configurations map[string]string `json:"configurations,omitempty"`
        Inputs         []RouteSpec       `json:"inputs,omitempty"`
        Outputs        []RouteSpec       `json:"outputs,omitempty"`
        Model          string            `json:"model,omitempty"`
}

func (n NodeSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherSpec, ok := other.(NodeSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if n.Id != otherSpec.Id </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if n.NodeType != otherSpec.NodeType </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if n.Name != otherSpec.Name </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if n.Model != otherSpec.Model </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !StringMapsEqual(n.Configurations, otherSpec.Configurations, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(n.Inputs, otherSpec.Inputs) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(n.Outputs, otherSpec.Outputs) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "strings"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
)

type DeploymentPlan struct {
        Steps []DeploymentStep
}
type DeploymentStep struct {
        Target     string
        Components []ComponentStep
        Role       string
        IsFirst    bool
}
type ComponentStep struct {
        Action    string        `json:"action"`
        Component ComponentSpec `json:"component"`
}

type TargetDesc struct {
        Name string
        Spec TargetSpec
}
type ByTargetName []TargetDesc

func (p ByTargetName) Len() int           <span class="cov0" title="0">{ return len(p) }</span>
func (p ByTargetName) Less(i, j int) bool <span class="cov0" title="0">{ return p[i].Name &lt; p[j].Name }</span>
func (p ByTargetName) Swap(i, j int)      <span class="cov0" title="0">{ p[i], p[j] = p[j], p[i] }</span>

type DeploymentState struct {
        Components      []ComponentSpec
        Targets         []TargetDesc
        TargetComponent map[string]string
}

func (s DeploymentStep) PrepareResultMap() map[string]ComponentResultSpec <span class="cov0" title="0">{
        ret := make(map[string]ComponentResultSpec)
        for _, c := range s.Components </span><span class="cov0" title="0">{
                ret[c.Component.Name] = ComponentResultSpec{
                        Status:  v1alpha2.Untouched,
                        Message: "",
                }
        }</span>
        <span class="cov0" title="0">return ret</span>
}
func (s DeploymentStep) GetComponents() []ComponentSpec <span class="cov0" title="0">{
        ret := make([]ComponentSpec, 0)
        for _, c := range s.Components </span><span class="cov0" title="0">{
                ret = append(ret, c.Component)
        }</span>
        <span class="cov0" title="0">return ret</span>
}
func (s DeploymentStep) GetUpdatedComponents() []ComponentSpec <span class="cov0" title="0">{
        ret := make([]ComponentSpec, 0)
        for _, c := range s.Components </span><span class="cov0" title="0">{
                if c.Action == "update" </span><span class="cov0" title="0">{
                        ret = append(ret, c.Component)
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
func (s DeploymentStep) GetDeletedComponents() []ComponentSpec <span class="cov0" title="0">{
        ret := make([]ComponentSpec, 0)
        for _, c := range s.Components </span><span class="cov0" title="0">{
                if c.Action == "delete" </span><span class="cov0" title="0">{
                        ret = append(ret, c.Component)
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
func (s DeploymentStep) GetUpdatedComponentSteps() []ComponentStep <span class="cov0" title="0">{
        ret := make([]ComponentStep, 0)
        for _, c := range s.Components </span><span class="cov0" title="0">{
                if c.Action == "update" </span><span class="cov0" title="0">{
                        ret = append(ret, c)
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
func (t *DeploymentState) MarkRemoveAll() <span class="cov0" title="0">{
        for k, v := range t.TargetComponent </span><span class="cov0" title="0">{
                if !strings.HasPrefix(v, "-") </span><span class="cov0" title="0">{
                        t.TargetComponent[k] = "-" + v
                }</span>
        }
}
func (t *DeploymentState) ClearAllRemoved() <span class="cov0" title="0">{
        for k, v := range t.TargetComponent </span><span class="cov0" title="0">{
                if strings.HasPrefix(v, "-") </span><span class="cov0" title="0">{
                        delete(t.TargetComponent, k)
                }</span>
        }
}
func (p DeploymentPlan) FindLastTargetRole(target, role string) int <span class="cov0" title="0">{
        for i := len(p.Steps) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if p.Steps[i].Role == role &amp;&amp; p.Steps[i].Target == target </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}
func (p DeploymentPlan) CanAppendToStep(step int, component ComponentSpec) bool <span class="cov0" title="0">{
        canAppend := true
        for _, d := range component.Dependencies </span><span class="cov0" title="0">{
                resolved := false
                for j := 0; j &lt;= step; j++ </span><span class="cov0" title="0">{
                        for _, c := range p.Steps[j].Components </span><span class="cov0" title="0">{
                                if c.Component.Name == d &amp;&amp; c.Action == "update" </span><span class="cov0" title="0">{
                                        resolved = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if resolved </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !resolved </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return canAppend</span>
}
func (p DeploymentPlan) RevisedForDeletion() DeploymentPlan <span class="cov0" title="0">{
        ret := DeploymentPlan{
                Steps: make([]DeploymentStep, 0),
        }
        // create a stack to save deleted steps
        deletedSteps := make([]DeploymentStep, 0)

        for _, s := range p.Steps </span><span class="cov0" title="0">{
                deleted := s.GetDeletedComponents()
                all := s.GetComponents()
                if len(deleted) == 0 </span><span class="cov0" title="0">{
                        ret.Steps = append(ret.Steps, s)
                }</span> else<span class="cov0" title="0"> if len(deleted) == len(all) </span><span class="cov0" title="0">{
                        // add this step to the deleted steps stack
                        deletedSteps = append(deletedSteps, s)
                }</span> else<span class="cov0" title="0"> {
                        //split the steps into two steps, one with updated only, one with deleted only
                        ret.Steps = append(ret.Steps, makeUpdateStep(s))
                        deletedSteps = append(deletedSteps, makeReversedDeletionStep(s))
                }</span>
        }
        <span class="cov0" title="0">for i := len(deletedSteps) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                ret.Steps = append(ret.Steps, deletedSteps[i])
        }</span>
        <span class="cov0" title="0">return ret</span>
}
func makeUpdateStep(step DeploymentStep) DeploymentStep <span class="cov0" title="0">{
        ret := DeploymentStep{
                Target:     step.Target,
                Components: make([]ComponentStep, 0),
                Role:       step.Role,
                IsFirst:    step.IsFirst,
        }
        for _, c := range step.Components </span><span class="cov0" title="0">{
                if c.Action == "update" </span><span class="cov0" title="0">{
                        ret.Components = append(ret.Components, c)
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
func makeReversedDeletionStep(step DeploymentStep) DeploymentStep <span class="cov0" title="0">{
        ret := DeploymentStep{
                Target:     step.Target,
                Components: make([]ComponentStep, 0),
                Role:       step.Role,
                IsFirst:    step.IsFirst,
        }
        for i := len(step.Components) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if step.Components[i].Action == "delete" </span><span class="cov0" title="0">{
                        ret.Components = append(ret.Components, step.Components[i])
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

// +kubebuilder:object:generate=true
type RouteSpec struct {
        Route      string            `json:"route"`
        Type       string            `json:"type"`
        Properties map[string]string `json:"properties,omitempty"`
        Filters    []FilterSpec      `json:"filters,omitempty"`
}

func (c RouteSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{ // avoid using reflect, which has performance problems
        otherC, ok := other.(RouteSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a RouteSpec type")
        }</span>

        <span class="cov8" title="1">if c.Route != otherC.Route </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Type != otherC.Type </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Properties, otherC.Properties, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Filters, otherC.Filters) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
)

type SiteState struct {
        Id       string            `json:"id"`
        Metadata map[string]string `json:"metadata,omitempty"`
        Spec     *SiteSpec         `json:"spec,omitempty"`
        Status   *SiteStatus       `json:"status,omitempty"`
}
type TargetStatus struct {
        State  v1alpha2.State `json:"state,omitempty"`
        Reason string         `json:"reason,omitempty"`
}
type InstanceStatus struct {
        State  v1alpha2.State `json:"state,omitempty"`
        Reason string         `json:"reason,omitempty"`
}

// +kubebuilder:object:generate=true
type SiteStatus struct {
        IsOnline         bool                      `json:"isOnline,omitempty"`
        TargetStatuses   map[string]TargetStatus   `json:"targetStatuses,omitempty"`
        InstanceStatuses map[string]InstanceStatus `json:"instanceStatuses,omitempty"`
        LastReported     string                    `json:"lastReported,omitempty"`
}

// +kubebuilder:object:generate=true
type SiteSpec struct {
        Name       string            `json:"name,omitempty"`
        IsSelf     bool              `json:"isSelf,omitempty"`
        PublicKey  string            `json:"secretHash,omitempty"`
        Properties map[string]string `json:"properties,omitempty"`
}

func (s SiteSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherS, ok := other.(SiteSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("parameter is not a SiteSpec type")
        }</span>

        <span class="cov0" title="0">if s.Name != otherS.Name </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if s.PublicKey != otherS.PublicKey </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

type SkillState struct {
        Id   string     `json:"id"`
        Spec *SkillSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:generate=true
type SkillSpec struct {
        DisplayName string            `json:"displayName,omitempty"`
        Parameters  map[string]string `json:"parameters,omitempty"`
        Nodes       []NodeSpec        `json:"nodes"`
        Properties  map[string]string `json:"properties,omitempty"`
        Bindings    []BindingSpec     `json:"bindings,omitempty"`
        Edges       []EdgeSpec        `json:"edges"`
}

// +kubebuilder:object:generate=true
type SkillPackageSpec struct {
        DisplayName string            `json:"displayName,omitempty"`
        Skill       string            `json:"skill"`
        Properties  map[string]string `json:"properties,omitempty"`
        Constraints string            `json:"constraints,omitempty"`
        Routes      []RouteSpec       `json:"routes,omitempty"`
}

func (c SkillSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov0" title="0">{
        otherSkillSpec, ok := other.(*SkillSpec)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if c.DisplayName != otherSkillSpec.DisplayName </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !StringMapsEqual(c.Parameters, otherSkillSpec.Parameters, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(c.Nodes, otherSkillSpec.Nodes) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !StringMapsEqual(c.Properties, otherSkillSpec.Properties, nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(c.Bindings, otherSkillSpec.Bindings) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !SlicesEqual(c.Edges, otherSkillSpec.Edges) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "errors"
)

type (
        SolutionState struct {
                Id    string        `json:"id"`
                Scope string        `json:"scope"`
                Spec  *SolutionSpec `json:"spec,omitempty"`
        }

        SolutionSpec struct {
                DisplayName string            `json:"displayName,omitempty"`
                Scope       string            `json:"scope,omitempty"`
                Metadata    map[string]string `json:"metadata,omitempty"`
                Components  []ComponentSpec   `json:"components,omitempty"`
        }
)

func (c SolutionSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(SolutionSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a SolutionSpec type")
        }</span>

        <span class="cov8" title="1">if c.DisplayName != otherC.DisplayName </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Scope != otherC.Scope </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Metadata, otherC.Metadata, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Components, otherC.Components) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "time"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
)

type ComponentResultSpec struct {
        Status  v1alpha2.State `json:"status"`
        Message string         `json:"message"`
}
type TargetResultSpec struct {
        Status           string                         `json:"status"`
        Message          string                         `json:"message,omitempty"`
        ComponentResults map[string]ComponentResultSpec `json:"components,omitempty"`
}
type SummarySpec struct {
        TargetCount    int                         `json:"targetCount"`
        SuccessCount   int                         `json:"successCount"`
        TargetResults  map[string]TargetResultSpec `json:"targets,omitempty"`
        SummaryMessage string                      `json:"message,omitempty"`
        Skipped        bool                        `json:"skipped"`
        IsRemoval      bool                        `json:"isRemoval"`
}
type SummaryResult struct {
        Summary    SummarySpec `json:"summary"`
        Generation string      `json:"generation"`
        Time       time.Time   `json:"time"`
}

func (s *SummarySpec) UpdateTargetResult(target string, spec TargetResultSpec) <span class="cov0" title="0">{
        s.TargetResults[target] = spec
        count := 0
        for _, r := range s.TargetResults </span><span class="cov0" title="0">{
                if r.Status == "OK" </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">s.SuccessCount = count</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import "errors"

type (
        // TargetState defines the current state of the target
        TargetState struct {
                Id       string            `json:"id"`
                Scope    string            `json:"scope,omitempty"`
                Metadata map[string]string `json:"metadata,omitempty"`
                Status   map[string]string `json:"status,omitempty"`
                Spec     *TargetSpec       `json:"spec,omitempty"`
        }

        // TargetSpec defines the spec property of the TargetState
        TargetSpec struct {
                DisplayName   string            `json:"displayName,omitempty"`
                Scope         string            `json:"scope,omitempty"`
                Metadata      map[string]string `json:"metadata,omitempty"`
                Properties    map[string]string `json:"properties,omitempty"`
                Components    []ComponentSpec   `json:"components,omitempty"`
                Constraints   string            `json:"constraints,omitempty"`
                Topologies    []TopologySpec    `json:"topologies,omitempty"`
                ForceRedeploy bool              `json:"forceRedeploy,omitempty"`
                Generation    string            `json:"generation,omitempty"`
                // Defines the version of a particular resource
                Version string `json:"version,omitempty"`
        }
)

func (c TargetSpec) DeepEquals(other IDeepEquals) (bool, error) <span class="cov8" title="1">{
        otherC, ok := other.(TargetSpec)
        if !ok </span><span class="cov8" title="1">{
                return false, errors.New("parameter is not a TargetSpec type")
        }</span>

        <span class="cov8" title="1">if c.DisplayName != otherC.DisplayName </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Scope != otherC.Scope </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Metadata, otherC.Metadata, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !StringMapsEqual(c.Properties, otherC.Properties, nil) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Components, otherC.Components) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.Constraints != otherC.Constraints </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if !SlicesEqual(c.Topologies, otherC.Topologies) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if c.ForceRedeploy != otherC.ForceRedeploy </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "fmt"
        "strings"

        go_slices "golang.org/x/exp/slices"
        "helm.sh/helm/v3/pkg/strvals"
)

type (
        // IDeepEquals interface defines an interface for memberwise equality comparision
        IDeepEquals interface {
                DeepEquals(other IDeepEquals) (bool, error)
        }

        ValueInjections struct {
                InstanceId   string
                SolutionId   string
                TargetId     string
                ActivationId string
                CatalogId    string
                CampaignId   string
                DeviceId     string
                SkillId      string
                ModelId      string
                SiteId       string
        }
)

// stringMapsEqual compares two string maps for equality
func StringMapsEqual(a map[string]string, b map[string]string, ignoredMissingKeys []string) bool <span class="cov8" title="1">{
        // if len(a) != len(b) {
        //         return false
        // }

        //TODO: I don't think we need this anymore

        for k, v := range a </span><span class="cov8" title="1">{
                if bv, ok := b[k]; ok </span><span class="cov8" title="1">{
                        if bv != v </span><span class="cov8" title="1">{
                                if !strings.Contains(bv, "${{$instance()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$instance()}}") &amp;&amp;
                                        !strings.Contains(bv, "${{$solution()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$solution()}}") &amp;&amp;
                                        !strings.Contains(bv, "${{$target()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$target()}}") </span><span class="cov8" title="1">{ // Skip comparision because $instance is filled by different instances
                                        return false
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if bv, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if bv != v </span><span class="cov8" title="1">{
                                if !strings.Contains(bv, "${{$instance()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$instance()}}") &amp;&amp;
                                        !strings.Contains(bv, "${{$solution()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$solution()}}") &amp;&amp;
                                        !strings.Contains(bv, "${{$target()}}") &amp;&amp;
                                        !strings.Contains(v, "${{$target()}}") </span><span class="cov0" title="0">{ // Skip comparision because $instance is filled by different instances
                                        return false
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

func StringStringMapsEqual(a map[string]map[string]string, b map[string]map[string]string, ignoredMissingKeys []string) bool <span class="cov8" title="1">{
        for k, v := range a </span><span class="cov8" title="1">{
                if bv, ok := b[k]; ok </span><span class="cov8" title="1">{
                        if !StringMapsEqual(v, bv, ignoredMissingKeys) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if bv, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if !StringMapsEqual(v, bv, ignoredMissingKeys) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> {
                        if !go_slices.Contains(ignoredMissingKeys, k) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

// Compatibility Helper
func ExtractRawEnvFromProperties(properties map[string]interface{}) map[string]string <span class="cov0" title="0">{
        env := make(map[string]string)
        for k, v := range properties </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, "env.") </span><span class="cov0" title="0">{
                        env[k] = fmt.Sprintf("%v", v)
                }</span>
        }

        <span class="cov0" title="0">return env</span>
}

func EnvMapsEqual(a map[string]string, b map[string]string) bool <span class="cov8" title="1">{
        // if len(a) != len(b) {
        //         return false
        // }

        for k, v := range a </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, "env.") </span><span class="cov8" title="1">{
                        if bv, ok := b[k]; ok </span><span class="cov8" title="1">{
                                if bv != v </span><span class="cov8" title="1">{
                                        if !strings.Contains(bv, "${{$instance()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$instance()}}") &amp;&amp;
                                                !strings.Contains(bv, "${{$solution()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$solution()}}") &amp;&amp;
                                                !strings.Contains(bv, "${{$target()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$target()}}") </span><span class="cov8" title="1">{ // Skip comparision because $instance is filled by different instances
                                                return false
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, "env.") </span><span class="cov8" title="1">{
                        if bv, ok := a[k]; ok </span><span class="cov8" title="1">{
                                if bv != v </span><span class="cov8" title="1">{
                                        if !strings.Contains(bv, "${{$instance()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$instance()}}") &amp;&amp;
                                                !strings.Contains(bv, "${{$solution()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$solution()}}") &amp;&amp;
                                                !strings.Contains(bv, "${{$target()}}") &amp;&amp;
                                                !strings.Contains(v, "${{$target()}}") </span><span class="cov0" title="0">{ // Skip comparision because $instance is filled by different instances
                                                return false
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return true</span>
}

// SliceEuql compares two slices of IDeepEqual items, ignoring the order of items
// It returns two if the two slices are exactly the same, otherwise it returns false
func SlicesEqual[K IDeepEquals](a []K, b []K) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">used := make(map[int]bool)
        for _, ia := range a </span><span class="cov8" title="1">{
                found := false
                for j, jb := range b </span><span class="cov8" title="1">{
                        if _, ok := used[j]; !ok </span><span class="cov8" title="1">{
                                t, e := ia.DeepEquals(jb)
                                if e != nil </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov8" title="1">if t </span><span class="cov8" title="1">{
                                        used[j] = true
                                        found = true
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func SlicesCover[K IDeepEquals](src []K, dest []K) bool <span class="cov8" title="1">{
        for _, ia := range src </span><span class="cov8" title="1">{
                found := false
                for _, jb := range dest </span><span class="cov8" title="1">{
                        t, e := ia.DeepEquals(jb)
                        if e == nil &amp;&amp; t </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func SlicesAny[K IDeepEquals](src []K, dest []K) bool <span class="cov8" title="1">{
        for _, ia := range src </span><span class="cov8" title="1">{
                for _, jb := range dest </span><span class="cov8" title="1">{
                        t, e := ia.DeepEquals(jb)
                        if e == nil &amp;&amp; t </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

func CheckProperty(a map[string]string, b map[string]string, key string, ignoreCase bool) bool <span class="cov8" title="1">{
        if va, oka := a[key]; oka </span><span class="cov8" title="1">{
                if vb, okb := b[key]; okb </span><span class="cov8" title="1">{
                        if ignoreCase </span><span class="cov8" title="1">{
                                return strings.EqualFold(va, vb)
                        }</span> else<span class="cov8" title="1"> {
                                return va == vb
                        }</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return true</span>
}

func CheckPropertyCompat(a map[string]interface{}, b map[string]interface{}, key string, ignoreCase bool) bool <span class="cov0" title="0">{
        if va, oka := a[key]; oka </span><span class="cov0" title="0">{
                if vb, okb := b[key]; okb </span><span class="cov0" title="0">{
                        if ignoreCase </span><span class="cov0" title="0">{
                                return strings.EqualFold(fmt.Sprintf("%v", va), fmt.Sprintf("%v", vb))
                        }</span> else<span class="cov0" title="0"> {
                                return va == vb
                        }</span>
                }

                <span class="cov0" title="0">return false</span>
        }

        <span class="cov0" title="0">return true</span>
}

func HasSameProperty(a map[string]string, b map[string]string, key string) bool <span class="cov0" title="0">{
        va, oka := a[key]
        vb, okb := b[key]
        if oka &amp;&amp; okb </span><span class="cov0" title="0">{
                return va == vb
        }</span> else<span class="cov0" title="0"> if !oka &amp;&amp; !okb </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>

}

func HasSamePropertyCompat(a map[string]interface{}, b map[string]interface{}, key string) bool <span class="cov0" title="0">{
        va, oka := a[key]
        vb, okb := b[key]
        if oka &amp;&amp; okb </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", va) == fmt.Sprintf("%v", vb)
        }</span> else<span class="cov0" title="0"> if !oka &amp;&amp; !okb </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>

}

func CollectPropertiesWithPrefix(col map[string]interface{}, prefix string, injections *ValueInjections, withHierarchy bool) map[string]interface{} <span class="cov8" title="1">{
        ret := make(map[string]interface{})
        for k, v := range col </span><span class="cov8" title="1">{
                if v, ok := v.(string); ok &amp;&amp; strings.HasPrefix(k, prefix) </span><span class="cov8" title="1">{
                        key := k[len(prefix):]
                        if withHierarchy </span><span class="cov8" title="1">{
                                strvals.ParseInto(fmt.Sprintf("%s=%s", key, ResolveString(v, injections)), ret)
                        }</span> else<span class="cov8" title="1"> {
                                ret[key] = ResolveString(v, injections)
                        }</span>
                }
        }

        <span class="cov8" title="1">return ret</span>
}

func ReadPropertyCompat(col map[string]interface{}, key string, injections *ValueInjections) string <span class="cov8" title="1">{
        if v, ok := col[key]; ok </span><span class="cov8" title="1">{
                return ResolveString(fmt.Sprintf("%v", v), injections)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func ReadProperty(col map[string]string, key string, injections *ValueInjections) string <span class="cov8" title="1">{
        if v, ok := col[key]; ok </span><span class="cov8" title="1">{
                return ResolveString(v, injections)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func ResolveString(value string, injections *ValueInjections) string <span class="cov8" title="1">{
        //TODO: future enhancement - analyze the syntax instead of doing simply string replacement
        if injections != nil </span><span class="cov0" title="0">{
                value = strings.ReplaceAll(value, "${{$instance()}}", injections.InstanceId)
                value = strings.ReplaceAll(value, "${{$solution()}}", injections.SolutionId)
                value = strings.ReplaceAll(value, "${{$target()}}", injections.TargetId)
                value = strings.ReplaceAll(value, "${{$activation()}}", injections.ActivationId)
                value = strings.ReplaceAll(value, "${{$catalog()}}", injections.CatalogId)
                value = strings.ReplaceAll(value, "${{$campaign()}}", injections.CampaignId)
                value = strings.ReplaceAll(value, "${{$device()}}", injections.DeviceId)
                value = strings.ReplaceAll(value, "${{$model()}}", injections.ModelId)
                value = strings.ReplaceAll(value, "${{$skill()}}", injections.SkillId)
                value = strings.ReplaceAll(value, "${{$site()}}", injections.SiteId)
        }</span>

        <span class="cov8" title="1">return value</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package model

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
)

type PropertyDesc struct {
        Name            string `json:"name"`
        IgnoreCase      bool   `json:"ignoreCase,omitempty"`
        SkipIfMissing   bool   `json:"skipIfMissing,omitempty"`
        PrefixMatch     bool   `json:"prefixMatch,omitempty"`
        IsComponentName bool   `json:"isComponentName,omitempty"`
}
type ValidationRule struct {
        RequiredComponentType     string         `json:"requiredType"`
        ChangeDetectionProperties []PropertyDesc `json:"changeDetection,omitempty"`
        ChangeDetectionMetadata   []PropertyDesc `json:"changeDetectionMetadata,omitempty"`
        RequiredProperties        []string       `json:"requiredProperties"`
        OptionalProperties        []string       `json:"optionalProperties"`
        RequiredMetadata          []string       `json:"requiredMetadata"`
        OptionalMetadata          []string       `json:"optionalMetadata"`
        // a provider that supports scope isolation can deploy to specified scopes other than the "default" scope.
        // instances from different scopes are isolated from each other.
        ScopeIsolation bool `json:"supportScopes,omitempty"`
        // a provider that supports instance isolation can deploy multiple instances on the same target without conflicts.
        InstanceIsolation bool `json:"instanceIsolation,omitempty"`
}

func (v ValidationRule) ValidateInputs(inputs map[string]interface{}) error <span class="cov0" title="0">{
        // required properties must all present
        for _, p := range v.RequiredProperties </span><span class="cov0" title="0">{
                if ReadPropertyCompat(inputs, p, nil) == "" </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("required property '%s' is missing", p), v1alpha2.BadRequest)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v ValidationRule) Validate(components []ComponentSpec) error <span class="cov8" title="1">{
        for _, c := range components </span><span class="cov8" title="1">{
                err := v.validateComponent(c)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (v ValidationRule) IsComponentChanged(old ComponentSpec, new ComponentSpec) bool <span class="cov8" title="1">{
        for _, c := range v.ChangeDetectionProperties </span><span class="cov8" title="1">{
                if strings.Contains(c.Name, "*") </span><span class="cov8" title="1">{
                        escapedPattern := regexp.QuoteMeta(c.Name)
                        // Replace the wildcard (*) with a regular expression pattern
                        regexpPattern := strings.ReplaceAll(escapedPattern, `\*`, ".*")
                        // Compile the regular expression
                        regexpObject := regexp.MustCompile("^" + regexpPattern + "$")
                        for k := range old.Properties </span><span class="cov8" title="1">{
                                if regexpObject.MatchString(k) </span><span class="cov8" title="1">{
                                        if compareProperties(c, old, new, k) </span><span class="cov8" title="1">{
                                                return true
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        if c.IsComponentName </span><span class="cov0" title="0">{
                                if !compareStrings(old.Name, new.Name, c.IgnoreCase, c.SkipIfMissing) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if compareProperties(c, old, new, c.Name) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, c := range v.ChangeDetectionMetadata </span><span class="cov0" title="0">{
                if strings.Contains(c.Name, "*") </span><span class="cov0" title="0">{
                        escapedPattern := regexp.QuoteMeta(c.Name)
                        // Replace the wildcard (*) with a regular expression pattern
                        regexpPattern := strings.ReplaceAll(escapedPattern, `\*`, ".*")
                        // Compile the regular expression
                        regexpObject := regexp.MustCompile("^" + regexpPattern + "$")
                        for k := range old.Metadata </span><span class="cov0" title="0">{
                                if regexpObject.MatchString(k) </span><span class="cov0" title="0">{
                                        if compareMetadata(c, old, new, k) </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        if compareMetadata(c, old, new, c.Name) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
func compareStrings(a, b string, ignoreCase bool, prefixMatch bool) bool <span class="cov8" title="1">{
        ta := a
        tb := b
        if ignoreCase </span><span class="cov0" title="0">{
                ta = strings.ToLower(a)
                tb = strings.ToLower(b)
        }</span>
        <span class="cov8" title="1">if !prefixMatch </span><span class="cov8" title="1">{
                return ta == tb
        }</span> else<span class="cov0" title="0"> {
                return strings.HasPrefix(tb, ta)
        }</span>
}
func compareProperties(c PropertyDesc, old ComponentSpec, new ComponentSpec, key string) bool <span class="cov8" title="1">{
        if v, ok := old.Properties[key]; ok </span><span class="cov8" title="1">{
                if nv, nok := new.Properties[key]; nok </span><span class="cov8" title="1">{
                        if !compareStrings(fmt.Sprintf("%v", v), fmt.Sprintf("%v", nv), c.IgnoreCase, c.PrefixMatch) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                if !c.SkipIfMissing </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func compareMetadata(c PropertyDesc, old ComponentSpec, new ComponentSpec, key string) bool <span class="cov0" title="0">{
        if v, ok := old.Metadata[key]; ok </span><span class="cov0" title="0">{
                if nv, nok := new.Metadata[key]; nok </span><span class="cov0" title="0">{
                        if !compareStrings(fmt.Sprintf("%v", v), fmt.Sprintf("%v", nv), c.IgnoreCase, c.PrefixMatch) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                if !c.SkipIfMissing </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (v ValidationRule) validateComponent(component ComponentSpec) error <span class="cov8" title="1">{
        //required component type must be set
        if v.RequiredComponentType != "" &amp;&amp; v.RequiredComponentType != component.Type </span><span class="cov8" title="1">{
                return v1alpha2.NewCOAError(nil, fmt.Sprintf("provider requires component type '%s', but '%s' is found instead", v.RequiredComponentType, component.Type), v1alpha2.BadRequest)
        }</span>

        // required properties must all present
        <span class="cov8" title="1">for _, p := range v.RequiredProperties </span><span class="cov8" title="1">{
                if ReadPropertyCompat(component.Properties, p, nil) == "" </span><span class="cov8" title="1">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("required property '%s' is missing", p), v1alpha2.BadRequest)
                }</span>
        }

        // required metadata must all present
        <span class="cov8" title="1">for _, p := range v.RequiredMetadata </span><span class="cov8" title="1">{
                if ReadProperty(component.Metadata, p, nil) == "" </span><span class="cov8" title="1">{
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("required metadata '%s' is missing", p), v1alpha2.BadRequest)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

// Code generated by controller-gen. DO NOT EDIT.

package model

import ()

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BindingSpec) DeepCopyInto(out *BindingSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Config != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Config, &amp;out.Config
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BindingSpec.
func (in *BindingSpec) DeepCopy() *BindingSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BindingSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComponentError) DeepCopyInto(out *ComponentError) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComponentError.
func (in *ComponentError) DeepCopy() *ComponentError <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ComponentError)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DeviceSpec) DeepCopyInto(out *DeviceSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Bindings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Bindings, &amp;out.Bindings
                *out = make([]BindingSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DeviceSpec.
func (in *DeviceSpec) DeepCopy() *DeviceSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DeviceSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ErrorType) DeepCopyInto(out *ErrorType) <span class="cov0" title="0">{
        *out = *in
        if in.Details != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Details, &amp;out.Details
                *out = make([]TargetError, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ErrorType.
func (in *ErrorType) DeepCopy() *ErrorType <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ErrorType)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterSpec) DeepCopyInto(out *FilterSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Parameters != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Parameters, &amp;out.Parameters
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterSpec.
func (in *FilterSpec) DeepCopy() *FilterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(FilterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstanceSpec) DeepCopyInto(out *InstanceSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Parameters != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Parameters, &amp;out.Parameters
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Metadata != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Metadata, &amp;out.Metadata
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">in.Target.DeepCopyInto(&amp;out.Target)
        if in.Topologies != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Topologies, &amp;out.Topologies
                *out = make([]TopologySpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Pipelines != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Pipelines, &amp;out.Pipelines
                *out = make([]PipelineSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Arguments != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Arguments, &amp;out.Arguments
                *out = make(map[string]map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        var outVal map[string]string
                        if val == nil </span><span class="cov0" title="0">{
                                (*out)[key] = nil
                        }</span> else<span class="cov0" title="0"> {
                                in, out := &amp;val, &amp;outVal
                                *out = make(map[string]string, len(*in))
                                for key, val := range *in </span><span class="cov0" title="0">{
                                        (*out)[key] = val
                                }</span>
                        }
                        <span class="cov0" title="0">(*out)[key] = outVal</span>
                }
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstanceSpec.
func (in *InstanceSpec) DeepCopy() *InstanceSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(InstanceSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ModelSpec) DeepCopyInto(out *ModelSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Bindings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Bindings, &amp;out.Bindings
                *out = make([]BindingSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ModelSpec.
func (in *ModelSpec) DeepCopy() *ModelSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ModelSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeSpec) DeepCopyInto(out *NodeSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Configurations != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Configurations, &amp;out.Configurations
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Inputs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Inputs, &amp;out.Inputs
                *out = make([]RouteSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Outputs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Outputs, &amp;out.Outputs
                *out = make([]RouteSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeSpec.
func (in *NodeSpec) DeepCopy() *NodeSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NodeSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ObjectRef) DeepCopyInto(out *ObjectRef) <span class="cov0" title="0">{
        *out = *in
        if in.Metadata != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Metadata, &amp;out.Metadata
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ObjectRef.
func (in *ObjectRef) DeepCopy() *ObjectRef <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ObjectRef)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PipelineSpec) DeepCopyInto(out *PipelineSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Parameters != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Parameters, &amp;out.Parameters
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PipelineSpec.
func (in *PipelineSpec) DeepCopy() *PipelineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(PipelineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProvisioningStatus) DeepCopyInto(out *ProvisioningStatus) <span class="cov0" title="0">{
        *out = *in
        in.Error.DeepCopyInto(&amp;out.Error)
        if in.Output != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Output, &amp;out.Output
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProvisioningStatus.
func (in *ProvisioningStatus) DeepCopy() *ProvisioningStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ProvisioningStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RouteSpec) DeepCopyInto(out *RouteSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Filters != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Filters, &amp;out.Filters
                *out = make([]FilterSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RouteSpec.
func (in *RouteSpec) DeepCopy() *RouteSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RouteSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteSpec) DeepCopyInto(out *SiteSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteSpec.
func (in *SiteSpec) DeepCopy() *SiteSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SiteSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteStatus) DeepCopyInto(out *SiteStatus) <span class="cov0" title="0">{
        *out = *in
        if in.TargetStatuses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.TargetStatuses, &amp;out.TargetStatuses
                *out = make(map[string]TargetStatus, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.InstanceStatuses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.InstanceStatuses, &amp;out.InstanceStatuses
                *out = make(map[string]InstanceStatus, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteStatus.
func (in *SiteStatus) DeepCopy() *SiteStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SiteStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkillPackageSpec) DeepCopyInto(out *SkillPackageSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Routes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Routes, &amp;out.Routes
                *out = make([]RouteSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkillPackageSpec.
func (in *SkillPackageSpec) DeepCopy() *SkillPackageSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SkillPackageSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkillSpec) DeepCopyInto(out *SkillSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Parameters != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Parameters, &amp;out.Parameters
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Nodes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Nodes, &amp;out.Nodes
                *out = make([]NodeSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Properties != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Properties, &amp;out.Properties
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Bindings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Bindings, &amp;out.Bindings
                *out = make([]BindingSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Edges != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Edges, &amp;out.Edges
                *out = make([]EdgeSpec, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkillSpec.
func (in *SkillSpec) DeepCopy() *SkillSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SkillSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TargetError) DeepCopyInto(out *TargetError) <span class="cov0" title="0">{
        *out = *in
        if in.Details != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Details, &amp;out.Details
                *out = make([]ComponentError, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TargetError.
func (in *TargetError) DeepCopy() *TargetError <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TargetError)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TargetSelector) DeepCopyInto(out *TargetSelector) <span class="cov0" title="0">{
        *out = *in
        if in.Selector != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Selector, &amp;out.Selector
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TargetSelector.
func (in *TargetSelector) DeepCopy() *TargetSelector <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TargetSelector)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopologySpec) DeepCopyInto(out *TopologySpec) <span class="cov0" title="0">{
        *out = *in
        if in.Selector != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Selector, &amp;out.Selector
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Bindings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Bindings, &amp;out.Bindings
                *out = make([]BindingSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopologySpec.
func (in *TopologySpec) DeepCopy() *TopologySpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(TopologySpec)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package catalog

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        coa_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
)

var msLock sync.Mutex

type CatalogConfigProviderConfig struct {
        BaseUrl  string `json:"baseUrl"`
        User     string `json:"user"`
        Password string `json:"password"`
}

type CatalogConfigProvider struct {
        Config  CatalogConfigProviderConfig
        Context *contexts.ManagerContext
}

func (s *CatalogConfigProvider) Init(config providers.IProviderConfig) error <span class="cov0" title="0">{
        msLock.Lock()
        defer msLock.Unlock()
        mockConfig, err := toCatalogConfigProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Config = mockConfig
        return nil</span>
}
func (s *CatalogConfigProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func toCatalogConfigProviderConfig(config providers.IProviderConfig) (CatalogConfigProviderConfig, error) <span class="cov0" title="0">{
        ret := CatalogConfigProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *CatalogConfigProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := CatalogConfigProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func CatalogConfigProviderConfigFromMap(properties map[string]string) (CatalogConfigProviderConfig, error) <span class="cov0" title="0">{
        ret := CatalogConfigProviderConfig{}
        baseUrl, err := utils.GetString(properties, "baseUrl")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.BaseUrl = baseUrl
        if ret.BaseUrl == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "baseUrl is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">user, err := utils.GetString(properties, "user")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.User = user
        if ret.User == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "user is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">password, err := utils.GetString(properties, "password")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.Password = password
        return ret, nil</span>
}
func (m *CatalogConfigProvider) unwindOverrides(override string, field string) (string, error) <span class="cov0" title="0">{
        catalog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, override, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if v, ok := catalog.Spec.Properties[field]; ok </span><span class="cov0" title="0">{
                return v.(string), nil
        }</span>
        <span class="cov0" title="0">if catalog.Spec.ParentName != "" </span><span class="cov0" title="0">{
                return m.unwindOverrides(catalog.Spec.ParentName, field)
        }</span>
        <span class="cov0" title="0">return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("field '%s' is not found in configuration '%s'", field, override), v1alpha2.NotFound)</span>
}
func (m *CatalogConfigProvider) Read(object string, field string, localcontext interface{}) (interface{}, error) <span class="cov0" title="0">{
        catalog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if v, ok := catalog.Spec.Properties[field]; ok </span><span class="cov0" title="0">{
                return m.traceValue(v, localcontext)
        }</span>

        <span class="cov0" title="0">if catalog.Spec.ParentName != "" </span><span class="cov0" title="0">{
                overrid, err := m.unwindOverrides(catalog.Spec.ParentName, field)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span> else<span class="cov0" title="0"> {
                        return overrid, nil
                }</span>
        }

        <span class="cov0" title="0">return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("field '%s' is not found in configuration '%s'", field, object), v1alpha2.NotFound)</span>
}
func (m *CatalogConfigProvider) ReadObject(object string, localcontext interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        catalog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ret := map[string]interface{}{}
        for k, v := range catalog.Spec.Properties </span><span class="cov0" title="0">{
                tv, err := m.traceValue(v, localcontext)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // line 189-196 extracts the returned map and merge the keys with the parent
                // this allows a referenced configuration to be overriden by local values
                <span class="cov0" title="0">if tmap, ok := tv.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for tk, tv := range tmap </span><span class="cov0" title="0">{
                                if _, ok := ret[tk]; !ok </span><span class="cov0" title="0">{
                                        ret[tk] = tv
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">ret[k] = tv</span>
        }
        <span class="cov0" title="0">return ret, nil</span>
}
func (m *CatalogConfigProvider) traceValue(v interface{}, localcontext interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                parser := utils.NewParser(val)
                context := m.Context.VencorContext.EvaluationContext.Clone()
                context.DeploymentSpec = m.Context.VencorContext.EvaluationContext.DeploymentSpec
                if localcontext != nil </span><span class="cov0" title="0">{
                        if ltx, ok := localcontext.(coa_utils.EvaluationContext); ok </span><span class="cov0" title="0">{
                                context.Inputs = ltx.Inputs
                                context.Outputs = ltx.Outputs
                                context.Value = ltx.Value
                                context.Properties = ltx.Properties
                                context.Component = ltx.Component
                                if ltx.DeploymentSpec != nil </span><span class="cov0" title="0">{
                                        context.DeploymentSpec = ltx.DeploymentSpec
                                }</span>
                        }
                }
                <span class="cov0" title="0">v, err := parser.Eval(*context)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">switch vt := v.(type) </span>{
                case string:<span class="cov0" title="0">
                        return vt, nil</span>
                default:<span class="cov0" title="0">
                        return m.traceValue(v, localcontext)</span>
                }
        case []interface{}:<span class="cov0" title="0">
                ret := []interface{}{}
                for _, v := range val </span><span class="cov0" title="0">{
                        tv, err := m.traceValue(v, localcontext)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">ret = append(ret, tv)</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                ret := map[string]interface{}{}
                for k, v := range val </span><span class="cov0" title="0">{
                        tv, err := m.traceValue(v, localcontext)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">ret[k] = tv</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        default:<span class="cov0" title="0">
                return val, nil</span>
        }
}
func (m *CatalogConfigProvider) Set(object string, field string, value interface{}) error <span class="cov0" title="0">{
        catalog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">catalog.Spec.Properties[field] = value
        data, _ := json.Marshal(catalog.Spec)
        return utils.UpsertCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password, data)</span>
}
func (m *CatalogConfigProvider) SetObject(object string, value map[string]interface{}) error <span class="cov0" title="0">{
        catalog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">catalog.Spec.Properties = map[string]interface{}{}
        for k, v := range value </span><span class="cov0" title="0">{
                catalog.Spec.Properties[k] = v
        }</span>
        <span class="cov0" title="0">data, _ := json.Marshal(catalog.Spec)
        return utils.UpsertCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password, data)</span>
}
func (m *CatalogConfigProvider) Remove(object string, field string) error <span class="cov0" title="0">{
        catlog, err := utils.GetCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, ok := catlog.Spec.Properties[field]; !ok </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "field not found", v1alpha2.NotFound)
        }</span>
        <span class="cov0" title="0">delete(catlog.Spec.Properties, field)
        data, _ := json.Marshal(catlog.Spec)
        return utils.UpsertCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password, data)</span>
}
func (m *CatalogConfigProvider) RemoveObject(object string) error <span class="cov0" title="0">{
        return utils.DeleteCatalog(context.TODO(), m.Config.BaseUrl, object, m.Config.User, m.Config.Password)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package memorygraph

import (
        "context"
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/graph"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
)

type MemoryGraphProviderConfig struct {
}

type MemoryGraphProvider struct {
        Config  MemoryGraphProviderConfig
        Context *contexts.ManagerContext
        Data    []v1alpha2.INode
}

func (g *MemoryGraphProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        mockConfig, err := toMemoryGraphProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">g.Config = mockConfig
        return nil</span>
}
func (s *MemoryGraphProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func toMemoryGraphProviderConfig(config providers.IProviderConfig) (MemoryGraphProviderConfig, error) <span class="cov8" title="1">{
        ret := MemoryGraphProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *MemoryGraphProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := MemoryhGraphProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func MemoryhGraphProviderConfigFromMap(properties map[string]string) (MemoryGraphProviderConfig, error) <span class="cov0" title="0">{
        ret := MemoryGraphProviderConfig{}
        return ret, nil
}</span>
func (i *MemoryGraphProvider) GetSet(ctx context.Context, request graph.GetRequest) (graph.GetSetResponse, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetSet",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        ret := graph.GetSetResponse{
                Nodes: make([]v1alpha2.INode, 0),
        }
        _, err = i.getNode(request.Name, request.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">for _, node := range i.Data </span><span class="cov8" title="1">{
                if request.Filter != "" &amp;&amp; node.GetType() != request.Filter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if node.GetParent() == request.Name </span><span class="cov8" title="1">{
                        ret.Nodes = append(ret.Nodes, node)
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *MemoryGraphProvider) GetTree(ctx context.Context, request graph.GetRequest) (graph.GetSetResponse, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetTree",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        ret := graph.GetSetResponse{
                Nodes: make([]v1alpha2.INode, 0),
        }
        root, err := i.getNode(request.Name, request.Filter)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">ret.Nodes = append(ret.Nodes, root)
        i.collectChildren(root, request.Filter, &amp;ret)
        return ret, nil</span>
}
func (i *MemoryGraphProvider) collectChildren(root v1alpha2.INode, filter string, ret *graph.GetSetResponse) <span class="cov8" title="1">{
        queue := []v1alpha2.INode{root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                node := queue[0]
                queue = queue[1:]
                for _, child := range i.Data </span><span class="cov8" title="1">{
                        if filter != "" &amp;&amp; child.GetType() != filter </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if child.GetParent() == node.GetId() </span><span class="cov8" title="1">{
                                ret.Nodes = append(ret.Nodes, child)
                                queue = append(queue, child)
                        }</span>
                }
        }
}
func (i *MemoryGraphProvider) GetGraph(ctx context.Context, request graph.GetRequest) (graph.GetGraphResponse, error) <span class="cov0" title="0">{
        return graph.GetGraphResponse{}, v1alpha2.NewCOAError(nil, "not implemented", v1alpha2.NotImplemented)
}</span>
func (i *MemoryGraphProvider) getNode(name string, filter string) (v1alpha2.INode, error) <span class="cov8" title="1">{
        var root v1alpha2.INode
        for _, node := range i.Data </span><span class="cov8" title="1">{
                if filter != "" &amp;&amp; node.GetType() != filter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if node.GetId() == name </span><span class="cov8" title="1">{
                        root = node
                        break</span>
                }
        }
        <span class="cov8" title="1">if root == nil </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(nil, "root node not found", v1alpha2.NotFound)
        }</span>
        <span class="cov8" title="1">return root, nil</span>
}
func (i *MemoryGraphProvider) GetChain(ctx context.Context, request graph.GetRequest) (graph.GetSetResponse, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetChain",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        rep, err := i.GetTree(ctx, request)
        return rep, err
}</span>
func (i *MemoryGraphProvider) GetSets(ctx context.Context, request graph.ListRequest) (graph.GetSetsResponse, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetSets",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        seenSets := make(map[string]bool)
        ret := graph.GetSetsResponse{
                Sets: make(map[string]graph.GetSetResponse),
        }
        for _, node := range i.Data </span><span class="cov0" title="0">{
                if request.Filter != "" &amp;&amp; node.GetType() != request.Filter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if node.GetParent() == "" &amp;&amp; !seenSets[node.GetId()] </span><span class="cov0" title="0">{
                        seenSets[node.GetId()] = true
                        var set graph.GetSetResponse
                        set, err = i.GetSet(ctx, graph.GetRequest{
                                Name: node.GetId(),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, err
                        }</span>
                        <span class="cov0" title="0">ret.Sets[node.GetId()] = set</span>
                }
        }
        <span class="cov0" title="0">return ret, nil</span>

}
func (i *MemoryGraphProvider) GetTrees(ctx context.Context, request graph.ListRequest) (graph.GetSetsResponse, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetTrees",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        seenSets := make(map[string]bool)
        ret := graph.GetSetsResponse{
                Sets: make(map[string]graph.GetSetResponse),
        }
        for _, node := range i.Data </span><span class="cov0" title="0">{
                if request.Filter != "" &amp;&amp; node.GetType() != request.Filter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if node.GetParent() == "" &amp;&amp; !seenSets[node.GetId()] </span><span class="cov0" title="0">{
                        seenSets[node.GetId()] = true
                        var set graph.GetSetResponse
                        set, err = i.GetTree(ctx, graph.GetRequest{
                                Name: node.GetId(),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, err
                        }</span>
                        <span class="cov0" title="0">ret.Sets[node.GetId()] = set</span>
                }
        }
        <span class="cov0" title="0">return ret, nil</span>
}
func (i *MemoryGraphProvider) GetChains(ctx context.Context, request graph.ListRequest) (graph.GetSetsResponse, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Memory Graph Provider", ctx, &amp;map[string]string{
                "method": "GetChains",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        seenSets := make(map[string]bool)
        ret := graph.GetSetsResponse{
                Sets: make(map[string]graph.GetSetResponse),
        }
        for _, node := range i.Data </span><span class="cov8" title="1">{
                if request.Filter != "" &amp;&amp; node.GetType() != request.Filter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if node.GetParent() == "" &amp;&amp; !seenSets[node.GetId()] </span><span class="cov8" title="1">{
                        seenSets[node.GetId()] = true
                        var set graph.GetSetResponse
                        set, err = i.GetChain(ctx, graph.GetRequest{
                                Name: node.GetId(),
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">ret.Sets[node.GetId()] = set</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *MemoryGraphProvider) GetGraphs(ctx context.Context, request graph.ListRequest) (graph.GetGraphsResponse, error) <span class="cov0" title="0">{
        return graph.GetGraphsResponse{}, v1alpha2.NewCOAError(nil, "not implemented", v1alpha2.NotImplemented)
}</span>

func (i *MemoryGraphProvider) IsPure() bool <span class="cov0" title="0">{
        return false
}</span>
func (i *MemoryGraphProvider) SetData(data []v1alpha2.INode) error <span class="cov8" title="1">{
        i.Data = data
        return nil
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package counter

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "sync"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
)

var msLock sync.Mutex

type CounterStageProviderConfig struct {
        ID string `json:"id"`
}
type CounterStageProvider struct {
        Config  CounterStageProviderConfig
        Context *contexts.ManagerContext
}

func (m *CounterStageProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        msLock.Lock()
        defer msLock.Unlock()

        mockConfig, err := toMockStageProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.Config = mockConfig
        return nil</span>
}
func (s *CounterStageProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>
func toMockStageProviderConfig(config providers.IProviderConfig) (CounterStageProviderConfig, error) <span class="cov8" title="1">{
        ret := CounterStageProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *CounterStageProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := MockStageProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func MockStageProviderConfigFromMap(properties map[string]string) (CounterStageProviderConfig, error) <span class="cov0" title="0">{
        ret := CounterStageProviderConfig{}
        ret.ID = properties["id"]
        return ret, nil
}</span>
func (i *CounterStageProvider) Process(ctx context.Context, mgrContext contexts.ManagerContext, inputs map[string]interface{}) (map[string]interface{}, bool, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("[Stage] Counter provider", ctx, &amp;map[string]string{
                "method": "Process",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        outputs := make(map[string]interface{})
        selfState := make(map[string]interface{})
        if state, ok := inputs["__state"]; ok </span><span class="cov8" title="1">{
                selfState = state.(map[string]interface{})
        }</span>

        <span class="cov8" title="1">for k, v := range inputs </span><span class="cov8" title="1">{
                if k != "__state" </span><span class="cov8" title="1">{
                        if !strings.HasSuffix(k, ".init") </span><span class="cov8" title="1">{
                                var iv int64
                                if iv, err = getNumber(v); err == nil </span><span class="cov8" title="1">{
                                        if s, ok := selfState[k]; ok </span><span class="cov8" title="1">{
                                                var sv int64
                                                if sv, err = getNumber(s); err == nil </span><span class="cov8" title="1">{
                                                        selfState[k] = sv + iv
                                                        outputs[k] = sv + iv
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                if vs, ok := inputs[k+".init"]; ok </span><span class="cov8" title="1">{
                                                        var ivs int64
                                                        if ivs, err = getNumber(vs); err == nil </span><span class="cov8" title="1">{
                                                                selfState[k] = ivs + iv
                                                                outputs[k] = ivs + iv
                                                        }</span>
                                                } else<span class="cov8" title="1"> {
                                                        selfState[k] = iv
                                                        outputs[k] = iv
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">outputs["__state"] = selfState
        return outputs, false, nil</span>
}

func getNumber(val interface{}) (int64, error) <span class="cov8" title="1">{
        if v, ok := val.(int64); ok </span><span class="cov8" title="1">{
                return v, nil
        }</span>
        <span class="cov8" title="1">if v, ok := val.(int); ok </span><span class="cov8" title="1">{
                return int64(v), nil
        }</span>
        <span class="cov0" title="0">if v, ok := val.(float64); ok </span><span class="cov0" title="0">{
                return int64(v), nil
        }</span>
        <span class="cov0" title="0">if v, ok := val.(float32); ok </span><span class="cov0" title="0">{
                return int64(v), nil
        }</span>
        <span class="cov0" title="0">if v, ok := val.(string); ok </span><span class="cov0" title="0">{
                if v, err := strconv.ParseInt(v, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return v, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("cannot convert %v to number", val)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package create

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "sync"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
)

var msLock sync.Mutex

type CreateStageProviderConfig struct {
        BaseUrl      string `json:"baseUrl"`
        User         string `json:"user"`
        Password     string `json:"password"`
        WaitCount    int    `json:"wait.count,omitempty"`
        WaitInterval int    `json:"wait.interval,omitempty"`
}

type CreateStageProvider struct {
        Config  CreateStageProviderConfig
        Context *contexts.ManagerContext
}

func (s *CreateStageProvider) Init(config providers.IProviderConfig) error <span class="cov0" title="0">{
        msLock.Lock()
        defer msLock.Unlock()
        mockConfig, err := toSymphonyStageProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Config = mockConfig
        return nil</span>
}
func (s *CreateStageProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>
func toSymphonyStageProviderConfig(config providers.IProviderConfig) (CreateStageProviderConfig, error) <span class="cov0" title="0">{
        ret := CreateStageProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *CreateStageProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := SymphonyStageProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func SymphonyStageProviderConfigFromMap(properties map[string]string) (CreateStageProviderConfig, error) <span class="cov0" title="0">{
        ret := CreateStageProviderConfig{}
        baseUrl, err := utils.GetString(properties, "baseUrl")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.BaseUrl = baseUrl
        if ret.BaseUrl == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "baseUrl is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">user, err := utils.GetString(properties, "user")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.User = user
        if ret.User == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "user is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">password, err := utils.GetString(properties, "password")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">waitStr, err := utils.GetString(properties, "wait.count")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">waitCount, err := strconv.Atoi(waitStr)
        if err != nil </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(err, "wait.count must be an integer", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">ret.WaitCount = waitCount
        waitStr, err = utils.GetString(properties, "wait.interval")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">waitInterval, err := strconv.Atoi(waitStr)
        if err != nil </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(err, "wait.interval must be an integer", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">ret.WaitInterval = waitInterval
        ret.Password = password
        if waitCount &lt;= 0 </span><span class="cov0" title="0">{
                waitCount = 1
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func (i *CreateStageProvider) Process(ctx context.Context, mgrContext contexts.ManagerContext, inputs map[string]interface{}) (map[string]interface{}, bool, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("[Stage] Create provider", ctx, &amp;map[string]string{
                "method": "Process",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        outputs := make(map[string]interface{})

        objectType := stage.ReadInputString(inputs, "objectType")
        objectName := stage.ReadInputString(inputs, "objectName")
        action := stage.ReadInputString(inputs, "action")
        object := inputs["object"]
        var oData []byte
        if object != nil </span><span class="cov0" title="0">{
                oData, _ = json.Marshal(object)
        }</span>
        <span class="cov0" title="0">lastSummaryMessage := ""
        switch objectType </span>{
        case "instance":<span class="cov0" title="0">
                objectScope := stage.ReadInputString(inputs, "objectScope")
                if objectScope == "" </span><span class="cov0" title="0">{
                        objectScope = "default"
                }</span>

                <span class="cov0" title="0">if action == "remove" </span><span class="cov0" title="0">{
                        err = utils.DeleteInstance(ctx, i.Config.BaseUrl, objectName, i.Config.User, i.Config.Password, objectScope)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = utils.CreateInstance(ctx, i.Config.BaseUrl, objectName, i.Config.User, i.Config.Password, oData, objectScope)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, false, err
                        }</span>
                        <span class="cov0" title="0">for ic := 0; ic &lt; i.Config.WaitCount; ic++ </span><span class="cov0" title="0">{
                                var summary model.SummaryResult
                                summary, err = utils.GetSummary(ctx, i.Config.BaseUrl, i.Config.User, i.Config.Password, objectName, objectScope)
                                lastSummaryMessage = summary.Summary.SummaryMessage
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, false, err
                                }</span>
                                <span class="cov0" title="0">if summary.Summary.SuccessCount == summary.Summary.TargetCount </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(time.Duration(i.Config.WaitInterval) * time.Second)</span>
                        }
                        <span class="cov0" title="0">err = v1alpha2.NewCOAError(nil, fmt.Sprintf("Instance creation failed: %s", lastSummaryMessage), v1alpha2.InternalError)
                        return nil, false, err</span>
                }
        }
        <span class="cov0" title="0">outputs["objectType"] = objectType
        outputs["objectName"] = objectName

        return outputs, false, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        coa_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var msLock sync.Mutex
var sLog = logger.NewLogger("coa.runtime")

type HttpStageProviderConfig struct {
        Url                string `json:"url"`
        Method             string `json:"method"`
        SuccessCodes       []int  `json:"successCodes,omitempty"`
        WaitUrl            string `json:"wait.url,omitempty"`
        WaitInterval       int    `json:"wait.interval,omitempty"`
        WaitCount          int    `json:"wait.count,omitempty"`
        WaitStartCodes     []int  `json:"wait.start,omitempty"`
        WaitSuccessCodes   []int  `json:"wait.success,omitempty"`
        WaitFailedCodes    []int  `json:"wait.fail,omitempty"`
        WaitExpression     string `json:"wait.expression,omitempty"`
        WaitExpressionType string `json:"wait.expressionType,omitempty"`
}
type HttpStageProvider struct {
        Config  HttpStageProviderConfig
        Context *contexts.ManagerContext
}

func (m *HttpStageProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        msLock.Lock()
        defer msLock.Unlock()
        sLog.Debug("  P (Http Stage): initialize")

        mockConfig, err := toHttpStageProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): expected HttpStageProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">m.Config = mockConfig
        return nil</span>
}
func (s *HttpStageProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>
func toHttpStageProviderConfig(config providers.IProviderConfig) (HttpStageProviderConfig, error) <span class="cov8" title="1">{
        ret := HttpStageProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *HttpStageProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := MockStageProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func MockStageProviderConfigFromMap(properties map[string]string) (HttpStageProviderConfig, error) <span class="cov0" title="0">{
        ret := HttpStageProviderConfig{}
        if v, ok := properties["url"]; ok </span><span class="cov0" title="0">{
                ret.Url = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "missing required property url", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["method"]; ok </span><span class="cov0" title="0">{
                ret.Method = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "missing required property method", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["successCodes"]; ok </span><span class="cov0" title="0">{
                codes, err := readIntArray(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov0" title="0">ret.SuccessCodes = codes</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.success"]; ok </span><span class="cov0" title="0">{
                codes, err := readIntArray(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov0" title="0">ret.SuccessCodes = codes</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.start"]; ok </span><span class="cov0" title="0">{
                codes, err := readIntArray(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov0" title="0">ret.SuccessCodes = codes</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.fail"]; ok </span><span class="cov0" title="0">{
                codes, err := readIntArray(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov0" title="0">ret.SuccessCodes = codes</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.url"]; ok </span><span class="cov0" title="0">{
                ret.WaitUrl = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["wait.interval"]; ok </span><span class="cov0" title="0">{
                interval, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to parse wait interval %v", v), v1alpha2.BadConfig)
                }</span>
                <span class="cov0" title="0">ret.WaitInterval = interval</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.count"]; ok </span><span class="cov0" title="0">{
                count, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to parse wait count %v", v), v1alpha2.BadConfig)
                }</span>
                <span class="cov0" title="0">ret.WaitCount = count</span>
        }
        <span class="cov0" title="0">if v, ok := properties["wait.expression"]; ok </span><span class="cov0" title="0">{
                ret.WaitExpression = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["wait.expressionType"]; ok </span><span class="cov0" title="0">{
                ret.WaitExpressionType = v
        }</span> else<span class="cov0" title="0"> {
                ret.WaitExpressionType = "symphony"
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func readIntArray(s string) ([]int, error) <span class="cov0" title="0">{
        var codes []int
        for _, code := range strings.Split(s, ",") </span><span class="cov0" title="0">{
                code = strings.TrimSpace(code)
                if code == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">intCode, err := strconv.Atoi(code)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to parse code %v", code), v1alpha2.BadConfig)
                }</span>
                <span class="cov0" title="0">codes = append(codes, intCode)</span>
        }
        <span class="cov0" title="0">return codes, nil</span>
}
func (i *HttpStageProvider) Process(ctx context.Context, mgrContext contexts.ManagerContext, inputs map[string]interface{}) (map[string]interface{}, bool, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("[Stage] Http provider", ctx, &amp;map[string]string{
                "method": "Process",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Http Stage): start process request")

        // Check all config fields for override in inputs
        var configMap map[string]interface{}
        configJson, _ := json.Marshal(i.Config)
        json.Unmarshal(configJson, &amp;configMap)
        for key := range configMap </span><span class="cov8" title="1">{
                val, found := inputs[key]
                if found </span><span class="cov0" title="0">{
                        configMap[key] = val
                }</span>
        }
        <span class="cov8" title="1">configJson, err = json.Marshal(configMap)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): failed to override config with input: %v", err)
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(configJson, &amp;i.Config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): failed to override config with input: %v", err)
                return nil, false, err
        }</span>

        <span class="cov8" title="1">sLog.Infof("  P (Http Stage): %v: %v", i.Config.Method, i.Config.Url)
        webClient := &amp;http.Client{}
        req, err := http.NewRequest(fmt.Sprintf("%v", i.Config.Method), fmt.Sprintf("%v", i.Config.Url), nil)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): failed to create request: %v", err)
                return nil, false, err
        }</span>
        <span class="cov8" title="1">for key, input := range inputs </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "header.") </span><span class="cov0" title="0">{
                        req.Header.Add(key[7:], fmt.Sprintf("%v", input))
                }</span>
                <span class="cov0" title="0">if key == "body" </span><span class="cov0" title="0">{
                        var jData []byte
                        jData, err = json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Http Stage): failed to encode json request body: %v", err)
                                return nil, false, err
                        }</span>
                        <span class="cov0" title="0">req.Body = ioutil.NopCloser(bytes.NewBuffer(jData))
                        req.ContentLength = int64(len(jData))</span>
                }
        }

        <span class="cov8" title="1">resp, err := webClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): request failed: %v", err)
                return nil, false, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        outputs := make(map[string]interface{})

        for key, values := range resp.Header </span><span class="cov8" title="1">{
                outputs[fmt.Sprintf("header.%v", key)] = values
        }</span>

        <span class="cov8" title="1">data, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Http Stage): failed to read request response: %v", err)
                return nil, false, err
        }</span>
        <span class="cov8" title="1">outputs["body"] = string(data) //TODO: probably not so good to assume string
        outputs["status"] = resp.StatusCode

        if i.Config.WaitUrl != "" </span><span class="cov8" title="1">{
                okToWait := false
                if len(i.Config.WaitStartCodes) &gt; 0 </span><span class="cov8" title="1">{
                        for _, code := range i.Config.WaitStartCodes </span><span class="cov8" title="1">{
                                if code == resp.StatusCode </span><span class="cov8" title="1">{
                                        okToWait = true
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if !okToWait </span><span class="cov0" title="0">{
                        return nil, false, v1alpha2.NewCOAError(nil, fmt.Sprintf("unexpected status code %v", resp.StatusCode), v1alpha2.BadConfig)
                }</span>
                <span class="cov8" title="1">counter := 0
                failed := false
                succeeded := false
                sLog.Debugf("  P (Http Stage): WaitCount: %d", i.Config.WaitCount)
                for counter &lt; i.Config.WaitCount || i.Config.WaitCount == 0 </span><span class="cov8" title="1">{
                        sLog.Infof("  P (Http Stage): start wait iteration %d", counter)
                        var waitReq *http.Request
                        waitReq, err = http.NewRequest("GET", i.Config.WaitUrl, nil)
                        for key, input := range inputs </span><span class="cov0" title="0">{
                                if strings.HasPrefix(key, "header.") </span><span class="cov0" title="0">{
                                        waitReq.Header.Add(key[7:], fmt.Sprintf("%v", input))
                                }</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Http Stage): failed to create wait request: %v", err)
                                return nil, false, err
                        }</span>
                        <span class="cov8" title="1">var waitResp *http.Response
                        waitResp, err = webClient.Do(waitReq)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Http Stage): wait request failed: %v", err)
                                return nil, false, err
                        }</span>
                        <span class="cov8" title="1">defer waitResp.Body.Close()
                        if len(i.Config.WaitFailedCodes) &gt; 0 </span><span class="cov0" title="0">{
                                for _, code := range i.Config.WaitFailedCodes </span><span class="cov0" title="0">{
                                        if code == waitResp.StatusCode </span><span class="cov0" title="0">{
                                                failed = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if len(i.Config.WaitSuccessCodes) &gt; 0 </span><span class="cov8" title="1">{
                                for _, code := range i.Config.WaitSuccessCodes </span><span class="cov8" title="1">{
                                        if code == waitResp.StatusCode </span><span class="cov8" title="1">{
                                                succeeded = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if succeeded </span><span class="cov8" title="1">{
                                var data []byte
                                data, err = ioutil.ReadAll(waitResp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (Http Stage): failed to read wait request response: %v", err)
                                        succeeded = false
                                }</span> else<span class="cov8" title="1"> {
                                        if i.Config.WaitExpression != "" </span><span class="cov8" title="1">{
                                                var obj interface{}
                                                err = json.Unmarshal(data, &amp;obj)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        sLog.Errorf("  P (Http Stage): wait response could not be decoded to json: %v", err)
                                                        succeeded = false
                                                }</span> else<span class="cov8" title="1"> {
                                                        switch i.Config.WaitExpressionType </span>{
                                                        case "jsonpath":<span class="cov8" title="1">
                                                                var result interface{}
                                                                result, err = utils.JsonPathQuery(obj, i.Config.WaitExpression)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        sLog.Errorf("  P (Http Stage): failed to evaluate JsonPath: %v", err)
                                                                }</span>
                                                                <span class="cov8" title="1">succeeded = err == nil
                                                                outputs["waitResult"] = result</span>
                                                        default:<span class="cov8" title="1">
                                                                parser := utils.NewParser(i.Config.WaitExpression)
                                                                var val interface{}
                                                                val, err = parser.Eval(coa_utils.EvaluationContext{
                                                                        Value: obj,
                                                                })
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        sLog.Errorf("  P (Http Stage): failed to evaluate Symphony expression: %v", err)
                                                                }</span>
                                                                <span class="cov8" title="1">succeeded = (err == nil &amp;&amp; val != "false") // a boolean Symphony expression may evaluate to "false" as a string, indicating the condition is not met
                                                                outputs["waitResult"] = val</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">if succeeded </span><span class="cov8" title="1">{
                                                outputs["waitBody"] = string(data) //TODO: probably not so good to assume string
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if !failed &amp;&amp; !succeeded </span><span class="cov0" title="0">{
                                counter++
                                if i.Config.WaitInterval &gt; 0 </span><span class="cov0" title="0">{
                                        sLog.Debug("  P (Http Stage): sleep for wait interval")
                                        time.Sleep(time.Duration(i.Config.WaitInterval) * time.Second)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">if failed </span><span class="cov0" title="0">{
                        return nil, false, v1alpha2.NewCOAError(nil, fmt.Sprintf("failed to wait for operation %v", resp.StatusCode), v1alpha2.BadConfig)
                }</span>

        } else<span class="cov8" title="1"> if len(i.Config.SuccessCodes) &gt; 0 </span><span class="cov0" title="0">{
                for _, code := range i.Config.SuccessCodes </span><span class="cov0" title="0">{
                        if code == resp.StatusCode </span><span class="cov0" title="0">{
                                return outputs, false, nil
                        }</span>
                }
                <span class="cov0" title="0">sLog.Errorf("  P (Http Stage): failed to process request: %d", resp.StatusCode)
                return nil, false, v1alpha2.NewCOAError(nil, fmt.Sprintf("unexpected status code %v", resp.StatusCode), v1alpha2.BadConfig)</span>
        }

        <span class="cov8" title="1">sLog.Infof("  P (Http Stage): process request completed with: %d", resp.StatusCode)
        return outputs, false, nil</span>
}
func (*HttpStageProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov0" title="0">{
        return model.ValidationRule{
                RequiredProperties:        []string{},
                OptionalProperties:        []string{"header.*", "body"},
                RequiredComponentType:     "",
                RequiredMetadata:          []string{},
                OptionalMetadata:          []string{},
                ChangeDetectionProperties: []model.PropertyDesc{},
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package patch

import (
        "context"
        "encoding/json"
        "sync"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var msLock sync.Mutex
var sLog = logger.NewLogger("coa.runtime")

type PatchStageProviderConfig struct {
        BaseUrl  string `json:"baseUrl"`
        User     string `json:"user"`
        Password string `json:"password"`
}

type PatchStageProvider struct {
        Config  PatchStageProviderConfig
        Context *contexts.ManagerContext
}

func (s *PatchStageProvider) Init(config providers.IProviderConfig) error <span class="cov0" title="0">{
        msLock.Lock()
        defer msLock.Unlock()
        mockConfig, err := toPatchStageProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Config = mockConfig
        return nil</span>
}
func (s *PatchStageProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>
func toPatchStageProviderConfig(config providers.IProviderConfig) (PatchStageProviderConfig, error) <span class="cov0" title="0">{
        ret := PatchStageProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *PatchStageProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := SymphonyStageProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func SymphonyStageProviderConfigFromMap(properties map[string]string) (PatchStageProviderConfig, error) <span class="cov0" title="0">{
        ret := PatchStageProviderConfig{}
        baseUrl, err := utils.GetString(properties, "baseUrl")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.BaseUrl = baseUrl
        if ret.BaseUrl == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "baseUrl is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">user, err := utils.GetString(properties, "user")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.User = user
        if ret.User == "" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "user is required", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">password, err := utils.GetString(properties, "password")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">ret.Password = password
        return ret, nil</span>
}
func (m *PatchStageProvider) traceValue(v interface{}, ctx interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                parser := utils.NewParser(val)
                context := m.Context.VencorContext.EvaluationContext.Clone()
                context.Value = ctx
                v, err := parser.Eval(*context)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">switch vt := v.(type) </span>{
                case string:<span class="cov0" title="0">
                        return vt, nil</span>
                default:<span class="cov0" title="0">
                        return m.traceValue(v, ctx)</span>
                }
        case []interface{}:<span class="cov0" title="0">
                ret := []interface{}{}
                for _, v := range val </span><span class="cov0" title="0">{
                        tv, err := m.traceValue(v, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">ret = append(ret, tv)</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                ret := map[string]interface{}{}
                for k, v := range val </span><span class="cov0" title="0">{
                        tv, err := m.traceValue(v, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">ret[k] = tv</span>
                }
                <span class="cov0" title="0">return ret, nil</span>
        default:<span class="cov0" title="0">
                return val, nil</span>
        }
}

func (i *PatchStageProvider) Process(ctx context.Context, mgrContext contexts.ManagerContext, inputs map[string]interface{}) (map[string]interface{}, bool, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("[Stage] Patch Provider", ctx, &amp;map[string]string{
                "method": "Process",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Patch Stage): start process request")

        outputs := make(map[string]interface{})

        objectType := stage.ReadInputString(inputs, "objectType")
        objectName := stage.ReadInputString(inputs, "objectName")
        patchSource := stage.ReadInputString(inputs, "patchSource")
        var patchContent interface{}
        if v, ok := inputs["patchContent"]; ok </span><span class="cov0" title="0">{
                patchContent = v
        }</span>
        <span class="cov0" title="0">componentName := stage.ReadInputString(inputs, "component")
        propertyName := stage.ReadInputString(inputs, "property")
        subKey := stage.ReadInputString(inputs, "subKey")
        dedupKey := stage.ReadInputString(inputs, "dedupKey")
        patchAction := stage.ReadInputString(inputs, "patchAction")
        if patchAction == "" </span><span class="cov0" title="0">{
                patchAction = "add"
        }</span>
        <span class="cov0" title="0">udpated := false

        var catalog model.CatalogState

        switch patchSource </span>{
        case "", "catalog":<span class="cov0" title="0">
                if v, ok := patchContent.(string); ok </span><span class="cov0" title="0">{
                        catalog, err = utils.GetCatalog(ctx, i.Config.BaseUrl, v, i.Config.User, i.Config.Password)

                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Patch Stage): error getting catalog %s", v)
                                return nil, false, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        sLog.Errorf("  P (Patch Stage): error getting catalog %s", v)
                        err = v1alpha2.NewCOAError(nil, "patchContent is not valid", v1alpha2.BadConfig)
                        return nil, false, err
                }</span>
        case "inline":<span class="cov0" title="0">
                if componentName != "" </span><span class="cov0" title="0">{
                        if v, ok := patchContent.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                catalog = model.CatalogState{
                                        Spec: &amp;model.CatalogSpec{
                                                Properties: v,
                                        },
                                }
                        }</span> else<span class="cov0" title="0"> {
                                sLog.Errorf("  P (Patch Stage): error getting catalog %s", v)
                                err = v1alpha2.NewCOAError(nil, "patchContent is not valid", v1alpha2.BadConfig)
                                return nil, false, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        var componentSpec model.ComponentSpec
                        jData, _ := json.Marshal(patchContent)
                        if err = json.Unmarshal(jData, &amp;componentSpec); err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Patch Stage): error unmarshalling componentSpec")
                                return nil, false, err
                        }</span>
                        <span class="cov0" title="0">catalog = model.CatalogState{
                                Spec: &amp;model.CatalogSpec{
                                        Properties: map[string]interface{}{
                                                "spec": componentSpec,
                                        },
                                },
                        }</span>
                }
        default:<span class="cov0" title="0">
                sLog.Errorf("  P (Patch Stage): unsupported patchSource: %s", patchSource)
                err = v1alpha2.NewCOAError(nil, "patchSource is not valid", v1alpha2.BadConfig)
                return nil, false, err</span>
        }

        <span class="cov0" title="0">for k, v := range catalog.Spec.Properties </span><span class="cov0" title="0">{
                var tv interface{}
                tv, err = i.traceValue(v, inputs["context"])
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Patch Stage): error tracing value %s", k)
                        return nil, false, err
                }</span>
                <span class="cov0" title="0">catalog.Spec.Properties[k] = tv</span>
        }

        <span class="cov0" title="0">switch objectType </span>{
        case "solution":<span class="cov0" title="0">
                objectScope := stage.ReadInputString(inputs, "objectScope")
                if objectScope == "" </span><span class="cov0" title="0">{
                        objectScope = "default"
                }</span>
                <span class="cov0" title="0">var solution model.SolutionState
                solution, err := utils.GetSolution(ctx, i.Config.BaseUrl, objectName, i.Config.User, i.Config.Password, objectScope)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Patch Stage): error getting solution %s", objectName)
                        return nil, false, err
                }</span>

                <span class="cov0" title="0">if componentName == "" </span><span class="cov0" title="0">{
                        componentSpec := catalog.Spec.Properties["spec"].(model.ComponentSpec)
                        for i, c := range solution.Spec.Components </span><span class="cov0" title="0">{
                                if c.Name == componentSpec.Name </span><span class="cov0" title="0">{
                                        if patchAction == "remove" </span><span class="cov0" title="0">{
                                                solution.Spec.Components = append(solution.Spec.Components[:i], solution.Spec.Components[i+1:]...)
                                        }</span> else<span class="cov0" title="0"> {
                                                solution.Spec.Components[i] = componentSpec
                                        }</span>
                                        <span class="cov0" title="0">udpated = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !udpated &amp;&amp; patchAction != "remove" </span><span class="cov0" title="0">{
                                solution.Spec.Components = append(solution.Spec.Components, componentSpec)
                                udpated = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        for i, c := range solution.Spec.Components </span><span class="cov0" title="0">{
                                if c.Name == componentName </span><span class="cov0" title="0">{
                                        for k, p := range c.Properties </span><span class="cov0" title="0">{
                                                if k == propertyName </span><span class="cov0" title="0">{
                                                        if subKey != "" </span><span class="cov0" title="0">{
                                                                if detailedTarget, ok := p.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                        if v, ok := detailedTarget[subKey]; ok </span><span class="cov0" title="0">{
                                                                                if targetMap, ok := v.([]interface{}); ok </span><span class="cov0" title="0">{
                                                                                        replaced := false
                                                                                        if dedupKey != "" </span><span class="cov0" title="0">{
                                                                                                for i, v := range targetMap </span><span class="cov0" title="0">{
                                                                                                        if vmap, ok := v.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                                                                if vmap[dedupKey] == catalog.Spec.Properties[dedupKey] </span><span class="cov0" title="0">{
                                                                                                                        if patchAction == "remove" </span><span class="cov0" title="0">{
                                                                                                                                targetMap = append(targetMap[:i], targetMap[i+1:]...)
                                                                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                                                                targetMap[i] = catalog.Spec.Properties
                                                                                                                        }</span>
                                                                                                                        <span class="cov0" title="0">replaced = true
                                                                                                                        break</span>
                                                                                                                }
                                                                                                        }
                                                                                                }
                                                                                        }
                                                                                        <span class="cov0" title="0">if !replaced &amp;&amp; patchAction != "remove" </span><span class="cov0" title="0">{
                                                                                                targetMap = append(targetMap, catalog.Spec.Properties)
                                                                                        }</span>
                                                                                        <span class="cov0" title="0">detailedTarget[subKey] = targetMap
                                                                                        solution.Spec.Components[i].Properties[propertyName] = detailedTarget
                                                                                        udpated = true</span>
                                                                                } else<span class="cov0" title="0"> {
                                                                                        sLog.Errorf("  P (Patch Stage): target properties is not valid")
                                                                                        err = v1alpha2.NewCOAError(nil, "target properties is not valid", v1alpha2.BadConfig)
                                                                                        return nil, false, err
                                                                                }</span>
                                                                        } else<span class="cov0" title="0"> {
                                                                                sLog.Errorf("  P (Patch Stage): subKey is not valid")
                                                                                err = v1alpha2.NewCOAError(nil, "subKey is not valid", v1alpha2.BadConfig)
                                                                                return nil, false, err
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        sLog.Errorf("  P (Patch Stage): subKey is not valid")
                                                                        err = v1alpha2.NewCOAError(nil, "subKey is not valid", v1alpha2.BadConfig)
                                                                        return nil, false, err
                                                                }</span>
                                                        } else<span class="cov0" title="0"> {
                                                                if targetMap, ok := p.([]interface{}); ok </span><span class="cov0" title="0">{
                                                                        replaced := false
                                                                        if dedupKey != "" </span><span class="cov0" title="0">{
                                                                                for i, v := range targetMap </span><span class="cov0" title="0">{
                                                                                        if vmap, ok := v.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                                                                if vmap[dedupKey] == catalog.Spec.Properties[dedupKey] </span><span class="cov0" title="0">{
                                                                                                        if patchAction == "remove" </span><span class="cov0" title="0">{
                                                                                                                targetMap = append(targetMap[:i], targetMap[i+1:]...)
                                                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                                                targetMap[i] = catalog.Spec.Properties
                                                                                                        }</span>
                                                                                                        <span class="cov0" title="0">replaced = true
                                                                                                        break</span>
                                                                                                }
                                                                                        }
                                                                                }
                                                                        }
                                                                        <span class="cov0" title="0">if !replaced &amp;&amp; patchAction != "remove" </span><span class="cov0" title="0">{
                                                                                targetMap = append(targetMap, catalog.Spec.Properties)
                                                                        }</span>
                                                                        <span class="cov0" title="0">solution.Spec.Components[i].Properties[propertyName] = targetMap
                                                                        udpated = true</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        sLog.Errorf("  P (Patch Stage): target properties is not valid")
                                                                        err = v1alpha2.NewCOAError(nil, "target properties is not valid", v1alpha2.BadConfig)
                                                                        return nil, false, err
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if udpated </span><span class="cov0" title="0">{
                        jData, _ := json.Marshal(solution.Spec)
                        err := utils.UpsertSolution(ctx, i.Config.BaseUrl, objectName, i.Config.User, i.Config.Password, jData, objectScope)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Patch Stage): error updating solution %s", objectName)
                                return nil, false, err
                        }</span>
                }

        }
        <span class="cov0" title="0">sLog.Info("  P (Patch Stage): end process request")
        return outputs, false, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package script

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/google/uuid"
)

var sLog = logger.NewLogger("coa.runtime")

type ScriptStageProviderConfig struct {
        Name          string `json:"name"`
        Script        string `json:"script"`
        ScriptFolder  string `json:"scriptFolder,omitempty"`
        StagingFolder string `json:"stagingFolder,omitempty"`
        ScriptEngine  string `json:"scriptEngine,omitempty"`
}

type ScriptStageProvider struct {
        Config  ScriptStageProviderConfig
        Context *contexts.ManagerContext
}

func ScriptProviderConfigFromMap(properties map[string]string) (ScriptStageProviderConfig, error) <span class="cov0" title="0">{
        ret := ScriptStageProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov0" title="0">{
                ret.Name = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["stagingFolder"]; ok </span><span class="cov0" title="0">{
                ret.StagingFolder = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["scriptFolder"]; ok </span><span class="cov0" title="0">{
                ret.ScriptFolder = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["script"]; ok </span><span class="cov0" title="0">{
                ret.Script = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "invalid script provider config, exptected 'script'", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["scriptEngine"]; ok </span><span class="cov0" title="0">{
                ret.ScriptEngine = v
        }</span> else<span class="cov0" title="0"> {
                ret.ScriptEngine = "bash"
        }</span>
        <span class="cov0" title="0">if ret.ScriptEngine != "bash" &amp;&amp; ret.ScriptEngine != "powershell" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "invalid script engine, exptected 'bash' or 'powershell'", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func (i *ScriptStageProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := ScriptProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}

func (s *ScriptStageProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *ScriptStageProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("[Stage] Script Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Script Stage): Init()")

        updateConfig, err := toScriptStageProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("expected ScriptProviderConfig")
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov0" title="0">{
                err = downloadFile(i.Config.ScriptFolder, i.Config.Script, i.Config.StagingFolder)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func downloadFile(scriptFolder string, script string, stagingFolder string) error <span class="cov0" title="0">{
        sPath, err := url.JoinPath(scriptFolder, script)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tPath := filepath.Join(stagingFolder, script)

        out, err := os.Create(tPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        resp, err := http.Get(sPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        _, err = io.Copy(out, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Chmod(tPath, 0755)</span>
}
func toScriptStageProviderConfig(config providers.IProviderConfig) (ScriptStageProviderConfig, error) <span class="cov8" title="1">{
        ret := ScriptStageProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

func (i *ScriptStageProvider) Process(ctx context.Context, mgrContext contexts.ManagerContext, inputs map[string]interface{}) (map[string]interface{}, bool, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("[Stage] Script Provider", ctx, &amp;map[string]string{
                "method": "Process",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Script Stage): start process request")

        id := uuid.New().String()
        input := id + ".json"
        output := id + "-output.json"

        staging := filepath.Join(i.Config.StagingFolder, input)
        file, _ := json.MarshalIndent(inputs, "", " ")
        _ = ioutil.WriteFile(staging, file, 0644)

        abs, _ := filepath.Abs(staging)

        defer os.Remove(abs)

        scriptAbs, _ := filepath.Abs(filepath.Join(i.Config.ScriptFolder, i.Config.Script))
        if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov0" title="0">{
                scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.StagingFolder, i.Config.Script))
        }</span>

        <span class="cov8" title="1">o, err := i.runCommand(scriptAbs, abs)
        sLog.Debugf("  P (Script Stage): get script output: %s", o)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Stage): failed to run get script: %+v", err)
                return nil, false, err
        }</span>

        <span class="cov8" title="1">outputStaging := filepath.Join(i.Config.StagingFolder, output)

        data, err := ioutil.ReadFile(outputStaging)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Stage): failed to parse get script output (expected map[string]interface{}): %+v", err)
                return nil, false, err
        }</span>

        <span class="cov8" title="1">abs_output, _ := filepath.Abs(outputStaging)

        defer os.Remove(abs_output)

        ret := make(map[string]interface{})
        err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Stage): failed to parse get script output (expected map[string]interface{}): %+v", err)
                return nil, false, err
        }</span>

        <span class="cov8" title="1">return ret, false, nil</span>
}

func (i *ScriptStageProvider) runCommand(scriptAbs string, parameters ...string) ([]byte, error) <span class="cov8" title="1">{
        // Sanitize input to prevent command injection
        scriptAbs = strings.ReplaceAll(scriptAbs, "|", "")
        scriptAbs = strings.ReplaceAll(scriptAbs, "&amp;", "")
        for idx, param := range parameters </span><span class="cov8" title="1">{
                parameters[idx] = strings.ReplaceAll(param, "|", "")
                parameters[idx] = strings.ReplaceAll(param, "&amp;", "")
        }</span>

        <span class="cov8" title="1">var err error
        var out []byte
        params := make([]string, 0)
        if i.Config.ScriptEngine == "" || i.Config.ScriptEngine == "bash" </span><span class="cov8" title="1">{
                params = append(params, parameters...)
                out, err = exec.Command(scriptAbs, params...).Output()
        }</span> else<span class="cov0" title="0"> {
                params = append(params, scriptAbs)
                params = append(params, parameters...)
                out, err = exec.Command("powershell", params...).Output()
        }</span>
        <span class="cov8" title="1">return out, err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package k8s

import (
        "context"
        "encoding/json"
        "fmt"
        "path/filepath"
        "strconv"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/states"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        k8s_errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

var sLog = logger.NewLogger("coa.runtime")

type K8sStateProviderConfig struct {
        Name       string `json:"name"`
        ConfigType string `json:"configType,omitempty"`
        ConfigData string `json:"configData,omitempty"`
        Context    string `json:"context,omitempty"`
        InCluster  bool   `json:"inCluster"`
}

type K8sStateProvider struct {
        Config        K8sStateProviderConfig
        Context       *contexts.ManagerContext
        DynamicClient dynamic.Interface
}

func K8sStateProviderConfigFromMap(properties map[string]string) (K8sStateProviderConfig, error) <span class="cov8" title="1">{
        ret := K8sStateProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov0" title="0">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov0" title="0">{
                ret.ConfigType = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov0" title="0">{
                ret.ConfigData = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov0" title="0">{
                ret.Context = v
        }</span>
        <span class="cov8" title="1">if ret.ConfigType == "" </span><span class="cov8" title="1">{
                ret.ConfigType = "path"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov0" title="0">{
                val := v
                if val != "" </span><span class="cov0" title="0">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of K8s state provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov0" title="0">ret.InCluster = bVal</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *K8sStateProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := K8sStateProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}

func (s *K8sStateProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *K8sStateProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("K8s State Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Debug("  P (K8s State): initialize")

        updateConfig, err := toK8sStateProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (K8s State): expected KubectlTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        var kConfig *rest.Config
        if i.Config.InCluster </span><span class="cov0" title="0">{
                kConfig, err = rest.InClusterConfig()
        }</span> else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "path":<span class="cov8" title="1">
                        if i.Config.ConfigData == "" </span><span class="cov0" title="0">{
                                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                                        i.Config.ConfigData = filepath.Join(home, ".kube", "config")
                                }</span> else<span class="cov0" title="0"> {
                                        err = v1alpha2.NewCOAError(nil, "can't locate home direction to read default kubernetes config file, to run in cluster, set inCluster config setting to true", v1alpha2.BadConfig)
                                        sLog.Errorf("  P (K8s State): %+v", err)
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">kConfig, err = clientcmd.BuildConfigFromFlags("", i.Config.ConfigData)</span>
                case "bytes":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        sLog.Errorf("  P (K8s State): %+v", err)
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                err = v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                                sLog.Errorf("  P (K8s State): %+v", err)
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        err = v1alpha2.NewCOAError(nil, "unrecognized config type, accepted values are: path and bytes", v1alpha2.BadConfig)
                        sLog.Errorf("  P (K8s State): %+v", err)
                        return err</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P (K8s State): %+v", err)
                return err
        }</span>
        <span class="cov0" title="0">i.DynamicClient, err = dynamic.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (K8s State): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func toK8sStateProviderConfig(config providers.IProviderConfig) (K8sStateProviderConfig, error) <span class="cov8" title="1">{
        ret := K8sStateProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        if ret.ConfigType == "" </span><span class="cov0" title="0">{
                ret.ConfigType = "path"
        }</span>
        <span class="cov8" title="1">return ret, err</span>
}

func (s *K8sStateProvider) Upsert(ctx context.Context, entry states.UpsertRequest) (string, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("K8s State Provider", ctx, &amp;map[string]string{
                "method": "Upsert",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (K8s State): upsert state")

        scope := model.ReadProperty(entry.Metadata, "scope", nil)
        group := model.ReadProperty(entry.Metadata, "group", nil)
        version := model.ReadProperty(entry.Metadata, "version", nil)
        resource := model.ReadProperty(entry.Metadata, "resource", nil)

        if scope == "" </span><span class="cov0" title="0">{
                scope = "default"
        }</span>

        <span class="cov0" title="0">resourceId := schema.GroupVersionResource{
                Group:    group,
                Version:  version,
                Resource: resource,
        }

        j, _ := json.Marshal(entry.Value.Body)

        item, err := s.DynamicClient.Resource(resourceId).Namespace(scope).Get(ctx, entry.Value.ID, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // TODO: check if not-found error
                template := model.ReadProperty(entry.Metadata, "template", &amp;model.ValueInjections{
                        TargetId:     entry.Value.ID,
                        SolutionId:   entry.Value.ID, //TODO: This is not very nice. Maybe change ValueInjection to include a generic ID?
                        InstanceId:   entry.Value.ID,
                        ActivationId: entry.Value.ID,
                        CampaignId:   entry.Value.ID,
                        CatalogId:    entry.Value.ID,
                        DeviceId:     entry.Value.ID,
                        ModelId:      entry.Value.ID,
                        SkillId:      entry.Value.ID,
                        SiteId:       entry.Value.ID,
                })
                var unc *unstructured.Unstructured
                err = json.Unmarshal([]byte(template), &amp;unc)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to deserialize template: %v", err)
                        return "", err
                }</span>
                <span class="cov0" title="0">var dict map[string]interface{}
                err = json.Unmarshal(j, &amp;dict)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to get object: %v", err)
                        return "", err
                }</span>
                <span class="cov0" title="0">unc.Object["spec"] = dict["spec"]
                _, err = s.DynamicClient.Resource(resourceId).Namespace(scope).Create(ctx, unc, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to create object: %v", err)
                        return "", err
                }</span>
                //Note: state is ignored for new object
        } else<span class="cov0" title="0"> {
                j, _ := json.Marshal(entry.Value.Body)
                var dict map[string]interface{}
                err = json.Unmarshal(j, &amp;dict)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to unmarshal object: %v", err)
                        return "", err
                }</span>
                <span class="cov0" title="0">if v, ok := dict["spec"]; ok </span><span class="cov0" title="0">{
                        item.Object["spec"] = v

                        _, err = s.DynamicClient.Resource(resourceId).Namespace(scope).Update(ctx, item, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (K8s State): failed to update object: %v", err)
                                return "", err
                        }</span>
                }
                <span class="cov0" title="0">if v, ok := dict["status"]; ok </span><span class="cov0" title="0">{
                        status := &amp;unstructured.Unstructured{
                                Object: map[string]interface{}{
                                        "apiVersion": group + "/" + version,
                                        "kind":       "Status",
                                        "metadata": map[string]interface{}{
                                                "name": entry.Value.ID,
                                        },
                                        "status": v.(map[string]interface{}),
                                },
                        }
                        status.SetResourceVersion(item.GetResourceVersion())
                        _, err = s.DynamicClient.Resource(resourceId).Namespace(scope).UpdateStatus(ctx, status, v1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (K8s State): failed to update object status: %v", err)
                                return "", err
                        }</span>
                }
        }
        <span class="cov0" title="0">return entry.Value.ID, nil</span>
}

func (s *K8sStateProvider) ListAllNamespaces(ctx context.Context, version string) ([]string, error) <span class="cov0" title="0">{
        namespaceResource := schema.GroupVersionResource{Group: "", Version: version, Resource: "namespaces"}
        namespaces, err := s.DynamicClient.Resource(namespaceResource).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ret := []string{}
        for _, namespace := range namespaces.Items </span><span class="cov0" title="0">{
                ret = append(ret, namespace.GetName())
        }</span>
        <span class="cov0" title="0">return ret, err</span>
}

func (s *K8sStateProvider) List(ctx context.Context, request states.ListRequest) ([]states.StateEntry, string, error) <span class="cov0" title="0">{
        var entities []states.StateEntry

        ctx, span := observability.StartSpan("K8s State Provider", ctx, &amp;map[string]string{
                "method": "List",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (K8s State): list state")

        scope := model.ReadProperty(request.Metadata, "scope", nil)
        group := model.ReadProperty(request.Metadata, "group", nil)
        version := model.ReadProperty(request.Metadata, "version", nil)
        resource := model.ReadProperty(request.Metadata, "resource", nil)

        var namespaces []string
        if scope == "" </span><span class="cov0" title="0">{
                ret, err := s.ListAllNamespaces(ctx, version)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to list namespaces: %v", err)
                        return nil, "", err
                }</span>
                <span class="cov0" title="0">namespaces = ret</span>
        } else<span class="cov0" title="0"> {
                namespaces = []string{scope}
        }</span>
        <span class="cov0" title="0">for _, namespace := range namespaces </span><span class="cov0" title="0">{
                resourceId := schema.GroupVersionResource{
                        Group:    group,
                        Version:  version,
                        Resource: resource,
                }
                items, err := s.DynamicClient.Resource(resourceId).Namespace(namespace).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (K8s State): failed to list objects in namespace %s: %v ", namespace, err)
                        return nil, "", err
                }</span>
                <span class="cov0" title="0">for _, v := range items.Items </span><span class="cov0" title="0">{
                        generation := v.GetGeneration()
                        entry := states.StateEntry{
                                ETag: strconv.FormatInt(generation, 10),
                                ID:   v.GetName(),
                                Body: map[string]interface{}{
                                        "spec":   v.Object["spec"],
                                        "status": v.Object["status"],
                                        "scope":  namespace,
                                },
                        }
                        entities = append(entities, entry)
                }</span>
        }
        <span class="cov0" title="0">return entities, "", nil</span>
}

func (s *K8sStateProvider) Delete(ctx context.Context, request states.DeleteRequest) error <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("K8s State Provider", ctx, &amp;map[string]string{
                "method": "Delete",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (K8s State): delete state")

        scope := model.ReadProperty(request.Metadata, "scope", nil)
        group := model.ReadProperty(request.Metadata, "group", nil)
        version := model.ReadProperty(request.Metadata, "version", nil)
        resource := model.ReadProperty(request.Metadata, "resource", nil)

        resourceId := schema.GroupVersionResource{
                Group:    group,
                Version:  version,
                Resource: resource,
        }
        if scope == "" </span><span class="cov0" title="0">{
                scope = "default"
        }</span>

        <span class="cov0" title="0">err = s.DynamicClient.Resource(resourceId).Namespace(scope).Delete(ctx, request.ID, metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (K8s State): failed to delete objects: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *K8sStateProvider) Get(ctx context.Context, request states.GetRequest) (states.StateEntry, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan("K8s State Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (K8s State): get state")

        scope := model.ReadProperty(request.Metadata, "scope", nil)
        group := model.ReadProperty(request.Metadata, "group", nil)
        version := model.ReadProperty(request.Metadata, "version", nil)
        resource := model.ReadProperty(request.Metadata, "resource", nil)

        if scope == "" </span><span class="cov0" title="0">{
                scope = "default"
        }</span>

        <span class="cov0" title="0">resourceId := schema.GroupVersionResource{
                Group:    group,
                Version:  version,
                Resource: resource,
        }

        item, err := s.DynamicClient.Resource(resourceId).Namespace(scope).Get(ctx, request.ID, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                coaError := v1alpha2.NewCOAError(err, "failed to get object", v1alpha2.InternalError)
                //check if not found
                if k8s_errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        coaError.State = v1alpha2.NotFound
                }</span>
                <span class="cov0" title="0">sLog.Errorf("  P (K8s State %v", coaError.Error())
                return states.StateEntry{}, coaError</span>
        }
        <span class="cov0" title="0">generation := item.GetGeneration()
        ret := states.StateEntry{
                ID:   request.ID,
                ETag: strconv.FormatInt(generation, 10),
                Body: map[string]interface{}{
                        "spec":   item.Object["spec"],
                        "status": item.Object["status"],
                        "scope":  scope,
                },
        }
        return ret, nil</span>
}

// Implmeement the IConfigProvider interface
func (s *K8sStateProvider) Read(object string, field string) (string, error) <span class="cov0" title="0">{
        obj, err := s.Get(context.TODO(), states.GetRequest{
                ID: object,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "catalogs",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if v, ok := obj.Body.(map[string]interface{})["spec"]; ok </span><span class="cov0" title="0">{
                spec := v.(map[string]interface{})
                if v, ok := spec["properties"]; ok </span><span class="cov0" title="0">{
                        properties := v.(map[string]interface{})
                        if v, ok := properties[field]; ok </span><span class="cov0" title="0">{
                                return v.(string), nil
                        }</span> else<span class="cov0" title="0"> {
                                return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("field '%s' is not found in configuration catalog '%s'", field, object), v1alpha2.NotFound)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", v1alpha2.NewCOAError(nil, "properties not found", v1alpha2.NotFound)
                }</span>
        }
        <span class="cov0" title="0">return "", v1alpha2.NewCOAError(nil, "spec not found", v1alpha2.NotFound)</span>
}

func (s *K8sStateProvider) ReadObject(object string) (map[string]string, error) <span class="cov0" title="0">{
        obj, err := s.Get(context.TODO(), states.GetRequest{
                ID: object,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "catalogs",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if v, ok := obj.Body.(map[string]interface{})["spec"]; ok </span><span class="cov0" title="0">{
                spec := v.(map[string]interface{})
                if v, ok := spec["properties"]; ok </span><span class="cov0" title="0">{
                        properties := v.(map[string]interface{})
                        ret := map[string]string{}
                        for k, v := range properties </span><span class="cov0" title="0">{
                                ret[k] = v.(string)
                        }</span>
                        <span class="cov0" title="0">return ret, nil</span>
                } else<span class="cov0" title="0"> {
                        return nil, v1alpha2.NewCOAError(nil, "properties not found", v1alpha2.NotFound)
                }</span>
        }
        <span class="cov0" title="0">return nil, v1alpha2.NewCOAError(nil, "spec not found", v1alpha2.NotFound)</span>
}

func (s *K8sStateProvider) Set(object string, field string, value string, scope string) error <span class="cov0" title="0">{
        obj, err := s.Get(context.TODO(), states.GetRequest{
                ID: object,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "catalogs",
                        "scope":    scope,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if v, ok := obj.Body.(map[string]interface{})["spec"]; ok </span><span class="cov0" title="0">{
                spec := v.(map[string]interface{})
                if v, ok := spec["properties"]; ok </span><span class="cov0" title="0">{
                        properties := v.(map[string]interface{})
                        properties[field] = value
                        _, err := s.Upsert(context.TODO(), states.UpsertRequest{
                                Value: obj,
                                Metadata: map[string]string{
                                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Catalog", "metadata": {"name": "${{$catalog()}}"}}`, model.FederationGroup),
                                        "scope":    scope,
                                        "group":    model.FederationGroup,
                                        "version":  "v1",
                                        "resource": "catalogs",
                                },
                        })
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return v1alpha2.NewCOAError(nil, "properties not found", v1alpha2.NotFound)
                }</span>
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, "spec not found", v1alpha2.NotFound)</span>
}
func (s *K8sStateProvider) SetObject(object string, values map[string]string, scope string) error <span class="cov0" title="0">{
        obj, err := s.Get(context.TODO(), states.GetRequest{
                ID: object,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "catalogs",
                        "scope":    scope,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if v, ok := obj.Body.(map[string]interface{})["spec"]; ok </span><span class="cov0" title="0">{
                spec := v.(map[string]interface{})
                if v, ok := spec["properties"]; ok </span><span class="cov0" title="0">{
                        properties := v.(map[string]interface{})
                        for k, v := range values </span><span class="cov0" title="0">{
                                properties[k] = v
                        }</span>
                        <span class="cov0" title="0">_, err := s.Upsert(context.TODO(), states.UpsertRequest{
                                Value: obj,
                                Metadata: map[string]string{
                                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Catalog", "metadata": {"name": "${{$catalog()}}"}}`, model.FederationGroup),
                                        "scope":    scope,
                                        "group":    model.FederationGroup,
                                        "version":  "v1",
                                        "resource": "catalogs",
                                },
                        })
                        return err</span>
                } else<span class="cov0" title="0"> {
                        return v1alpha2.NewCOAError(nil, "properties not found", v1alpha2.NotFound)
                }</span>
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, "spec not found", v1alpha2.NotFound)</span>
}
func (s *K8sStateProvider) Remove(object string, field string, scope string) error <span class="cov0" title="0">{
        obj, err := s.Get(context.TODO(), states.GetRequest{
                ID: object,
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FederationGroup,
                        "resource": "catalogs",
                        "scope":    scope,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if v, ok := obj.Body.(map[string]interface{})["spec"]; ok </span><span class="cov0" title="0">{
                spec := v.(map[string]interface{})
                if v, ok := spec["properties"]; ok </span><span class="cov0" title="0">{
                        properties := v.(map[string]interface{})
                        delete(properties, field)
                        _, err := s.Upsert(context.TODO(), states.UpsertRequest{
                                Value: obj,
                                Metadata: map[string]string{
                                        "template": fmt.Sprintf(`{"apiVersion":"%s/v1", "kind": "Catalog", "metadata": {"name": "${{$catalog()}}"}}`, model.FederationGroup),
                                        "scope":    scope,
                                        "group":    model.FederationGroup,
                                        "version":  "v1",
                                        "resource": "catalogs",
                                },
                        })
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return v1alpha2.NewCOAError(nil, "properties not found", v1alpha2.NotFound)
                }</span>
        }
        <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, "spec not found", v1alpha2.NotFound)</span>
}
func (s *K8sStateProvider) RemoveObject(object string, scope string) error <span class="cov0" title="0">{
        return s.Delete(context.TODO(), states.DeleteRequest{
                ID: object,
                Metadata: map[string]string{
                        "scope":    scope,
                        "group":    model.FederationGroup,
                        "version":  "v1",
                        "resource": "catalogs",
                },
        })
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package adb

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os/exec"
        "regexp"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var aLog = logger.NewLogger("coa.runtime")

type AdbProviderConfig struct {
        Name string `json:"name"`
}

type AdbProvider struct {
        Config  AdbProviderConfig
        Context *contexts.ManagerContext
}

func AdbProviderConfigFromMap(properties map[string]string) (AdbProviderConfig, error) <span class="cov8" title="1">{
        ret := AdbProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *AdbProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := AdbProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}
func (s *AdbProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *AdbProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Android ADB Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        aLog.Info("  P (Android ADB): Init()")

        updateConfig, err := toAdbProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("expected AdbProviderConfig")
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        return nil</span>
}

func toAdbProviderConfig(config providers.IProviderConfig) (AdbProviderConfig, error) <span class="cov8" title="1">{
        ret := AdbProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

func (i *AdbProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("Android ADB Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        aLog.Infof("  P (Android ADB): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        ret := make([]model.ComponentSpec, 0)

        re := regexp.MustCompile(`^package:(\w+\.)+\w+$`)

        for _, component := range references </span><span class="cov8" title="1">{
                if p, ok := component.Component.Properties[model.AppPackage]; ok </span><span class="cov8" title="1">{
                        params := make([]string, 0)
                        params = append(params, "shell")
                        params = append(params, "pm")
                        params = append(params, "list")
                        params = append(params, "packages")
                        params = append(params, fmt.Sprintf("%v", p))
                        var out []byte
                        out, err = exec.Command("adb", params...).Output()

                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">str := string(out)
                        lines := strings.Split(str, "\r\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                if re.Match([]byte(line)) </span><span class="cov0" title="0">{
                                        ret = append(ret, model.ComponentSpec{
                                                Name: line[8:],
                                                Type: model.AppPackage,
                                        })
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *AdbProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Android ADB Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        aLog.Infof("  P (Android ADB Provider): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()

        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>
        <span class="cov8" title="1">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for _, component := range components </span><span class="cov8" title="1">{
                        if component.Name != "" </span><span class="cov8" title="1">{
                                if p, ok := component.Properties[model.AppImage]; ok &amp;&amp; p != "" </span><span class="cov8" title="1">{
                                        if !isDryRun </span><span class="cov8" title="1">{
                                                params := make([]string, 0)
                                                params = append(params, "install")
                                                params = append(params, p.(string))
                                                cmd := exec.Command("adb", params...)
                                                err = cmd.Run()
                                                if err != nil </span><span class="cov8" title="1">{
                                                        ret[component.Name] = model.ComponentResultSpec{
                                                                Status:  v1alpha2.UpdateFailed,
                                                                Message: err.Error(),
                                                        }
                                                        return ret, err
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for _, component := range components </span><span class="cov8" title="1">{
                        if component.Name != "" </span><span class="cov8" title="1">{
                                if p, ok := component.Properties[model.AppPackage]; ok &amp;&amp; p != "" </span><span class="cov8" title="1">{
                                        params := make([]string, 0)
                                        params = append(params, "uninstall")
                                        params = append(params, p.(string))

                                        cmd := exec.Command("adb", params...)
                                        err = cmd.Run()
                                        if err != nil </span><span class="cov8" title="1">{
                                                ret[component.Name] = model.ComponentResultSpec{
                                                        Status:  v1alpha2.DeleteFailed,
                                                        Message: err.Error(),
                                                }
                                                return ret, err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">err = nil
        return ret, nil</span>
}

func (*AdbProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{model.AppPackage, model.AppImage},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package adu

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        azureutils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/cloudutils/azure"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/google/uuid"
)

var sLog = logger.NewLogger("coa.runtime")

type ADUTargetProviderConfig struct {
        Name               string `json:"name"`
        TenantId           string `json:"tenantId"`
        ClientId           string `json:"clientId"`
        ClientSecret       string `json:"clientSecret"`
        ADUAccountEndpoint string `json:"aduAccountEndpoint"`
        ADUAccountInstance string `json:"aduAccountInstance"`
        ADUGroup           string `json:"aduGroup"`
}

type ADUTargetProvider struct {
        Config  ADUTargetProviderConfig
        Context *contexts.ManagerContext
}

func ADUTargetProviderConfigFromMap(properties map[string]string) (ADUTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := ADUTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["tenantId"]; ok </span><span class="cov8" title="1">{
                ret.TenantId = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update provider tenant id is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["clientId"]; ok </span><span class="cov8" title="1">{
                ret.ClientId = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update provider client id is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["clientSecret"]; ok </span><span class="cov8" title="1">{
                ret.ClientSecret = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update provider client secret is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["aduAccountEndpoint"]; ok </span><span class="cov8" title="1">{
                ret.ADUAccountEndpoint = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update account endpoint is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["aduAccountInstance"]; ok </span><span class="cov8" title="1">{
                ret.ADUAccountInstance = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update account instance is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["aduGroup"]; ok </span><span class="cov8" title="1">{
                ret.ADUGroup = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "ADU update group is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *ADUTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := ADUTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *ADUTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *ADUTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("ADU Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("~~~ ADU Target Provider ~~~ : Init()")

        updateConfig, err := toADUTargetProviderConfig(config)
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("~~~ ADU Target Provider ~~~ : expected ADUTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        return nil</span>
}

func toADUTargetProviderConfig(config providers.IProviderConfig) (ADUTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := ADUTargetProviderConfig{}
        if config == nil </span><span class="cov8" title="1">{
                return ret, errors.New("ADUTargetProviderConfig is null")
        }</span>
        <span class="cov8" title="1">data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *ADUTargetProvider) Get(ctx context.Context, dep model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("ADU Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("~~~ ADU Update Provider ~~~ : getting components")
        deployment, err := i.getDeployment()
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("~~~ ADU Target Provider ~~~ : %+v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">ret := []model.ComponentSpec{}

        if deployment.DeploymentId != "" </span><span class="cov0" title="0">{
                ret = append(ret, model.ComponentSpec{
                        Name: deployment.UpdateId.Name,
                        Properties: map[string]interface{}{
                                "update.name":     deployment.UpdateId.Name,
                                "update.provider": deployment.UpdateId.Provider,
                                "update.version":  deployment.UpdateId.Version,
                        },
                })
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}

func getDeploymentFromComponent(c model.ComponentSpec) (azureutils.ADUDeployment, error) <span class="cov8" title="1">{
        provider := ""
        version := ""
        name := ""
        ok := false
        deployment := azureutils.ADUDeployment{}
        if provider, ok = c.Properties["update.provider"].(string); !ok </span><span class="cov0" title="0">{
                return deployment, errors.New("component doesn't contain a update.provider property")
        }</span>
        <span class="cov8" title="1">if version, ok = c.Properties["update.version"].(string); !ok </span><span class="cov0" title="0">{
                return deployment, errors.New("component doesn't contain a update.version property")
        }</span>
        <span class="cov8" title="1">if name, ok = c.Properties["update.name"].(string); !ok </span><span class="cov0" title="0">{
                return deployment, errors.New("component doesn't contain a update.name property")
        }</span>
        <span class="cov8" title="1">deployment.DeploymentId = uuid.New().String()
        deployment.StartDateTime = time.Now().UTC().Format("2006-01-02T15:04:05-0700")
        deployment.UpdateId = azureutils.UpdateId{
                Name:     name,
                Provider: provider,
                Version:  version,
        }
        return deployment, nil</span>
}

func (i *ADUTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("ADU Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (ADU Update): applying components")

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()

        for _, c := range step.Components </span><span class="cov8" title="1">{
                var deployment azureutils.ADUDeployment
                deployment, err = getDeploymentFromComponent(c.Component)
                if err != nil </span><span class="cov0" title="0">{
                        ret[c.Component.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.ValidateFailed,
                                Message: err.Error(),
                        }
                        return ret, err
                }</span>
                <span class="cov8" title="1">if c.Action == "update" </span><span class="cov8" title="1">{
                        deployment.GroupId = i.Config.ADUGroup
                        err = i.applyDeployment(deployment)
                        if err != nil </span><span class="cov8" title="1">{
                                ret[c.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P (ADU Update): %+v", err)
                                return ret, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        err = i.deleteDeploymeent(deployment)
                        if err != nil </span><span class="cov0" title="0">{
                                ret[c.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.DeleteFailed,
                                        Message: err.Error(),
                                }
                                err = nil
                                return ret, nil //TODO: are we ignoring errors on purpose here?
                        }</span>
                }

        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *ADUTargetProvider) getDeployment() (azureutils.ADUDeployment, error) <span class="cov8" title="1">{
        ret := azureutils.ADUDeployment{}
        token, err := azureutils.GetAzureToken(i.Config.TenantId, i.Config.ClientId, i.Config.ClientSecret, "https://api.adu.microsoft.com/.default")
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">group, err := azureutils.GetADUGroup(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup)
        if err != nil </span><span class="cov8" title="1">{
                return ret, err
        }</span>
        <span class="cov0" title="0">if group.DeploymentId == "" </span><span class="cov0" title="0">{
                return ret, nil
        }</span>
        <span class="cov0" title="0">deployment, err := azureutils.GetADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, group.DeploymentId)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return deployment, nil</span>
}
func (i *ADUTargetProvider) deleteDeploymeent(deployment azureutils.ADUDeployment) error <span class="cov8" title="1">{
        token, err := azureutils.GetAzureToken(i.Config.TenantId, i.Config.ClientId, i.Config.ClientSecret, "https://api.adu.microsoft.com/.default")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">existing, err := i.getDeployment()
        if err != nil </span><span class="cov8" title="1">{
                return nil //Can't read existing deployment, ignore
        }</span>
        <span class="cov0" title="0">if existing.UpdateId.Version == deployment.UpdateId.Version &amp;&amp; existing.UpdateId.Name == deployment.UpdateId.Name &amp;&amp; existing.UpdateId.Provider == deployment.UpdateId.Provider </span><span class="cov0" title="0">{
                return azureutils.DeleteADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, existing.DeploymentId)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (i *ADUTargetProvider) applyDeployment(deployment azureutils.ADUDeployment) error <span class="cov8" title="1">{
        token, err := azureutils.GetAzureToken(i.Config.TenantId, i.Config.ClientId, i.Config.ClientSecret, "https://api.adu.microsoft.com/.default")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">group, err := azureutils.GetADUGroup(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">if group.DeploymentId == "" </span><span class="cov0" title="0">{
                err = azureutils.CreateADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, deployment.DeploymentId, deployment)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                existing, err := azureutils.GetADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, group.DeploymentId)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if existing.UpdateId.Version != deployment.UpdateId.Version || existing.UpdateId.Name != deployment.UpdateId.Name || existing.UpdateId.Provider != deployment.UpdateId.Provider </span><span class="cov0" title="0">{
                        err = azureutils.CreateADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, deployment.DeploymentId, deployment)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if deployment.IsCanceled </span><span class="cov0" title="0">{
                                deployment.DeploymentId = existing.DeploymentId
                                err = azureutils.RetryADUDeployment(token, i.Config.ADUAccountEndpoint, i.Config.ADUAccountInstance, i.Config.ADUGroup, deployment.DeploymentId, deployment)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
func (*ADUTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{"update.provider", "update.name", "update.version"},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package iotedge

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "net/http"
        "regexp"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        azureutils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/cloudutils/azure"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/google/uuid"
)

var sLog = logger.NewLogger("coa.runtime")

const (
        ENV_NAME string = "SYMPHONY_AGENT_ADDRESS"
        ENV_SALT string = "SYMPHONY_VERSION_SALT"
)

// Provider config and type
type IoTEdgeTargetProviderConfig struct {
        Name             string `json:"name"`
        KeyName          string `json:"keyName"`
        Key              string `json:"key"`
        IoTHub           string `json:"iotHub"`
        APIVersion       string `json:"apiVersion"`
        DeviceName       string `json:"deviceName"`
        EdgeAgentVersion string `json:"edgeAgentVersion,omitempty"`
        EdgeHubVersion   string `json:"edgeHubVersion,omitempty"`
}
type IoTEdgeTargetProvider struct {
        Config  IoTEdgeTargetProviderConfig
        Context *contexts.ManagerContext
}

// Azure IoT Edge objects
type IoTEdgeDeployment struct {
        ModulesContent map[string]ModuleState `json:"modulesContent"`
}
type ModuleState struct {
        DesiredProperties map[string]interface{} `json:"properties.desired"`
}
type DesiredProperties struct {
        SchemaVersion string            `json:"schemaVersion"`
        Runtime       Runtime           `json:"runtime"`
        SystemModules map[string]Module `json:"systemModules"`
        Modules       map[string]Module `json:"modules"`
        Version       int               `json:"$version,omitempty"`
        Metadata      interface{}       `json:"$metadata,omitempty"`
}
type Runtime struct {
        Type     string                 `json:"type"`
        Settings map[string]interface{} `json:"settings"`
}
type RegistryCredential struct {
        UserName string `json:"username"`
        Password string `json:"password"`
        Address  string `json:"address"`
}
type Module struct {
        Type              string                 `json:"type"`
        Settings          map[string]string      `json:"settings"`
        Status            string                 `json:"status,omitempty"`
        RestartPolicy     string                 `json:"restartPolicy,omitempty"`
        Version           interface{}            `json:"version,omitempty"`
        DesiredProperties map[string]interface{} `json:"metadata,omitempty"`
        Graph             map[string]interface{} `json:"graph,omitempty"`
        GraphFlavor       string                 `json:"graphFlavor,omitempty"`
        IotHubRoutes      map[string]string      `json:"routes,omitempty"`
        Environments      map[string]EnvValue    `json:"env,omitempty"`
}
type EnvValue struct {
        Value string `json:"value"`
}
type ModuleID struct {
        ModuleId string `json:"moduleId"`
}
type ModuleTwin struct {
        DeviceId   string               `json:"deviceId"`
        ModuleId   string               `json:"moduleId"`
        Properties ModuleTwinProperties `json:"properties"`
        Version    interface{}          `json:"version"`
}
type ModuleTwinProperties struct {
        Desired  map[string]interface{} `json:"desired"`
        Reported map[string]interface{} `json:"reported"`
}

func IoTEdgeTargetProviderConfigFromMap(properties map[string]string) (IoTEdgeTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := IoTEdgeTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["keyName"]; ok </span><span class="cov8" title="1">{
                ret.KeyName = v
        }</span> else<span class="cov8" title="1"> {
                ret.KeyName = "iothubowner"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["key"]; ok </span><span class="cov8" title="1">{
                ret.Key = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "IoT Edge update provider key is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["iotHub"]; ok </span><span class="cov8" title="1">{
                ret.IoTHub = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "IoT Edge update provider IoT Hub name is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["apiVersion"]; ok </span><span class="cov0" title="0">{
                ret.APIVersion = v
        }</span> else<span class="cov8" title="1"> {
                ret.APIVersion = "2020-05-31-preview"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["edgeAgentVersion"]; ok </span><span class="cov0" title="0">{
                ret.EdgeAgentVersion = v
        }</span> else<span class="cov8" title="1"> {
                ret.EdgeAgentVersion = "1.3"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["edgeHubVersion"]; ok </span><span class="cov0" title="0">{
                ret.EdgeHubVersion = v
        }</span> else<span class="cov8" title="1"> {
                ret.EdgeHubVersion = "1.3"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["deviceName"]; ok </span><span class="cov8" title="1">{
                ret.DeviceName = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "IoT Edge update provider device name is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *IoTEdgeTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := IoTEdgeTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *IoTEdgeTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *IoTEdgeTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("IoT Edge Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P(IoT Edge Target): Init()")

        updateConfig, err := toIoTEdgeTargetProviderConfig(config)
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P(IoT Edge Target): expected IoTEdgeTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        return nil</span>
}
func (i *IoTEdgeTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("IoT Edge Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P(IoT Edge Target): getting components")

        hubTwin, err := i.getIoTEdgeModuleTwin(ctx, "$edgeHub")
        if err != nil </span><span class="cov8" title="1">{
                sLog.Error("  P(IoT Edge Target): +%v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">modules, err := i.getIoTEdgeModules(ctx)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P(IoT Edge Target): +%v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">components := make([]model.ComponentSpec, 0)
        for k, m := range modules </span><span class="cov0" title="0">{
                if k != "$edgeAgent" &amp;&amp; k != "$edgeHub" </span><span class="cov0" title="0">{
                        var twin ModuleTwin
                        twin, err = i.getIoTEdgeModuleTwin(ctx, k)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Error("  P(IoT Edge Target): +%v", err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">var component model.ComponentSpec
                        component, err = toComponent(hubTwin, twin, deployment.Instance.Name, m)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Error("  P(IoT Edge Target): +%v", err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">components = append(components, component)</span>
                }
        }

        <span class="cov0" title="0">return components, nil</span>
}

func (i *IoTEdgeTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("IoT Edge Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P(IoT Edge Target): applying components")

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()

        edgeAgent, err := i.getIoTEdgeModuleTwin(ctx, "$edgeAgent")
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P(IoT Edge Target): +%v", err)
                return ret, err
        }</span>

        <span class="cov0" title="0">edgeHub, err := i.getIoTEdgeModuleTwin(ctx, "$edgeHub")
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P(IoT Edge Target): +%v", err)
                return ret, err
        }</span>

        //updated
        <span class="cov0" title="0">modules := make(map[string]Module)
        for _, a := range components </span><span class="cov0" title="0">{
                module, e := toModule(a, deployment.Instance.Name, deployment.Instance.Metadata[ENV_NAME], step.Target)
                if e != nil </span><span class="cov0" title="0">{
                        ret[a.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.UpdateFailed,
                                Message: e.Error(),
                        }
                        err = e
                        sLog.Errorf("  P(IoT Edge Target): +%v", err)
                        return ret, err
                }</span>
                <span class="cov0" title="0">modules[a.Name] = module</span>
        }
        <span class="cov0" title="0">if len(modules) &gt; 0 </span><span class="cov0" title="0">{
                err = i.deployToIoTEdge(ctx, deployment.Instance.Name, deployment.Instance.Metadata, modules, edgeAgent, edgeHub)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P(IoT Edge Target): +%v", err)
                        return ret, err
                }</span>
        }

        //delete
        <span class="cov0" title="0">modules = make(map[string]Module)
        for _, a := range components </span><span class="cov0" title="0">{
                module, e := toModule(a, deployment.Instance.Name, deployment.Instance.Metadata[ENV_NAME], step.Target)
                if e != nil </span><span class="cov0" title="0">{
                        ret[a.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.DeleteFailed,
                                Message: e.Error(),
                        }
                        return ret, err
                }</span>
                <span class="cov0" title="0">modules[a.Name] = module</span>
        }
        <span class="cov0" title="0">if len(modules) &gt; 0 </span><span class="cov0" title="0">{
                err = i.remvoefromIoTEdge(ctx, deployment.Instance.Name, deployment.Instance.Metadata, modules, edgeAgent, edgeHub)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
        }
        //TODO: Should we raise events to remove AVA graphs?
        <span class="cov0" title="0">return ret, nil</span>
}
func (*IoTEdgeTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{model.ContainerImage, "container.version", "container.type"},
                OptionalProperties:    []string{"container.restartPolicy", "container.createOptions", "env.*"},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {Name: "container.restartPolicy", IgnoreCase: false, SkipIfMissing: true},
                        {Name: "container.createOptions", IgnoreCase: false, SkipIfMissing: true},
                        {Name: "container.version", IgnoreCase: false, SkipIfMissing: true},
                        {Name: "container.type", IgnoreCase: false, SkipIfMissing: true},
                        {Name: model.ContainerImage, IgnoreCase: false, SkipIfMissing: true},
                        {Name: "desired.*", IgnoreCase: false, SkipIfMissing: true},
                        {Name: "env.*", IgnoreCase: false, SkipIfMissing: true},
                },
        }
}</span>

func toIoTEdgeTargetProviderConfig(config providers.IProviderConfig) (IoTEdgeTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := IoTEdgeTargetProviderConfig{}
        if config == nil </span><span class="cov8" title="1">{
                return ret, errors.New("IoTEdgeTargetProviderConfig is null")
        }</span>
        <span class="cov8" title="1">data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        // ret.IoTHub = providers.LoadEnv(ret.IoTHub)
        // ret.DeviceName = providers.LoadEnv(ret.DeviceName)
        // ret.APIVersion = providers.LoadEnv(ret.APIVersion)
        // ret.KeyName = providers.LoadEnv(ret.KeyName)
        // ret.Key = providers.LoadEnv(ret.Key)

        <span class="cov8" title="1">if ret.APIVersion == "" </span><span class="cov8" title="1">{
                ret.APIVersion = "2020-05-31-preview"
        }</span>
        <span class="cov8" title="1">if ret.KeyName == "" </span><span class="cov8" title="1">{
                ret.KeyName = "iothubowner"
        }</span>
        <span class="cov8" title="1">if ret.EdgeAgentVersion == "" </span><span class="cov8" title="1">{
                ret.EdgeAgentVersion = "1.3"
        }</span>
        <span class="cov8" title="1">if ret.EdgeHubVersion == "" </span><span class="cov8" title="1">{
                ret.EdgeHubVersion = "1.3"
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func toComponent(hubTwin ModuleTwin, twin ModuleTwin, name string, module Module) (model.ComponentSpec, error) <span class="cov8" title="1">{
        moduleId, _ := reduceKey(twin.ModuleId, name)
        component := model.ComponentSpec{
                Name:       moduleId,
                Properties: make(map[string]interface{}),
                Routes:     make([]model.RouteSpec, 0),
        }
        for k, v := range module.Environments </span><span class="cov0" title="0">{
                if k != ENV_NAME &amp;&amp; k != ENV_SALT </span><span class="cov0" title="0">{
                        component.Properties["env."+k] = v.Value
                }</span>
        }

        <span class="cov8" title="1">if v, ok := hubTwin.Properties.Desired["routes"]; ok </span><span class="cov8" title="1">{
                routes := v.(map[string]interface{})
                for k, iv := range routes </span><span class="cov8" title="1">{
                        def := iv.(string)
                        if strings.Contains(def, "modules/"+twin.ModuleId+"/") </span><span class="cov8" title="1">{ //TODO: this check is not necessarily safe
                                reducedRoute, _ := reduceKey(k, name)
                                reducedDef, _ := replaceKey(def, name)
                                component.Routes = append(component.Routes, model.RouteSpec{
                                        Route: reducedRoute,
                                        Type:  "iothub",
                                        Properties: map[string]string{
                                                "definition": reducedDef,
                                        },
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">component.Properties["container.restartPolicy"] = module.RestartPolicy
        if module.Version != nil </span><span class="cov8" title="1">{
                component.Properties["container.version"] = module.Version.(string)
        }</span>
        <span class="cov8" title="1">component.Properties["container.type"] = module.Type
        if v, ok := module.Settings["createOptions"]; ok </span><span class="cov8" title="1">{
                component.Properties["container.createOptions"] = v
        }</span>
        <span class="cov8" title="1">if v, ok := module.Settings["image"]; ok </span><span class="cov8" title="1">{
                component.Properties[model.ContainerImage] = v
        }</span>
        //TODO: We are extracting only keys starting with a lower-case letter here.
        <span class="cov8" title="1">interestedKey := regexp.MustCompile(`^[a-zA-Z]+`)
        for k, v := range twin.Properties.Desired </span><span class="cov8" title="1">{ //We are reading desired instead of reported, as we leave IoT Edge state seeking to IoT Edge itself
                if interestedKey.MatchString(k) </span><span class="cov8" title="1">{
                        switch v.(type) </span>{
                        case int:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case int8:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case int16:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case int32:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case int64:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case uint:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case uint8:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case uint16:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case uint32:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case uint64:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case float32:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case float64:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("#%v", v)</span>
                        case string:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("%s", v)</span>
                        case bool:<span class="cov8" title="1">
                                component.Properties["desired."+k] = fmt.Sprintf("$%v", v)</span>
                        case []interface{}:<span class="cov8" title="1">
                                data, err := json.Marshal(v)
                                if err == nil </span><span class="cov8" title="1">{
                                        component.Properties["desired."+k] = string(data)
                                }</span> else<span class="cov0" title="0"> {
                                        component.Properties["desired."+k] = fmt.Sprintf("%v", v) //The "desired." prefix is added to match with what's generated during Apply
                                }</span>
                        default:<span class="cov0" title="0">
                                data, err := json.Marshal(v)
                                if err == nil </span><span class="cov0" title="0">{
                                        component.Properties["desired."+k] = string(data)
                                }</span> else<span class="cov0" title="0"> {
                                        component.Properties["desired."+k] = fmt.Sprintf("%v", v) //The "desired." prefix is added to match with what's generated during Apply
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return component, nil</span>
}
func readProperty(properties map[string]interface{}, key string, defaultVal string, required bool) (string, error) <span class="cov8" title="1">{
        if v, ok := properties[key]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%v", v), nil
        }</span>
        <span class="cov8" title="1">if required &amp;&amp; defaultVal == "" </span><span class="cov8" title="1">{
                return "", v1alpha2.NewCOAError(nil, fmt.Sprintf("required property '%s' is missng", key), v1alpha2.BadRequest)
        }</span>
        <span class="cov8" title="1">return defaultVal, nil</span>
}
func toModule(component model.ComponentSpec, name string, agentName string, targetName string) (Module, error) <span class="cov8" title="1">{
        policy, err := readProperty(component.Properties, "container.restartPolicy", "always", false)
        if err != nil </span><span class="cov0" title="0">{
                return Module{}, err
        }</span>
        <span class="cov8" title="1">createOptions, err := readProperty(component.Properties, "container.createOptions", "", false)
        if err != nil </span><span class="cov0" title="0">{
                return Module{}, err
        }</span>
        <span class="cov8" title="1">version, err := readProperty(component.Properties, "container.version", "", true)
        if err != nil </span><span class="cov8" title="1">{
                return Module{}, err
        }</span>
        <span class="cov8" title="1">componentType, err := readProperty(component.Properties, "container.type", "", true)
        if err != nil </span><span class="cov8" title="1">{
                return Module{}, err
        }</span>
        <span class="cov8" title="1">image, err := readProperty(component.Properties, model.ContainerImage, "", true)
        if err != nil </span><span class="cov8" title="1">{
                return Module{}, err
        }</span>
        <span class="cov8" title="1">module := Module{
                Version:       version,
                Type:          componentType,
                RestartPolicy: policy,
                Status:        "running",
                Settings: map[string]string{
                        "image":         image,
                        "createOptions": createOptions,
                },
        }
        module.DesiredProperties = make(map[string]interface{})
        module.Graph = make(map[string]interface{})
        module.GraphFlavor = "ava"
        module.IotHubRoutes = make(map[string]string)
        module.Environments = make(map[string]EnvValue)
        for k, v := range component.Properties </span><span class="cov8" title="1">{
                // TODO: Transition from map[string]string to map[string]interface{}
                // for now we would only do this for string properties
                if sv, ok := v.(string); ok </span><span class="cov8" title="1">{
                        tv := utils.ProjectValue(sv, name)
                        if strings.HasPrefix(k, "desired.") </span><span class="cov8" title="1">{
                                module.DesiredProperties[k[8:]] = tv
                                // } else if strings.HasPrefix(k, "graph.") {
                                //         if k == "graph.methodFlavor" {
                                //                 module.GraphFlavor = v
                                //         } else {
                                //                 module.Graph[k[6:]] = v
                                //         }
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(k, "env.") </span><span class="cov8" title="1">{
                                module.Environments[k[4:]] = EnvValue{Value: tv}
                        }</span>
                }
        }

        <span class="cov8" title="1">module.Environments[ENV_SALT] = EnvValue{Value: uuid.New().String()}

        if agentName != "" </span><span class="cov8" title="1">{
                module.Environments[ENV_NAME] = EnvValue{Value: fmt.Sprintf("%s-%s-%s", "target-runtime", targetName, agentName)}
        }</span>
        <span class="cov8" title="1">for _, v := range component.Routes </span><span class="cov0" title="0">{
                if v.Type == "iothub" </span><span class="cov0" title="0">{
                        module.IotHubRoutes[v.Route] = v.Properties["definition"]
                }</span>
        }

        <span class="cov8" title="1">return module, nil</span>
}
func (i *IoTEdgeTargetProvider) getIoTEdgeModuleTwin(ctx context.Context, id string) (ModuleTwin, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("https://%s/twins/%s/modules/%s?api-version=%s", i.Config.IoTHub, i.Config.DeviceName, id, i.Config.APIVersion)
        _, span := observability.StartSpan("IoT Edge REST API", ctx, &amp;map[string]string{
                "method": "getIoTEdgeModuleTwin",
                "url":    url,
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        module := ModuleTwin{}
        sasToken := azureutils.CreateSASToken(fmt.Sprintf("%s/devices/%s", i.Config.IoTHub, i.Config.DeviceName), i.Config.KeyName, i.Config.Key)
        client := &amp;http.Client{}
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("failed to get IoT Edge modules: %v", err)
                return module, v1alpha2.NewCOAError(err, "failed to get IoT Edge modules", v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", sasToken)
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("failed to get IoT Edge modules: %v", err)
                return module, v1alpha2.NewCOAError(err, "failed to get IoT Edge modules", v1alpha2.InternalError)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                sLog.Errorf("failed to get IoT Edge modules: %v", resp)
                //return module, v1alpha1.NewCOAError(nil, "failed to get IoT Edge modules", v1alpha1.InternalError) //TODO: carry over HTTP status code
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        bodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("failed to get IoT Edge modules: %v", err)
                return module, v1alpha2.NewCOAError(err, "failed to get IoT Edge modules", v1alpha2.InternalError)
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(bodyBytes, &amp;module)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("failed to get IoT Edge modules: %v", err)
                return module, v1alpha2.NewCOAError(err, "failed to get IoT Edge modules", v1alpha2.InternalError)
        }</span>
        <span class="cov0" title="0">return module, nil</span>
}
func (i *IoTEdgeTargetProvider) getIoTEdgeModules(ctx context.Context) (map[string]Module, error) <span class="cov8" title="1">{
        ret := make(map[string]Module)
        agentTwin, err := i.getIoTEdgeModuleTwin(ctx, "$edgeAgent")
        if err != nil </span><span class="cov8" title="1">{
                return ret, err
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(agentTwin.Properties.Desired["modules"])
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}

func (i *IoTEdgeTargetProvider) remvoefromIoTEdge(ctx context.Context, name string, metadata map[string]string, modules map[string]Module, agentRef ModuleTwin, hubRef ModuleTwin) error <span class="cov8" title="1">{
        deployment := makeDefaultDeployment(metadata, i.Config.EdgeAgentVersion, i.Config.EdgeHubVersion)
        err := reduceDeployment(&amp;deployment, name, modules, agentRef, hubRef)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return i.applyIoTEdgeDeployment(ctx, deployment)</span>
}

func (i *IoTEdgeTargetProvider) deployToIoTEdge(ctx context.Context, name string, metadata map[string]string, modules map[string]Module, agentRef ModuleTwin, hubRef ModuleTwin) error <span class="cov8" title="1">{

        deployment := makeDefaultDeployment(metadata, i.Config.EdgeAgentVersion, i.Config.EdgeHubVersion)

        err := updateDeployment(&amp;deployment, name, modules, agentRef, hubRef)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return i.applyIoTEdgeDeployment(ctx, deployment)</span>
}

func (i *IoTEdgeTargetProvider) applyIoTEdgeDeployment(ctx context.Context, deployment IoTEdgeDeployment) error <span class="cov8" title="1">{
        url := fmt.Sprintf("https://%s/devices/%s/applyConfigurationContent?api-version=%s", i.Config.IoTHub, i.Config.DeviceName, i.Config.APIVersion)
        _, span := observability.StartSpan("IoT Edge REST API", ctx, &amp;map[string]string{
                "method": "applyIoTEdgeDeployment",
                "url":    url,
        })

        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sasToken := azureutils.CreateSASToken(fmt.Sprintf("%s/devices/%s", i.Config.IoTHub, i.Config.DeviceName), i.Config.KeyName, i.Config.Key)
        client := &amp;http.Client{}
        payload, err := json.Marshal(deployment)
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(err, "failed to serialize IoT Edge deployemnt", v1alpha2.SerializationError)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("failed to post IoT Edge deployment: %v", err)
                return v1alpha2.NewCOAError(err, "failed to post IoT Edge deployment", v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", sasToken)
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("failed to post IoT Edge deployment: %v", err)
                return v1alpha2.NewCOAError(err, "failed to post IoT Edge deployment", v1alpha2.InternalError)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusNoContent &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                sLog.Errorf("failed to post IoT Edge deployment: %v", resp)
                return v1alpha2.NewCOAError(nil, "failed to post IoT Edge deployment", v1alpha2.InternalError) //TODO: carry over HTTP status code
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func replaceKey(key string, name string) (string, bool) <span class="cov8" title="1">{
        if name != "" &amp;&amp; strings.Contains(key, name+"-") </span><span class="cov0" title="0">{
                return strings.ReplaceAll(key, name+"-", ""), true
        }</span>
        <span class="cov8" title="1">return key, false</span>
}

func reduceKey(key string, name string) (string, bool) <span class="cov8" title="1">{
        if name != "" &amp;&amp; strings.HasPrefix(key, name+"-") </span><span class="cov8" title="1">{
                return key[len(name)+1:], true
        }</span>
        <span class="cov8" title="1">return key, false</span>
}
func expandKey(key string, name string) string <span class="cov8" title="1">{
        if name != "" </span><span class="cov8" title="1">{
                return name + "-" + key
        }</span>
        <span class="cov0" title="0">return key</span>
}

func carryOverRoutes(deployment *IoTEdgeDeployment, ref ModuleTwin) <span class="cov8" title="1">{
        if ref.ModuleId != "" </span><span class="cov8" title="1">{
                if v, ok := ref.Properties.Desired["routes"]; ok </span><span class="cov8" title="1">{
                        if vc, ok := v.(map[string]string); ok </span><span class="cov8" title="1">{
                                m := deployment.ModulesContent["$edgeHub"].DesiredProperties["routes"].(map[string]string)
                                for k, iv := range vc </span><span class="cov8" title="1">{
                                        m[k] = iv
                                }</span>
                        }
                }
        }
}

func updateDeployment(deployment *IoTEdgeDeployment, name string, modules map[string]Module, agentRef ModuleTwin, hubRef ModuleTwin) error <span class="cov8" title="1">{

        // add all other modules that are not in the current module list so that we can write them back
        otherModules := map[string]bool{}
        if agentRef.ModuleId != "" </span><span class="cov8" title="1">{
                carryOverRoutes(deployment, agentRef)
                im, ok := agentRef.Properties.Desired["modules"].(map[string]interface{})
                if ok </span><span class="cov8" title="1">{
                        for k, _ := range im </span><span class="cov8" title="1">{
                                rk, reduced := reduceKey(k, name)
                                if !reduced </span><span class="cov8" title="1">{
                                        strContent, _ := json.Marshal(im[k])
                                        mRef := Module{}
                                        err := json.Unmarshal(strContent, &amp;mRef)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">modules[rk] = mRef
                                        otherModules[rk] = true</span>
                                }
                        }
                }
        }

        // create a new module collection
        <span class="cov8" title="1">deployment.ModulesContent["$edgeAgent"].DesiredProperties["modules"] = make(map[string]Module)

        rd := deployment.ModulesContent["$edgeHub"].DesiredProperties["routes"].(map[string]string)

        if v, ok := hubRef.Properties.Desired["routes"]; ok </span><span class="cov0" title="0">{
                routes := v.(map[string]interface{})
                for ik, iv := range routes </span><span class="cov0" title="0">{
                        rd[ik] = iv.(string)
                }</span>
        }

        // add all modules, wich include modules from current deployment as well as other modules
        <span class="cov8" title="1">for k, m := range modules </span><span class="cov8" title="1">{
                d := deployment.ModulesContent["$edgeAgent"].DesiredProperties["modules"].(map[string]Module)
                ek := k
                if _, ok := otherModules[k]; !ok </span><span class="cov8" title="1">{
                        ek = expandKey(k, name)
                }</span>
                <span class="cov8" title="1">d[ek] = m
                if len(m.DesiredProperties) &gt; 0 </span><span class="cov0" title="0">{
                        deployment.ModulesContent[ek] = ModuleState{
                                DesiredProperties: map[string]interface{}{},
                        }
                        for ik, iv := range m.DesiredProperties </span><span class="cov0" title="0">{
                                deployment.ModulesContent[ek].DesiredProperties[ik] = iv
                        }</span>
                }
                <span class="cov8" title="1">if len(m.IotHubRoutes) &gt; 0 </span><span class="cov8" title="1">{
                        if _, ok := otherModules[k]; !ok </span><span class="cov8" title="1">{
                                for rk, rv := range m.IotHubRoutes </span><span class="cov8" title="1">{
                                        rek := expandKey(rk, name)
                                        mrv := modifyRoutes(rv, name, modules, otherModules)
                                        rd[rek] = mrv
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
func modifyRoutes(route string, name string, modules map[string]Module, otherModules map[string]bool) string <span class="cov8" title="1">{
        for k, _ := range modules </span><span class="cov8" title="1">{
                if _, ok := otherModules[k]; !ok </span><span class="cov8" title="1">{
                        route = strings.ReplaceAll(route, "modules/"+k, "modules/"+name+"-"+k)
                }</span>
        }
        <span class="cov8" title="1">return route</span>
}

func reduceDeployment(deployment *IoTEdgeDeployment, name string, modules map[string]Module, ref ModuleTwin, hubRef ModuleTwin) error <span class="cov8" title="1">{

        otherModules := map[string]bool{}

        rd := deployment.ModulesContent["$edgeHub"].DesiredProperties["routes"].(map[string]string)

        if v, ok := hubRef.Properties.Desired["routes"]; ok </span><span class="cov8" title="1">{
                routes := v.(map[string]interface{})
                for ik, iv := range routes </span><span class="cov8" title="1">{
                        rd[ik] = iv.(string)
                }</span>
        }

        <span class="cov8" title="1">if ref.ModuleId != "" </span><span class="cov8" title="1">{
                carryOverRoutes(deployment, ref)
                im, ok := ref.Properties.Desired["modules"].(map[string]interface{})
                if ok </span><span class="cov8" title="1">{
                        for k, _ := range im </span><span class="cov8" title="1">{
                                rk, reduced := reduceKey(k, name)
                                if !reduced </span><span class="cov8" title="1">{
                                        strContent, _ := json.Marshal(im[k])
                                        mRef := Module{}
                                        err := json.Unmarshal(strContent, &amp;mRef)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">modules[rk] = mRef
                                        otherModules[rk] = true</span>
                                } else<span class="cov8" title="1"> {
                                        if len(modules[rk].IotHubRoutes) &gt; 0 </span><span class="cov8" title="1">{
                                                for ik, _ := range modules[rk].IotHubRoutes </span><span class="cov8" title="1">{
                                                        delete(rd, expandKey(ik, name))
                                                }</span>
                                        }
                                        <span class="cov8" title="1">delete(modules, rk)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">deployment.ModulesContent["$edgeAgent"].DesiredProperties["modules"] = make(map[string]Module)
        for k, m := range modules </span><span class="cov8" title="1">{
                d := deployment.ModulesContent["$edgeAgent"].DesiredProperties["modules"].(map[string]Module)
                ek := k
                if _, ok := otherModules[k]; !ok </span><span class="cov0" title="0">{
                        ek = expandKey(k, name)
                }</span>
                <span class="cov8" title="1">d[ek] = m
                if len(m.DesiredProperties) &gt; 0 </span><span class="cov0" title="0">{
                        deployment.ModulesContent[ek] = ModuleState{
                                DesiredProperties: map[string]interface{}{},
                        }
                        for ik, iv := range m.DesiredProperties </span><span class="cov0" title="0">{
                                deployment.ModulesContent[ek].DesiredProperties[ik] = iv
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func makeDefaultDeployment(metadata map[string]string, edgeAgentVersion string, edgeHubVersion string) IoTEdgeDeployment <span class="cov8" title="1">{

        deployment := IoTEdgeDeployment{
                ModulesContent: map[string]ModuleState{
                        "$edgeAgent": {
                                DesiredProperties: map[string]interface{}{
                                        "schemaVersion": "1.0",
                                        "runtime": Runtime{
                                                Type: "docker",
                                                Settings: map[string]interface{}{
                                                        "minDockerVersion": "v1.25",
                                                        "loggingOption":    "",
                                                },
                                        },
                                        "systemModules": map[string]Module{
                                                "edgeAgent": Module{
                                                        Type: "docker",
                                                        Settings: map[string]string{
                                                                "image":         "mcr.microsoft.com/azureiotedge-agent:" + edgeAgentVersion,
                                                                "createOptions": "",
                                                        },
                                                },
                                                "edgeHub": {
                                                        Type:          "docker",
                                                        RestartPolicy: "always",
                                                        Status:        "running",
                                                        Settings: map[string]string{
                                                                "image":         "mcr.microsoft.com/azureiotedge-hub:" + edgeHubVersion,
                                                                "createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}",
                                                        },
                                                },
                                        },
                                },
                        },
                        "$edgeHub": {
                                DesiredProperties: map[string]interface{}{
                                        "schemaVersion": "1.0",
                                        "routes":        map[string]string{},
                                        "storeAndForwardConfiguration": map[string]int{ //TODO: this is also a hack
                                                "timeToLiveSecs": 7200,
                                        },
                                },
                        },
                },
        }
        if v, ok := metadata["$edgeAgent.registryCredentials"]; ok &amp;&amp; strings.HasPrefix(v, "[") &amp;&amp; strings.HasSuffix(v, "]") </span><span class="cov0" title="0">{
                credentials := make(map[string]RegistryCredential)
                data := []byte(v)
                err := json.Unmarshal(data, &amp;credentials)
                if err == nil </span><span class="cov0" title="0">{
                        (deployment.ModulesContent["$edgeAgent"].DesiredProperties["runtime"].(Runtime)).Settings["registryCredentials"] = credentials
                }</span>
        }
        <span class="cov8" title="1">return deployment</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package configmap

import (
        "context"
        "encoding/json"
        "path/filepath"
        "strconv"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        kerrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/serializer/yaml"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/discovery/cached/memory"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/restmapper"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

var (
        decUnstructured = yaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme)
        sLog            = logger.NewLogger("coa.runtime")
)

type (
        // ConfigMapTargetProviderConfig is the configuration for the kubectl target provider
        ConfigMapTargetProviderConfig struct {
                Name       string `json:"name,omitempty"`
                ConfigType string `json:"configType,omitempty"`
                ConfigData string `json:"configData,omitempty"`
                Context    string `json:"context,omitempty"`
                InCluster  bool   `json:"inCluster"`
        }

        // ConfigMapTargetProvider is the kubectl target provider
        ConfigMapTargetProvider struct {
                Config          ConfigMapTargetProviderConfig
                Context         *contexts.ManagerContext
                Client          kubernetes.Interface
                DynamicClient   dynamic.Interface
                DiscoveryClient *discovery.DiscoveryClient
                Mapper          *restmapper.DeferredDiscoveryRESTMapper
                RESTConfig      *rest.Config
        }
)

// ConfigMapTargetProviderConfigFromMap converts a map to a ConfigMapTargetProviderConfig
func ConfigMapTargetProviderConfigFromMap(properties map[string]string) (ConfigMapTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := ConfigMapTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov8" title="1">{
                ret.ConfigType = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov8" title="1">{
                ret.ConfigData = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov8" title="1">{
                ret.Context = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of kubectl provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.InCluster = bVal</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (s *ConfigMapTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

// InitWithMap initializes the configmap target provider with a map
func (i *ConfigMapTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := ConfigMapTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.Init(config)</span>
}

// Init initializes the configmap target provider
func (i *ConfigMapTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "ConfigMap Target Provider",
                context.TODO(),
                &amp;map[string]string{
                        "method": "Init",
                },
        )
        var err error = nil
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("  P (ConfigMap Target): Init()")

        updateConfig, err := toConfigMapTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (ConfigMap Target): expected ConfigMapTargetProviderConfig - %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Config = updateConfig
        var kConfig *rest.Config
        if i.Config.InCluster </span><span class="cov0" title="0">{
                kConfig, err = rest.InClusterConfig()
        }</span> else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "path":<span class="cov8" title="1">
                        if i.Config.ConfigData == "" </span><span class="cov8" title="1">{
                                if home := homedir.HomeDir(); home != "" </span><span class="cov8" title="1">{
                                        i.Config.ConfigData = filepath.Join(home, ".kube", "config")
                                }</span> else<span class="cov0" title="0"> {
                                        err = v1alpha2.NewCOAError(nil, "can't locate home direction to read default kubernetes config file, to run in cluster, set inCluster config setting to true", v1alpha2.BadConfig)
                                        sLog.Errorf("  P (ConfigMap Target): %+v", err)
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">kConfig, err = clientcmd.BuildConfigFromFlags("", i.Config.ConfigData)</span>
                case "inline":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        sLog.Errorf("  P (ConfigMap Target):  %+v", err)
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                err = v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                                sLog.Errorf("  P (ConfigMap Target): %+v", err)
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        err = v1alpha2.NewCOAError(nil, "unrecognized config type, accepted values are: path and inline", v1alpha2.BadConfig)
                        sLog.Errorf("  P (ConfigMap Target): %+v", err)
                        return err</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P (ConfigMap Target): %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Client, err = kubernetes.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (ConfigMap Target): %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.DynamicClient, err = dynamic.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (ConfigMap Target): %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (ConfigMap Target): %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Mapper = restmapper.NewDeferredDiscoveryRESTMapper(memory.NewMemCacheClient(i.DiscoveryClient))
        i.RESTConfig = kConfig
        return nil</span>
}

// toConfigMapTargetProviderConfig converts a generic IProviderConfig to a ConfigMapTargetProviderConfig
func toConfigMapTargetProviderConfig(config providers.IProviderConfig) (ConfigMapTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := ConfigMapTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

// Get gets the artifacts for a configmap
func (i *ConfigMapTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan(
                "ConfigMap Target Provider",
                ctx, &amp;map[string]string{
                        "method": "Get",
                },
        )
        var err error = nil
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (ConfigMap Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        ret := make([]model.ComponentSpec, 0)
        for _, component := range references </span><span class="cov8" title="1">{
                var obj *corev1.ConfigMap
                obj, err = i.Client.CoreV1().ConfigMaps(deployment.Instance.Scope).Get(ctx, component.Component.Name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                sLog.Infof("  P (ConfigMap Target): resource not found: %s", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">sLog.Error("  P (ConfigMap Target): failed to read object: +%v", err)
                        return nil, err</span>
                }
                <span class="cov8" title="1">component.Component.Properties = make(map[string]interface{})
                for key, value := range obj.Data </span><span class="cov8" title="1">{
                        var data interface{}
                        err = json.Unmarshal([]byte(value), &amp;data)
                        if err == nil </span><span class="cov0" title="0">{
                                component.Component.Properties[key] = data
                        }</span> else<span class="cov8" title="1"> {
                                component.Component.Properties[key] = value
                        }</span>
                }
                <span class="cov8" title="1">ret = append(ret, component.Component)</span>
        }

        <span class="cov8" title="1">return ret, nil</span>
}

// Apply applies the configmap artifacts
func (i *ConfigMapTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan(
                "ConfigMap Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Apply",
                },
        )
        var err error = nil
        defer utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (ConfigMap Target):  applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov0" title="0">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for _, component := range components </span><span class="cov8" title="1">{
                        if component.Type == "config" </span><span class="cov8" title="1">{
                                newConfigMap := &amp;corev1.ConfigMap{
                                        ObjectMeta: metav1.ObjectMeta{
                                                Name:      component.Name,
                                                Namespace: deployment.Instance.Scope,
                                        },
                                        Data: make(map[string]string),
                                }
                                for key, value := range component.Properties </span><span class="cov8" title="1">{
                                        if v, ok := value.(string); ok </span><span class="cov8" title="1">{
                                                newConfigMap.Data[key] = v
                                        }</span> else<span class="cov0" title="0"> {
                                                jData, _ := json.Marshal(value)
                                                newConfigMap.Data[key] = string(jData)
                                        }</span>
                                }
                                <span class="cov8" title="1">i.ensureNamespace(ctx, deployment.Instance.Scope)
                                err = i.applyConfigMap(ctx, newConfigMap, deployment.Instance.Scope)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Error("  P (ConfigMap Target): failed to apply configmap: +%v", err)
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                for _, component := range components </span><span class="cov0" title="0">{
                        if component.Type == "config" </span><span class="cov0" title="0">{
                                err = i.deleteConfigMap(ctx, component.Name, deployment.Instance.Scope)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Error("  P (ConfigMap Target): failed to delete configmap: +%v", err)
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

// ensureNamespace ensures that the namespace exists
func (k *ConfigMapTargetProvider) ensureNamespace(ctx context.Context, namespace string) error <span class="cov8" title="1">{
        ctx, span := observability.StartSpan(
                "ConfigMap Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "ensureNamespace",
                },
        )
        var err error = nil
        defer utils.CloseSpanWithError(span, &amp;err)

        _, err = k.Client.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if kerrors.IsNotFound(err) </span><span class="cov8" title="1">{
                _, err = k.Client.CoreV1().Namespaces().Create(ctx, &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: namespace,
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Error("  P (ConfigMap Target): failed to create namespace: +%v", err)
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                sLog.Error("  P (ConfigMap Target): failed to get namespace: +%v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetValidationRule returns validation rule for the provider
func (*ConfigMapTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {
                                Name: "*", //react to all property changes
                        },
                },
        }
}</span>

// deleteConfigMap deletes a configmap
func (i *ConfigMapTargetProvider) deleteConfigMap(ctx context.Context, name string, scope string) error <span class="cov8" title="1">{
        err := i.Client.CoreV1().ConfigMaps(scope).Delete(ctx, name, metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Error("  P (Kubectl Target): failed to delete configmap: +%v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// applyCustomResource applies a custom resource from a byte array
func (i *ConfigMapTargetProvider) applyConfigMap(ctx context.Context, config *corev1.ConfigMap, scope string) error <span class="cov8" title="1">{
        existingConfigMap, err := i.Client.CoreV1().ConfigMaps(scope).Get(ctx, config.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if kerrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        sLog.Infof("  P (ConfigMap Target): resource not found: %s", err)
                        _, err = i.Client.CoreV1().ConfigMaps(scope).Create(ctx, config, metav1.CreateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Error("  P (ConfigMap Target): failed to create configmap: +%v", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov0" title="0">sLog.Error("  P (ConfigMap Target): failed to read object: +%v", err)
                return err</span>
        }

        <span class="cov8" title="1">existingConfigMap.Data = config.Data

        _, err = i.Client.CoreV1().ConfigMaps(scope).Update(ctx, existingConfigMap, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (ConfigMap Target): failed to update configmap: +%v", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package conformance

import (
        "context"
        "testing"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/stretchr/testify/assert"
)

func RequiredPropertiesAndMetadata[P target.ITargetProvider](t *testing.T, p P) <span class="cov8" title="1">{
        desired := []model.ComponentSpec{
                {
                        Name:       "test-1",
                        Properties: map[string]interface{}{},
                        Metadata:   map[string]string{},
                },
        }

        step := model.DeploymentStep{
                Components: []model.ComponentStep{
                        {
                                Component: model.ComponentSpec{
                                        Name:       "test-1",
                                        Properties: map[string]interface{}{},
                                        Metadata:   map[string]string{},
                                },
                        },
                },
        }

        rule := p.GetValidationRule(context.Background())

        for _, property := range rule.RequiredProperties </span><span class="cov8" title="1">{
                desired[0].Properties[property] = "dummy property"
                step.Components[0].Component.Properties[property] = "dummy property"
        }</span>

        <span class="cov8" title="1">for _, metadata := range rule.RequiredMetadata </span><span class="cov0" title="0">{
                desired[0].Metadata[metadata] = "dummy metadata"
                step.Components[0].Component.Metadata[metadata] = "dummy metadata"
        }</span>

        <span class="cov8" title="1">deployment := model.DeploymentSpec{
                Solution: model.SolutionSpec{
                        Components: desired,
                },
                ComponentStartIndex: 0,
                ComponentEndIndex:   1,
        }
        _, err := p.Apply(context.Background(), deployment, step, true)
        assert.Nil(t, err)</span>
}
func AnyRequiredPropertiesMissing[P target.ITargetProvider](t *testing.T, p P) <span class="cov8" title="1">{

        desired := []model.ComponentSpec{
                {
                        Name:       "test-1",
                        Properties: map[string]interface{}{},
                        Metadata:   map[string]string{},
                },
        }

        step := model.DeploymentStep{
                Components: []model.ComponentStep{
                        {
                                Component: model.ComponentSpec{
                                        Name:       "test-1",
                                        Properties: map[string]interface{}{},
                                        Metadata:   map[string]string{},
                                },
                        },
                },
        }

        rule := p.GetValidationRule(context.Background())

        for _, metadata := range rule.RequiredMetadata </span><span class="cov0" title="0">{
                desired[0].Metadata[metadata] = "dummy metadata"
        }</span>

        <span class="cov8" title="1">for i, _ := range rule.RequiredProperties </span><span class="cov8" title="1">{
                desired[0].Properties = make(map[string]interface{}, len(rule.RequiredProperties)-1)
                slice := append(append([]string{}, rule.RequiredProperties[:i]...), rule.RequiredProperties[i+1:]...)
                for _, property := range slice </span><span class="cov8" title="1">{
                        desired[0].Properties[property] = "dummy property"
                }</span>
                <span class="cov8" title="1">deployment := model.DeploymentSpec{
                        Solution: model.SolutionSpec{
                                Components: desired,
                        },
                        ComponentStartIndex: 0,
                        ComponentEndIndex:   1,
                }
                _, err := p.Apply(context.Background(), deployment, step, true)
                assert.NotNil(t, err)
                coaErr := err.(v1alpha2.COAError)
                assert.Equal(t, v1alpha2.BadRequest, coaErr.State)</span>
        }
}
func ConformanceSuite[P target.ITargetProvider](t *testing.T, p P) <span class="cov8" title="1">{
        t.Run("Level=Basic", func(t *testing.T) </span><span class="cov8" title="1">{
                RequiredPropertiesAndMetadata(t, p)
                AnyRequiredPropertiesMissing(t, p)
        }</span>)
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package docker

import (
        "context"
        "encoding/json"
        "errors"
        "strings"

        "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/client"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type DockerTargetProviderConfig struct {
        Name string `json:"name"`
}

type DockerTargetProvider struct {
        Config  DockerTargetProviderConfig
        Context *contexts.ManagerContext
}

func DockerTargetProviderConfigFromMap(properties map[string]string) (DockerTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := DockerTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (d *DockerTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := DockerTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return d.Init(config)</span>
}
func (s *DockerTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (d *DockerTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Docker Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Docker Target): Init()")

        // convert config to DockerTargetProviderConfig type
        dockerConfig, err := toDockerTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Docker Target): expected DockerTargetProviderConfig: %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">d.Config = dockerConfig
        return nil</span>
}
func toDockerTargetProviderConfig(config providers.IProviderConfig) (DockerTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := DockerTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

func (i *DockerTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Docker Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (Docker Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        cli, err := client.NewClientWithOpts(client.FromEnv)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Docker Target): failed to create docker client: %+v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">ret := make([]model.ComponentSpec, 0)
        for _, component := range references </span><span class="cov8" title="1">{
                var info types.ContainerJSON
                info, err = cli.ContainerInspect(ctx, component.Component.Name)
                if err == nil </span><span class="cov8" title="1">{
                        name := info.Name
                        if len(name) &gt; 0 &amp;&amp; name[0] == '/' </span><span class="cov8" title="1">{
                                name = name[1:]
                        }</span>
                        <span class="cov8" title="1">component := model.ComponentSpec{
                                Name:       name,
                                Properties: make(map[string]interface{}),
                        }
                        // container.args
                        if len(info.Args) &gt; 0 </span><span class="cov0" title="0">{
                                argsData, _ := json.Marshal(info.Args)
                                component.Properties["container.args"] = string(argsData)
                        }</span>
                        // container.image
                        <span class="cov8" title="1">component.Properties[model.ContainerImage] = info.Config.Image
                        if info.HostConfig != nil </span><span class="cov8" title="1">{
                                resources, _ := json.Marshal(info.HostConfig.Resources)
                                component.Properties["container.resources"] = string(resources)
                        }</span>
                        // container.ports
                        <span class="cov8" title="1">if info.NetworkSettings != nil &amp;&amp; len(info.NetworkSettings.Ports) &gt; 0 </span><span class="cov0" title="0">{
                                ports, _ := json.Marshal(info.NetworkSettings.Ports)
                                component.Properties["container.ports"] = string(ports)
                        }</span>
                        // container.cmd
                        <span class="cov8" title="1">if len(info.Config.Cmd) &gt; 0 </span><span class="cov8" title="1">{
                                cmdData, _ := json.Marshal(info.Config.Cmd)
                                component.Properties["container.commands"] = string(cmdData)
                        }</span>
                        // container.volumeMounts
                        <span class="cov8" title="1">if len(info.Mounts) &gt; 0 </span><span class="cov0" title="0">{
                                volumeData, _ := json.Marshal(info.Mounts)
                                component.Properties["container.volumeMounts"] = string(volumeData)
                        }</span>
                        // get environment varibles that are passed in by the reference
                        <span class="cov8" title="1">env := info.Config.Env
                        if len(env) &gt; 0 </span><span class="cov8" title="1">{
                                for _, e := range env </span><span class="cov8" title="1">{
                                        pair := strings.Split(e, "=")
                                        if len(pair) == 2 </span><span class="cov8" title="1">{
                                                for _, s := range references </span><span class="cov8" title="1">{
                                                        if s.Component.Name == component.Name </span><span class="cov8" title="1">{
                                                                for k, _ := range s.Component.Properties </span><span class="cov8" title="1">{
                                                                        if k == "env."+pair[0] </span><span class="cov0" title="0">{
                                                                                component.Properties[k] = pair[1]
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                        <span class="cov8" title="1">ret = append(ret, component)</span>
                }
        }

        <span class="cov8" title="1">return ret, nil</span>
}

func (i *DockerTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Docker Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (Docker Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        injections := &amp;model.ValueInjections{
                InstanceId: deployment.Instance.Name,
                SolutionId: deployment.Instance.Solution,
                TargetId:   deployment.ActiveTarget,
        }

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()

        cli, err := client.NewClientWithOpts(client.FromEnv)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Docker Target): failed to create docker client: %+v", err)
                return ret, err
        }</span>

        <span class="cov8" title="1">for _, component := range step.Components </span><span class="cov8" title="1">{
                if component.Action == "update" </span><span class="cov8" title="1">{
                        image := model.ReadPropertyCompat(component.Component.Properties, model.ContainerImage, injections)
                        resources := model.ReadPropertyCompat(component.Component.Properties, "container.resources", injections)
                        if image == "" </span><span class="cov0" title="0">{
                                err = errors.New("component doesn't have container.image property")
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P (Helm Target): component doesn't have container.image property")
                                return ret, err
                        }</span>

                        <span class="cov8" title="1">alreadyRunning := true
                        _, err = cli.ContainerInspect(ctx, component.Component.Name)
                        if err != nil </span><span class="cov8" title="1">{ //TODO: check if the error is ErrNotFound
                                alreadyRunning = false
                        }</span>

                        // TODO: I don't think we need to do an explict image pull here, as Docker will pull the image upon cache miss
                        // reader, err := cli.ImagePull(ctx, image, types.ImagePullOptions{})
                        // if err != nil {
                        //         observ_utils.CloseSpanWithError(span, &amp;err)
                        //         sLog.Errorf("  P (Docker Target): failed to pull docker image: %+v", err)
                        //         return err
                        // }

                        // defer reader.Close()
                        // io.Copy(os.Stdout, reader)

                        <span class="cov8" title="1">if alreadyRunning </span><span class="cov8" title="1">{
                                err = cli.ContainerStop(context.TODO(), component.Component.Name, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        if !client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                                                sLog.Errorf("  P (Docker Target): failed to stop a running container: %+v", err)
                                                return ret, err
                                        }</span>
                                }
                                <span class="cov8" title="1">err = cli.ContainerRemove(context.TODO(), component.Component.Name, types.ContainerRemoveOptions{})
                                if err != nil </span><span class="cov0" title="0">{
                                        ret[component.Component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.UpdateFailed,
                                                Message: err.Error(),
                                        }
                                        sLog.Errorf("  P (Docker Target): failed to remove existing container: %+v", err)
                                        return ret, err
                                }</span>
                        }

                        // prepare environment variables
                        <span class="cov8" title="1">env := make([]string, 0)
                        for k, v := range component.Component.Properties </span><span class="cov8" title="1">{
                                if strings.HasPrefix(k, "env.") </span><span class="cov0" title="0">{
                                        env = append(env, strings.TrimPrefix(k, "env.")+"="+v.(string))
                                }</span>
                        }

                        <span class="cov8" title="1">containerConfig := container.Config{
                                Image: image,
                                Env:   env,
                        }
                        var hostConfig *container.HostConfig
                        if resources != "" </span><span class="cov0" title="0">{
                                var resourceSpec container.Resources
                                err = json.Unmarshal([]byte(resources), &amp;resourceSpec)
                                if err != nil </span><span class="cov0" title="0">{
                                        ret[component.Component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.UpdateFailed,
                                                Message: err.Error(),
                                        }
                                        sLog.Errorf("  P (Docker Target): failed to read container resource settings: %+v", err)
                                        return ret, err
                                }</span>
                                <span class="cov0" title="0">hostConfig = &amp;container.HostConfig{
                                        Resources: resourceSpec,
                                }</span>
                        }
                        <span class="cov8" title="1">var container container.ContainerCreateCreatedBody
                        container, err = cli.ContainerCreate(context.TODO(), &amp;containerConfig, hostConfig, nil, nil, component.Component.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P (Docker Target): failed to create container: %+v", err)
                                return ret, err
                        }</span>

                        <span class="cov8" title="1">if err = cli.ContainerStart(context.TODO(), container.ID, types.ContainerStartOptions{}); err != nil </span><span class="cov0" title="0">{
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P (Docker Target): failed to start container: %+v", err)
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">ret[component.Component.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.Updated,
                                Message: "",
                        }</span>
                } else<span class="cov8" title="1"> {
                        err = cli.ContainerStop(context.TODO(), component.Component.Name, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                if !client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (Docker Target): failed to stop a running container: %+v", err)
                                        return ret, err
                                }</span>
                        }
                        <span class="cov8" title="1">err = cli.ContainerRemove(context.TODO(), component.Component.Name, types.ContainerRemoveOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                if !client.IsErrNotFound(err) </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (Docker Target): failed to remove existing container: %+v", err)
                                        return ret, err
                                }</span>
                        }
                        <span class="cov8" title="1">ret[component.Component.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.Deleted,
                                Message: "",
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (*DockerTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{model.ContainerImage},
                OptionalProperties:    []string{"container.resources"},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {Name: model.ContainerImage, IgnoreCase: false, SkipIfMissing: false},
                        {Name: "container.ports", IgnoreCase: false, SkipIfMissing: true},
                        {Name: "container.resources", IgnoreCase: false, SkipIfMissing: true},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package helm

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/google/uuid"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/registry"
        "helm.sh/helm/v3/pkg/release"
        "k8s.io/cli-runtime/pkg/genericclioptions"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

var sLog = logger.NewLogger("coa.runtime")

const (
        DEFAULT_NAMESPACE = "default"
        TEMP_CHART_DIR    = "/tmp/symphony/charts"
)

type (
        // HelmTargetProviderConfig is the configuration for the Helm provider
        HelmTargetProviderConfig struct {
                Name       string `json:"name"`
                ConfigType string `json:"configType,omitempty"`
                ConfigData string `json:"configData,omitempty"`
                Context    string `json:"context,omitempty"`
                InCluster  bool   `json:"inCluster"`
        }
        // HelmTargetProvider is the Helm provider
        HelmTargetProvider struct {
                Config          HelmTargetProviderConfig
                Context         *contexts.ManagerContext
                ListClient      *action.List
                InstallClient   *action.Install
                UpgradeClient   *action.Upgrade
                UninstallClient *action.Uninstall
        }
        // HelmProperty is the property for the Helm chart
        HelmProperty struct {
                Chart  HelmChartProperty      `json:"chart"`
                Values map[string]interface{} `json:"values,omitempty"`
        }
        // HelmChartProperty is the property for the Helm Charts
        HelmChartProperty struct {
                Repo    string `json:"repo"`
                Version string `json:"version"`
                Wait    bool   `json:"wait"`
        }
)

// HelmTargetProviderConfigFromMap converts a map to a HelmTargetProviderConfig
func HelmTargetProviderConfigFromMap(properties map[string]string) (HelmTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := HelmTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>

        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov8" title="1">{
                ret.ConfigType = v
        }</span>

        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov8" title="1">{
                ret.ConfigData = v
        }</span>

        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov8" title="1">{
                ret.Context = v
        }</span>

        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of Helm provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.InCluster = bVal</span>
                }
        }

        <span class="cov8" title="1">return ret, nil</span>
}

// InitWithMap initializes the HelmTargetProvider with a map
func (i *HelmTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := HelmTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *HelmTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

// Init initializes the HelmTargetProvider
func (i *HelmTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "Helm Target Provider",
                context.TODO(),
                &amp;map[string]string{
                        "method": "Init",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("  P (Helm Target): Init()")

        err = initChartsDir()
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Helm Target): failed to init charts dir: %+v", err)
                return err
        }</span>

        // convert config to HelmTargetProviderConfig type
        <span class="cov8" title="1">var helmConfig HelmTargetProviderConfig
        helmConfig, err = toHelmTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Helm Target): expected HelmTargetProviderConfig: %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Config = helmConfig
        var actionConfig *action.Configuration
        if i.Config.InCluster </span><span class="cov8" title="1">{
                settings := cli.New()
                actionConfig = new(action.Configuration)
                // TODO: $HELM_DRIVER        set the backend storage driver. Values are: configmap, secret, memory, sql. Do we need to handle this differently?
                if err = actionConfig.Init(settings.RESTClientGetter(), settings.Namespace(), os.Getenv("HELM_DRIVER"), log.Printf); err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Helm Target): failed to init: %+v", err)
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "bytes":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                var kConfig *rest.Config
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        sLog.Errorf("  P (Helm Target): failed to init with config bytes: %+v", err)
                                        return err
                                }</span>

                                <span class="cov0" title="0">namespace := DEFAULT_NAMESPACE
                                actionConfig, err = getActionConfig(context.TODO(), namespace, kConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (Helm Target): failed to init with config bytes: %+v", err)
                                        return err
                                }</span>

                        } else<span class="cov8" title="1"> {
                                err = v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                                sLog.Errorf("  P (Helm Target): %+v", err)
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        err = v1alpha2.NewCOAError(nil, "unrecognized config type, accepted value is: bytes", v1alpha2.BadConfig)
                        sLog.Errorf("  P (Helm Target): %+v", err)
                        return err</span>
                }
        }

        <span class="cov8" title="1">i.ListClient = action.NewList(actionConfig)
        i.InstallClient = action.NewInstall(actionConfig)
        i.UninstallClient = action.NewUninstall(actionConfig)
        i.UpgradeClient = action.NewUpgrade(actionConfig)
        return nil</span>
}

// getActionConfig returns an action configuration
func getActionConfig(ctx context.Context, namespace string, config *rest.Config) (*action.Configuration, error) <span class="cov8" title="1">{
        actionConfig := new(action.Configuration)
        cliConfig := genericclioptions.NewConfigFlags(false)
        cliConfig.APIServer = &amp;config.Host
        cliConfig.BearerToken = &amp;config.BearerToken
        cliConfig.Namespace = &amp;namespace
        // Drop their rest.Config and just return inject own
        wrapper := func(*rest.Config) *rest.Config </span><span class="cov0" title="0">{
                return config
        }</span>
        <span class="cov8" title="1">cliConfig.WithWrapConfigFn(wrapper)
        if err := actionConfig.Init(cliConfig, namespace, "secret", log.Printf); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return actionConfig, nil</span>
}

// toHelmTargetProviderConfig converts a generic IProviderConfig to a HelmTargetProviderConfig
func toHelmTargetProviderConfig(config providers.IProviderConfig) (HelmTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := HelmTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

// Get returns the list of components for a given deployment
func (i *HelmTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov0" title="0">{
        _, span := observability.StartSpan(
                "Helm Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Get",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Helm Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)
        i.ListClient.Deployed = true
        var results []*release.Release
        results, err = i.ListClient.Run()
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Helm Target): failed to create Helm list client: %+v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">ret := make([]model.ComponentSpec, 0)
        for _, component := range references </span><span class="cov0" title="0">{
                for _, res := range results </span><span class="cov0" title="0">{
                        if (deployment.Instance.Scope == "" || res.Namespace == deployment.Instance.Scope) &amp;&amp; res.Name == component.Component.Name </span><span class="cov0" title="0">{
                                repo := ""
                                if strings.HasPrefix(res.Chart.Metadata.Tags, "SYM:") </span><span class="cov0" title="0">{ //we use this special metadata tag to remember the chart URL
                                        repo = res.Chart.Metadata.Tags[4:]
                                }</span>

                                <span class="cov0" title="0">ret = append(ret, model.ComponentSpec{
                                        Name: res.Name,
                                        Type: "helm.v3",
                                        Properties: map[string]interface{}{
                                                "chart": map[string]string{
                                                        "repo":    repo,
                                                        "version": res.Chart.Metadata.Version,
                                                },
                                                "values": res.Config,
                                        },
                                })</span>
                        }
                }
        }

        <span class="cov0" title="0">return ret, nil</span>
}

// GetValidationRule returns the validation rule for this provider
func (*HelmTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{"chart"},
                OptionalProperties:    []string{"values"},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {Name: "chart", IgnoreCase: false, SkipIfMissing: true}, //TODO: deep change detection on interface{}
                },
        }
}</span>

// downloadFile will download a url to a local file. It's efficient because it will
func downloadFile(url string, fileName string) error <span class="cov8" title="1">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        fileHandle, err := os.OpenFile(fileName, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fileHandle.Close()

        _, err = io.Copy(fileHandle, resp.Body)
        return err</span>
}

// Apply deploys the helm chart for a given deployment
func (i *HelmTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan(
                "Helm Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Apply",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Helm Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ret := step.PrepareResultMap()

        for _, component := range step.Components </span><span class="cov0" title="0">{
                if component.Action == "update" </span><span class="cov0" title="0">{
                        var helmProp *HelmProperty
                        helmProp, err = getHelmPropertyFromComponent(component.Component)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Helm Target): failed to get Helm properties: %+v", err)
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                return ret, err
                        }</span>

                        <span class="cov0" title="0">var fileName string
                        fileName, err = i.pullChart(&amp;helmProp.Chart)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Helm Target): failed to pull chart: %+v", err)
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                return ret, err
                        }</span>
                        <span class="cov0" title="0">defer os.Remove(fileName)

                        var chart *chart.Chart
                        chart, err = loader.Load(fileName)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("  P (Helm Target): failed to load chart: %+v", err)
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                return ret, err
                        }</span>

                        <span class="cov0" title="0">chart.Metadata.Tags = "SYM:" + helmProp.Chart.Repo //this is not used by Helm SDK, we use this to carry repo info
                        i.configureUpsertClients(component.Component.Name, &amp;helmProp.Chart, &amp;deployment)

                        if _, err = i.UpgradeClient.Run(component.Component.Name, chart, helmProp.Values); err != nil </span><span class="cov0" title="0">{
                                if _, err = i.InstallClient.Run(chart, helmProp.Values); err != nil </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (Helm Target): failed to apply: %+v", err)
                                        ret[component.Component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.UpdateFailed,
                                                Message: err.Error(),
                                        }
                                        return ret, err
                                }</span>
                        }
                        <span class="cov0" title="0">ret[component.Component.Name] = model.ComponentResultSpec{
                                Status:  v1alpha2.Updated,
                                Message: "",
                        }</span>
                } else<span class="cov0" title="0"> {
                        if component.Component.Type == "helm.v3" </span><span class="cov0" title="0">{
                                _, err = i.UninstallClient.Run(component.Component.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                                continue</span> //TODO: better way to detect this error?
                                        }
                                        <span class="cov0" title="0">ret[component.Component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.DeleteFailed,
                                                Message: err.Error(),
                                        }
                                        sLog.Errorf("  P (Helm Target): failed to uninstall Helm chart: %+v", err)
                                        return ret, err</span>
                                }
                                <span class="cov0" title="0">ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.Deleted,
                                        Message: "",
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ret, nil</span>
}

func (i *HelmTargetProvider) pullChart(chart *HelmChartProperty) (fileName string, err error) <span class="cov0" title="0">{
        fileName = fmt.Sprintf("%s/%s.tgz", TEMP_CHART_DIR, uuid.New().String())

        var pullRes *registry.PullResult
        if strings.HasSuffix(chart.Repo, ".tgz") &amp;&amp; strings.HasPrefix(chart.Repo, "http") </span><span class="cov0" title="0">{
                err = downloadFile(chart.Repo, fileName)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Helm Target): failed to download chart from repo: %+v", err)
                        return "", err
                }</span>
        } else<span class="cov0" title="0"> {
                var regClient *registry.Client
                regClient, err = registry.NewClient()
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Helm Target): failed to create registry client: %+v", err)
                        return
                }</span>

                <span class="cov0" title="0">pullRes, err = regClient.Pull(fmt.Sprintf("%s:%s", chart.Repo, chart.Version), registry.PullOptWithChart(true))
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Helm Target): failed to pull chart from repo: %+v", err)
                        return
                }</span>

                <span class="cov0" title="0">err = ioutil.WriteFile(fileName, pullRes.Chart.Data, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Helm Target): failed to save chart: %+v", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">return fileName, nil</span>
}

func (i *HelmTargetProvider) configureUpsertClients(name string, componentProps *HelmChartProperty, deployment *model.DeploymentSpec) <span class="cov0" title="0">{
        if deployment.Instance.Scope == "" </span><span class="cov0" title="0">{
                i.InstallClient.Namespace = DEFAULT_NAMESPACE
                i.UpgradeClient.Namespace = DEFAULT_NAMESPACE
        }</span> else<span class="cov0" title="0"> {
                i.InstallClient.Namespace = deployment.Instance.Scope
                i.UpgradeClient.Namespace = deployment.Instance.Scope
        }</span>

        <span class="cov0" title="0">i.InstallClient.Wait = componentProps.Wait
        i.UpgradeClient.Wait = componentProps.Wait
        i.InstallClient.CreateNamespace = true
        i.InstallClient.ReleaseName = name
        i.InstallClient.IsUpgrade = true
        i.UpgradeClient.Install = true
        i.UpgradeClient.ResetValues = true</span>
}

func getHelmPropertyFromComponent(component model.ComponentSpec) (*HelmProperty, error) <span class="cov8" title="1">{
        ret := HelmProperty{}
        data, err := json.Marshal(component.Properties)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return validateProps(&amp;ret)</span>
}

func validateProps(props *HelmProperty) (*HelmProperty, error) <span class="cov8" title="1">{
        if props.Chart.Repo == "" </span><span class="cov8" title="1">{
                return nil, errors.New("chart repo is required")
        }</span>

        <span class="cov8" title="1">return props, nil</span>
}

func initChartsDir() error <span class="cov8" title="1">{
        if _, err := os.Stat(TEMP_CHART_DIR); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.MkdirAll(TEMP_CHART_DIR, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package http

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type HttpTargetProviderConfig struct {
        Name string `json:"name"`
}

type HttpTargetProvider struct {
        Config  HttpTargetProviderConfig
        Context *contexts.ManagerContext
}

func HttpTargetProviderConfigFromMap(properties map[string]string) (HttpTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := HttpTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *HttpTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := HttpTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *HttpTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *HttpTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Http Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P(HTTP Target): Init()")

        updateConfig, err := toHttpTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P(HTTP Target): expected HttpTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        return nil</span>
}
func toHttpTargetProviderConfig(config providers.IProviderConfig) (HttpTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := HttpTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *HttpTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("Http Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P(HTTP Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        // This provider doesn't remember what it does, so it always return nil when asked
        return nil, nil
}</span>

func (i *HttpTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Http Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P(HTTP Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        injections := &amp;model.ValueInjections{
                InstanceId: deployment.Instance.Name,
                SolutionId: deployment.Instance.Solution,
                TargetId:   deployment.ActiveTarget,
        }

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()
        for _, component := range step.Components </span><span class="cov8" title="1">{
                if component.Action == "update" </span><span class="cov8" title="1">{
                        body := model.ReadPropertyCompat(component.Component.Properties, "http.body", injections)
                        url := model.ReadPropertyCompat(component.Component.Properties, "http.url", injections)
                        method := model.ReadPropertyCompat(component.Component.Properties, "http.method", injections)

                        if url == "" </span><span class="cov0" title="0">{
                                err = errors.New("component doesn't have a http.url property")
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P(HTTP Target): %v", err)
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">if method == "" </span><span class="cov0" title="0">{
                                method = "POST"
                        }</span>
                        <span class="cov8" title="1">jsonData := []byte(body)
                        var request *http.Request
                        request, err = http.NewRequest(method, url, bytes.NewBuffer(jsonData))
                        if err != nil </span><span class="cov0" title="0">{
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P(HTTP Target): %v", err)
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">request.Header.Set("Content-Type", "application/json; charset=UTF-8")

                        client := &amp;http.Client{}
                        var resp *http.Response
                        resp, err = client.Do(request)
                        if err != nil </span><span class="cov8" title="1">{
                                ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: err.Error(),
                                }
                                sLog.Errorf("  P(HTTP Target): %v", err)
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                                bodyBytes, err := io.ReadAll(resp.Body)
                                var message string
                                if err != nil </span><span class="cov0" title="0">{
                                        message = err.Error()
                                }</span> else<span class="cov8" title="1"> {
                                        message = string(bodyBytes)
                                }</span>
                                <span class="cov8" title="1">ret[component.Component.Name] = model.ComponentResultSpec{
                                        Status:  v1alpha2.UpdateFailed,
                                        Message: message,
                                }
                                err = errors.New("HTTP request didn't respond 200 OK")
                                sLog.Errorf("  P(HTTP Target): %v", err)
                                return ret, err</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (*HttpTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{"http.url"},
                OptionalProperties:    []string{"http.method", "http.body"},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package ingress

import (
        "context"
        "encoding/json"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        kerrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/serializer/yaml"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/discovery/cached/memory"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/restmapper"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

var (
        decUnstructured = yaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme)
        sLog            = logger.NewLogger("coa.runtime")
)

type (
        // IngressTargetProviderConfig is the configuration for the ingress target provider
        IngressTargetProviderConfig struct {
                Name       string `json:"name,omitempty"`
                ConfigType string `json:"configType,omitempty"`
                ConfigData string `json:"configData,omitempty"`
                Context    string `json:"context,omitempty"`
                InCluster  bool   `json:"inCluster"`
        }

        // IngressTargetProvider is the kubectl target provider
        IngressTargetProvider struct {
                Config          IngressTargetProviderConfig
                Context         *contexts.ManagerContext
                Client          kubernetes.Interface
                DynamicClient   dynamic.Interface
                DiscoveryClient *discovery.DiscoveryClient
                Mapper          *restmapper.DeferredDiscoveryRESTMapper
                RESTConfig      *rest.Config
        }
)

// IngressTargetProviderConfigFromMap converts a map to a IngressTargetProviderConfig
func IngressTargetProviderConfigFromMap(properties map[string]string) (IngressTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := IngressTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov8" title="1">{
                ret.ConfigType = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov8" title="1">{
                ret.ConfigData = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov8" title="1">{
                ret.Context = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of ingress provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.InCluster = bVal</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func (s *IngressTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

// InitWithMap initializes the ingress target provider with a map
func (i *IngressTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := IngressTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.Init(config)</span>
}

// Init initializes the ingress target provider
func (i *IngressTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "ConfigMap Target Provider",
                context.TODO(),
                &amp;map[string]string{
                        "method": "Init",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("  P (ConfigMap Target): Init()")

        updateConfig, err := toIngressTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (ConfigMap Target): expected IngressTargetProviderConfig - %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Config = updateConfig
        var kConfig *rest.Config
        if i.Config.InCluster </span><span class="cov0" title="0">{
                kConfig, err = rest.InClusterConfig()
        }</span> else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "path":<span class="cov8" title="1">
                        if i.Config.ConfigData == "" </span><span class="cov0" title="0">{
                                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                                        i.Config.ConfigData = filepath.Join(home, ".kube", "config")
                                }</span> else<span class="cov0" title="0"> {
                                        err = v1alpha2.NewCOAError(nil, "can't locate home direction to read default kubernetes config file, to run in cluster, set inCluster config setting to true", v1alpha2.BadConfig)
                                        sLog.Errorf("  P (Ingress Target): %+v", err)
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">kConfig, err = clientcmd.BuildConfigFromFlags("", i.Config.ConfigData)</span>
                case "inline":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        sLog.Errorf("  P (Ingress Target):  %+v", err)
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err = v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                                sLog.Errorf("  P (Ingress Target): %+v", err)
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        err = v1alpha2.NewCOAError(nil, "unrecognized config type, accepted values are: path and inline", v1alpha2.BadConfig)
                        sLog.Errorf("  P (Ingress Target): %+v", err)
                        return err</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P (Ingress Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.Client, err = kubernetes.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Ingress Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.DynamicClient, err = dynamic.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Ingress Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Ingress Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.Mapper = restmapper.NewDeferredDiscoveryRESTMapper(memory.NewMemCacheClient(i.DiscoveryClient))
        i.RESTConfig = kConfig
        return nil</span>
}

// toIngressTargetProviderConfig converts a generic IProviderConfig to a IngressTargetProviderConfig
func toIngressTargetProviderConfig(config providers.IProviderConfig) (IngressTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := IngressTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

// Get gets the artifacts for a ingress
func (i *IngressTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan(
                "Ingress Target Provider",
                ctx, &amp;map[string]string{
                        "method": "Get",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Ingress Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        ret := make([]model.ComponentSpec, 0)
        for _, component := range references </span><span class="cov0" title="0">{
                var obj *networkingv1.Ingress
                obj, err = i.Client.NetworkingV1().Ingresses(deployment.Instance.Scope).Get(ctx, component.Component.Name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                sLog.Infof("  P (Ingress Target): resource not found: %s", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">sLog.Error("  P (Ingress Target): failed to read object: +%v", err)
                        return nil, err</span>
                }
                <span class="cov0" title="0">component.Component.Properties = make(map[string]interface{})

                component.Component.Properties["rules"] = obj.Spec.Rules
                ret = append(ret, component.Component)</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

// Apply applies the ingress artifacts
func (i *IngressTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan(
                "Ingress Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Apply",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Ingress Target):  applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isDryRun </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                for _, component := range components </span><span class="cov0" title="0">{
                        if component.Type == "ingress" </span><span class="cov0" title="0">{
                                newIngress := &amp;networkingv1.Ingress{
                                        ObjectMeta: metav1.ObjectMeta{
                                                Name:      component.Name,
                                                Namespace: deployment.Instance.Scope,
                                        },
                                        Spec: networkingv1.IngressSpec{
                                                Rules: make([]networkingv1.IngressRule, 0),
                                        },
                                }
                                if v, ok := component.Properties["rules"]; ok </span><span class="cov0" title="0">{
                                        jData, _ := json.Marshal(v)
                                        var rules []networkingv1.IngressRule
                                        err = json.Unmarshal(jData, &amp;rules)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sLog.Error("  P (Ingress Target): failed to unmarshal ingress: +%v", err)
                                                return ret, err
                                        }</span>
                                        <span class="cov0" title="0">newIngress.Spec.Rules = rules</span>
                                }

                                <span class="cov0" title="0">if v, ok := component.Properties["ingressClassName"]; ok </span><span class="cov0" title="0">{
                                        s, ok := v.(string)
                                        if ok </span><span class="cov0" title="0">{
                                                newIngress.Spec.IngressClassName = &amp;s
                                        }</span> else<span class="cov0" title="0"> {
                                                sLog.Error("  P (Ingress Target): failed to convert ingress class name: +%v", v)
                                                return ret, err
                                        }</span>
                                }

                                <span class="cov0" title="0">for k, v := range component.Metadata </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(k, "annotations.") </span><span class="cov0" title="0">{
                                                if newIngress.ObjectMeta.Annotations == nil </span><span class="cov0" title="0">{
                                                        newIngress.ObjectMeta.Annotations = make(map[string]string)
                                                }</span>
                                                <span class="cov0" title="0">newIngress.ObjectMeta.Annotations[k[12:]] = v</span>
                                        }
                                }

                                <span class="cov0" title="0">i.ensureNamespace(ctx, deployment.Instance.Scope)
                                err = i.applyIngress(ctx, newIngress, deployment.Instance.Scope)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Error("  P (Ingress Target): failed to apply ingress: +%v", err)
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                for _, component := range components </span><span class="cov0" title="0">{
                        if component.Type == "ingress" </span><span class="cov0" title="0">{
                                err = i.deleteIngress(ctx, component.Name, deployment.Instance.Scope)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Error("  P (Ingress Target): failed to delete ingress: +%v", err)
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ret, nil</span>
}

// ensureNamespace ensures that the namespace exists
func (k *IngressTargetProvider) ensureNamespace(ctx context.Context, namespace string) error <span class="cov0" title="0">{
        _, span := observability.StartSpan(
                "ConfigMap Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "ensureNamespace",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)

        _, err = k.Client.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                _, err = k.Client.CoreV1().Namespaces().Create(ctx, &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: namespace,
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Error("  P (ConfigMap Target): failed to create namespace: +%v", err)
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                sLog.Error("  P (ConfigMap Target): failed to get namespace: +%v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetValidationRule returns validation rule for the provider
func (*IngressTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov0" title="0">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {
                                Name: "*", //react to all property changes
                        },
                },
                ChangeDetectionMetadata: []model.PropertyDesc{
                        {
                                Name: "annotations.*", //react to all annotation changes
                        },
                },
        }
}</span>

// deleteConfigMap deletes a configmap
func (i *IngressTargetProvider) deleteIngress(ctx context.Context, name string, scope string) error <span class="cov0" title="0">{
        err := i.Client.NetworkingV1().Ingresses(scope).Delete(ctx, name, metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Error("  P (Ingress Target): failed to delete ingress: +%v", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// applyCustomResource applies a custom resource from a byte array
func (i *IngressTargetProvider) applyIngress(ctx context.Context, ingress *networkingv1.Ingress, scope string) error <span class="cov0" title="0">{
        existingIngress, err := i.Client.NetworkingV1().Ingresses(scope).Get(ctx, ingress.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Infof("  P (Ingress Target): resource not found: %s", err)
                        _, err = i.Client.NetworkingV1().Ingresses(scope).Create(ctx, ingress, metav1.CreateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Error("  P (Ingress Target): failed to create ingress: +%v", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">sLog.Error("  P (Ingress Target): failed to read object: +%v", err)
                return err</span>
        }

        <span class="cov0" title="0">existingIngress.Spec.Rules = ingress.Spec.Rules
        if ingress.ObjectMeta.Annotations != nil </span><span class="cov0" title="0">{
                existingIngress.ObjectMeta.Annotations = ingress.ObjectMeta.Annotations
        }</span>
        <span class="cov0" title="0">_, err = i.Client.NetworkingV1().Ingresses(scope).Update(ctx, existingIngress, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Ingress Target): failed to update ingress: +%v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package k8s

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/target/k8s/projectors"
        utils "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "go.opentelemetry.io/otel/trace"
        v1 "k8s.io/api/apps/v1"
        apiv1 "k8s.io/api/core/v1"
        k8s_errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

var log = logger.NewLogger("coa.runtime")

const (
        ENV_NAME     string = "SYMPHONY_AGENT_ADDRESS"
        SINGLE_POD   string = "single-pod"
        SERVICES     string = "services"
        SERVICES_NS  string = "ns-services"
        SERVICES_HNS string = "hns-services" //TODO: future versions
)

type K8sTargetProviderConfig struct {
        Name                 string `json:"name"`
        ConfigType           string `json:"configType,omitempty"`
        ConfigData           string `json:"configData,omitempty"`
        Context              string `json:"context,omitempty"`
        InCluster            bool   `json:"inCluster"`
        Projector            string `json:"projector,omitempty"`
        DeploymentStrategy   string `json:"deploymentStrategy,omitempty"`
        DeleteEmptyNamespace bool   `json:"deleteEmptyNamespace"`
        RetryCount           int    `json:"retryCount"`
        RetryIntervalInSec   int    `json:"retryIntervalInSec"`
}

type K8sTargetProvider struct {
        Config        K8sTargetProviderConfig
        Context       *contexts.ManagerContext
        Client        kubernetes.Interface
        DynamicClient dynamic.Interface
}

func K8sTargetProviderConfigFromMap(properties map[string]string) (K8sTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := K8sTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov8" title="1">{
                ret.ConfigType = v
        }</span>
        <span class="cov8" title="1">if ret.ConfigType == "" </span><span class="cov8" title="1">{
                ret.ConfigType = "path"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov0" title="0">{
                ret.ConfigData = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov0" title="0">{
                ret.Context = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of K8s reference provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.InCluster = bVal</span>
                }
        }
        <span class="cov8" title="1">if v, ok := properties["deploymentStrategy"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                if v != SERVICES &amp;&amp; v != SINGLE_POD &amp;&amp; v != SERVICES_NS </span><span class="cov0" title="0">{
                        return ret, v1alpha2.NewCOAError(nil, fmt.Sprintf("invalid deployment strategy. Expected: %s (default), %s or %s", SINGLE_POD, SERVICES, SERVICES_NS), v1alpha2.BadConfig)
                }</span>
                <span class="cov8" title="1">ret.DeploymentStrategy = v</span>
        } else<span class="cov8" title="1"> {
                ret.DeploymentStrategy = SINGLE_POD
        }</span>
        <span class="cov8" title="1">if v, ok := properties["deleteEmptyNamespace"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'deleteEmptyNamespace' setting of K8s reference provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.DeleteEmptyNamespace = bVal</span>
                }
        }
        <span class="cov8" title="1">if v, ok := properties["retryCount"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                ival, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, v1alpha2.NewCOAError(err, "invalid int value in the 'retryCount' setting of K8s reference provider", v1alpha2.BadConfig)
                }</span>
                <span class="cov8" title="1">ret.RetryCount = ival</span>
        } else<span class="cov8" title="1"> {
                ret.RetryCount = 3
        }</span>
        <span class="cov8" title="1">if v, ok := properties["retryIntervalInSec"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                ival, err := strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, v1alpha2.NewCOAError(err, "invalid int value in the 'retryInterval' setting of K8s reference provider", v1alpha2.BadConfig)
                }</span>
                <span class="cov8" title="1">ret.RetryIntervalInSec = ival</span>
        } else<span class="cov8" title="1"> {
                ret.RetryIntervalInSec = 2
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *K8sTargetProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := K8sTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}
func (s *K8sTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *K8sTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        updateConfig, err := toK8sTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("expected K8sTargetProviderConfig")
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        var kConfig *rest.Config
        if i.Config.InCluster </span><span class="cov0" title="0">{
                kConfig, err = rest.InClusterConfig()
        }</span> else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "path":<span class="cov8" title="1">
                        if i.Config.ConfigData == "" </span><span class="cov0" title="0">{
                                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                                        i.Config.ConfigData = filepath.Join(home, ".kube", "config")
                                }</span> else<span class="cov0" title="0"> {
                                        return v1alpha2.NewCOAError(nil, "can't locate home direction to read default kubernetes config file, to run in cluster, set inCluster config setting to true", v1alpha2.BadConfig)
                                }</span>
                        }
                        <span class="cov8" title="1">kConfig, err = clientcmd.BuildConfigFromFlags("", i.Config.ConfigData)</span>
                case "bytes":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                        }</span>
                default:<span class="cov8" title="1">
                        return v1alpha2.NewCOAError(nil, "unrecognized config type, accepted values are: path and bytes", v1alpha2.BadConfig)</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">i.Client, err = kubernetes.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">i.DynamicClient, err = dynamic.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func toK8sTargetProviderConfig(config providers.IProviderConfig) (K8sTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := K8sTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        //ret.Name = providers.LoadEnv(ret.Name)
        //ret.ConfigPath = providers.LoadEnv(ret.ConfigPath)
        return ret, err</span>
}

func (i *K8sTargetProvider) getDeployment(ctx context.Context, scope string, name string) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        deployment, err := i.Client.AppsV1().Deployments(scope).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if k8s_errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">components, err := deploymentToComponents(*deployment)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("  P (K8s Target Provider): getDeployment failed - %s", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">return components, nil</span>
}
func (i *K8sTargetProvider) fillServiceMeta(ctx context.Context, scope string, name string, component model.ComponentSpec) error <span class="cov8" title="1">{
        svc, err := i.Client.CoreV1().Services(scope).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if k8s_errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if component.Metadata == nil </span><span class="cov8" title="1">{
                component.Metadata = make(map[string]string)
        }</span>
        <span class="cov8" title="1">portData, _ := json.Marshal(svc.Spec.Ports)
        component.Metadata["service.ports"] = string(portData)
        component.Metadata["service.type"] = string(svc.Spec.Type)
        if svc.ObjectMeta.Name != name </span><span class="cov0" title="0">{
                component.Metadata["service.name"] = svc.ObjectMeta.Name
        }</span>
        <span class="cov8" title="1">if component.Metadata["service.type"] == "LoadBalancer" </span><span class="cov0" title="0">{
                component.Metadata["service.loadBalancerIP"] = svc.Spec.LoadBalancerIP
        }</span>
        <span class="cov8" title="1">for k, v := range svc.ObjectMeta.Annotations </span><span class="cov8" title="1">{
                component.Metadata["service.annotation."+k] = v
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) Get(ctx context.Context, dep model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("K8s Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        log.Infof("  P (K8s Target Provider): getting artifacts: %s - %s", dep.Instance.Scope, dep.Instance.Name)

        var components []model.ComponentSpec

        switch i.Config.DeploymentStrategy </span>{
        case "", SINGLE_POD:<span class="cov8" title="1">
                components, err = i.getDeployment(ctx, dep.Instance.Scope, dep.Instance.Name)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("  P (K8s Target Provider): failed to get - %s", err.Error())
                        return nil, err
                }</span>
        case SERVICES, SERVICES_NS:<span class="cov8" title="1">
                components = make([]model.ComponentSpec, 0)
                scope := dep.Instance.Scope
                if i.Config.DeploymentStrategy == SERVICES_NS </span><span class="cov0" title="0">{
                        scope = dep.Instance.Name
                }</span>
                <span class="cov8" title="1">slice := dep.GetComponentSlice()
                for _, component := range slice </span><span class="cov8" title="1">{
                        var cComponents []model.ComponentSpec
                        cComponents, err = i.getDeployment(ctx, scope, component.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("  P (K8s Target Provider) - failed to get: %s", err.Error())
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if len(cComponents) &gt; 1 </span><span class="cov0" title="0">{
                                err = v1alpha2.NewCOAError(nil, fmt.Sprintf("can't read multiple components when %s strategy or %s strategy is used", SERVICES, SERVICES_NS), v1alpha2.InternalError)
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if len(cComponents) == 1 </span><span class="cov8" title="1">{
                                serviceName := cComponents[0].Name

                                if cComponents[0].Metadata != nil </span><span class="cov0" title="0">{
                                        if v, ok := cComponents[0].Metadata["service.name"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                                                serviceName = v
                                        }</span>
                                }
                                <span class="cov8" title="1">if cComponents[0].Metadata == nil </span><span class="cov8" title="1">{
                                        cComponents[0].Metadata = make(map[string]string)
                                }</span>

                                <span class="cov8" title="1">err = i.fillServiceMeta(ctx, scope, serviceName, cComponents[0])
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debugf("failed to get: %s", err.Error())
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">components = append(components, cComponents...)</span>
                        }
                }
        }

        <span class="cov8" title="1">return components, nil</span>
}
func (i *K8sTargetProvider) removeService(ctx context.Context, scope string, serviceName string) error <span class="cov8" title="1">{
        svc, err := i.Client.CoreV1().Services(scope).Get(ctx, serviceName, metav1.GetOptions{})
        if err == nil &amp;&amp; svc != nil </span><span class="cov0" title="0">{
                foregroundDeletion := metav1.DeletePropagationForeground
                err = i.Client.CoreV1().Services(scope).Delete(ctx, serviceName, metav1.DeleteOptions{PropagationPolicy: &amp;foregroundDeletion})
                if err != nil </span><span class="cov0" title="0">{
                        if !k8s_errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) removeDeployment(ctx context.Context, scope string, name string) error <span class="cov8" title="1">{
        foregroundDeletion := metav1.DeletePropagationForeground
        err := i.Client.AppsV1().Deployments(scope).Delete(ctx, name, metav1.DeleteOptions{PropagationPolicy: &amp;foregroundDeletion})
        if err != nil </span><span class="cov0" title="0">{
                if !k8s_errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) removeNamespace(ctx context.Context, scope string, retryCount int, retryIntervalInSec int) error <span class="cov8" title="1">{
        _, err := i.Client.CoreV1().Namespaces().Get(ctx, scope, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">resourceCount := make(map[string]int)
        count := 0
        for </span><span class="cov8" title="1">{
                count++
                podList, _ := i.Client.CoreV1().Pods(scope).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if len(podList.Items) == 0 || count == retryCount </span><span class="cov8" title="1">{
                        resourceCount["pod"] = len(podList.Items)
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * time.Duration(retryIntervalInSec))</span>
        }

        <span class="cov8" title="1">deploymentList, err := i.Client.AppsV1().Deployments(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["deployment"] = len(deploymentList.Items)

        serviceList, err := i.Client.CoreV1().Services(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["service"] = len(serviceList.Items)

        replicasetList, err := i.Client.AppsV1().ReplicaSets(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["replicaset"] = len(replicasetList.Items)

        statefulsetList, err := i.Client.AppsV1().StatefulSets(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["statefulset"] = len(statefulsetList.Items)

        daemonsetList, err := i.Client.AppsV1().DaemonSets(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["daemonset"] = len(daemonsetList.Items)

        jobList, err := i.Client.BatchV1().Jobs(scope).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resourceCount["job"] = len(jobList.Items)

        isEmpty := true
        for resource, count := range resourceCount </span><span class="cov8" title="1">{
                if count != 0 </span><span class="cov0" title="0">{
                        log.Debugf("  P (K8s Target Provider): failed to delete %s namespace as resource %s is not empty", scope, resource)
                        isEmpty = false
                        break</span>
                }
        }

        <span class="cov8" title="1">if isEmpty </span><span class="cov8" title="1">{
                err = i.Client.CoreV1().Namespaces().Delete(ctx, scope, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) createNamespace(ctx context.Context, scope string) error <span class="cov8" title="1">{
        _, err := i.Client.CoreV1().Namespaces().Get(ctx, scope, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if k8s_errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        _, err = i.Client.CoreV1().Namespaces().Create(ctx, &amp;apiv1.Namespace{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name: scope,
                                },
                        }, metav1.CreateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) upsertDeployment(ctx context.Context, scope string, name string, deployment *v1.Deployment) error <span class="cov8" title="1">{
        existing, err := i.Client.AppsV1().Deployments(scope).Get(ctx, name, metav1.GetOptions{})
        if err != nil &amp;&amp; !k8s_errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if k8s_errors.IsNotFound(err) </span><span class="cov8" title="1">{
                _, err = i.Client.AppsV1().Deployments(scope).Create(ctx, deployment, metav1.CreateOptions{})
        }</span> else<span class="cov0" title="0"> {
                deployment.ResourceVersion = existing.ResourceVersion
                _, err = i.Client.AppsV1().Deployments(scope).Update(ctx, deployment, metav1.UpdateOptions{})
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) upsertService(ctx context.Context, scope string, name string, service *apiv1.Service) error <span class="cov8" title="1">{
        existing, err := i.Client.CoreV1().Services(scope).Get(ctx, name, metav1.GetOptions{})
        if err != nil &amp;&amp; !k8s_errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if k8s_errors.IsNotFound(err) </span><span class="cov8" title="1">{
                _, err = i.Client.CoreV1().Services(scope).Create(ctx, service, metav1.CreateOptions{})
        }</span> else<span class="cov0" title="0"> {
                service.ResourceVersion = existing.ResourceVersion
                _, err = i.Client.CoreV1().Services(scope).Update(ctx, service, metav1.UpdateOptions{})
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (i *K8sTargetProvider) deployComponents(ctx context.Context, span trace.Span, scope string, name string, metadata map[string]string, components []model.ComponentSpec, projector IK8sProjector, instanceName string) error <span class="cov8" title="1">{
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        deployment, err := componentsToDeployment(scope, name, metadata, components, instanceName)
        if projector != nil </span><span class="cov8" title="1">{
                err = projector.ProjectDeployment(scope, name, metadata, components, deployment)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("  P (K8s Target Provider): failed to project deployment: %s", err.Error())
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Debugf("  P (K8s Target Provider): failed to apply: %s", err.Error())
                return err
        }</span>
        <span class="cov8" title="1">service, err := metadataToService(scope, name, metadata)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("  P (K8s Target Provider): failed to apply (convert): %s", err.Error())
                return err
        }</span>
        <span class="cov8" title="1">if projector != nil </span><span class="cov8" title="1">{
                err = projector.ProjectService(scope, name, metadata, service)
                if err != nil </span><span class="cov8" title="1">{
                        log.Debugf("  P (K8s Target Provider): failed to project service: %s", err.Error())
                        return err
                }</span>
        }

        <span class="cov8" title="1">log.Debug("  P (K8s Target Provider): checking namespace")
        err = i.createNamespace(ctx, scope)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("failed to create namespace: %s", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">log.Debug("  P (K8s Target Provider): creating deployment")
        err = i.upsertDeployment(ctx, scope, name, deployment)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("  P (K8s Target Provider): failed to apply (API): %s", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if service != nil </span><span class="cov8" title="1">{
                log.Debug("  P (K8s Target Provider): creating service")
                err = i.upsertService(ctx, scope, service.Name, service)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("  P (K8s Target Provider): failed to apply (service): %s", err.Error())
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func (*K8sTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{model.ContainerImage},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {Name: model.ContainerImage, IgnoreCase: true, SkipIfMissing: false},
                        {Name: "env.*", IgnoreCase: true, SkipIfMissing: true},
                },
        }
}</span>
func (i *K8sTargetProvider) Apply(ctx context.Context, dep model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("K8s Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Infof("  P (K8s Target Provider): applying artifacts: %s - %s", dep.Instance.Scope, dep.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()

        projector, err := createProjector(i.Config.Projector)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("  P (K8s Target Provider): failed to create projector: %s", err.Error())
                return ret, err
        }</span>

        <span class="cov8" title="1">switch i.Config.DeploymentStrategy </span>{
        case "", SINGLE_POD:<span class="cov8" title="1">
                updated := step.GetUpdatedComponents()
                if len(updated) &gt; 0 </span><span class="cov8" title="1">{
                        err = i.deployComponents(ctx, span, dep.Instance.Scope, dep.Instance.Name, dep.Instance.Metadata, components, projector, dep.Instance.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("  P (K8s Target Provider): failed to apply components: %s", err.Error())
                                return ret, err
                        }</span>
                }
                <span class="cov8" title="1">deleted := step.GetDeletedComponents()
                if len(deleted) &gt; 0 </span><span class="cov8" title="1">{
                        serviceName := dep.Instance.Name
                        if v, ok := dep.Instance.Metadata["service.name"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                                serviceName = v
                        }</span>
                        <span class="cov8" title="1">err = i.removeService(ctx, dep.Instance.Scope, serviceName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("failed to remove service: %s", err.Error())
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">err = i.removeDeployment(ctx, dep.Instance.Scope, dep.Instance.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("failed to remove deployment: %s", err.Error())
                                return ret, err
                        }</span>
                        <span class="cov8" title="1">if i.Config.DeleteEmptyNamespace </span><span class="cov8" title="1">{
                                err = i.removeNamespace(ctx, dep.Instance.Scope, i.Config.RetryCount, i.Config.RetryIntervalInSec)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debugf("failed to remove namespace: %s", err.Error())
                                }</span>
                        }
                }
        case SERVICES, SERVICES_NS:<span class="cov8" title="1">
                updated := step.GetUpdatedComponents()
                if len(updated) &gt; 0 </span><span class="cov8" title="1">{
                        scope := dep.Instance.Scope
                        if i.Config.DeploymentStrategy == SERVICES_NS </span><span class="cov0" title="0">{
                                scope = dep.Instance.Name
                        }</span>
                        <span class="cov8" title="1">for _, component := range components </span><span class="cov8" title="1">{
                                if dep.Instance.Metadata != nil </span><span class="cov0" title="0">{
                                        if v, ok := dep.Instance.Metadata[ENV_NAME]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                                                if component.Metadata == nil </span><span class="cov0" title="0">{
                                                        component.Metadata = make(map[string]string)
                                                }</span>
                                                <span class="cov0" title="0">component.Metadata[ENV_NAME] = v</span>
                                        }
                                }
                                <span class="cov8" title="1">err = i.deployComponents(ctx, span, scope, component.Name, component.Metadata, []model.ComponentSpec{component}, projector, dep.Instance.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Debugf("  P (K8s Target Provider): failed to apply components: %s", err.Error())
                                        return ret, err
                                }</span>
                        }
                }
                <span class="cov8" title="1">deleted := step.GetDeletedComponents()
                if len(deleted) &gt; 0 </span><span class="cov8" title="1">{
                        scope := dep.Instance.Scope
                        if i.Config.DeploymentStrategy == SERVICES_NS </span><span class="cov0" title="0">{
                                scope = dep.Instance.Name
                        }</span>
                        <span class="cov8" title="1">for _, component := range deleted </span><span class="cov8" title="1">{
                                serviceName := component.Name
                                if component.Metadata != nil </span><span class="cov8" title="1">{
                                        if v, ok := component.Metadata["service.name"]; ok </span><span class="cov0" title="0">{
                                                serviceName = v
                                        }</span>
                                }
                                <span class="cov8" title="1">err = i.removeService(ctx, scope, serviceName)
                                if err != nil </span><span class="cov0" title="0">{
                                        ret[component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.DeleteFailed,
                                                Message: err.Error(),
                                        }
                                        log.Debugf("failed to remove service: %s", err.Error())
                                        return ret, err
                                }</span>
                                <span class="cov8" title="1">err = i.removeDeployment(ctx, scope, component.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        ret[component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.DeleteFailed,
                                                Message: err.Error(),
                                        }
                                        log.Debugf("failed to remove deployment: %s", err.Error())
                                        return ret, err
                                }</span>
                                <span class="cov8" title="1">if i.Config.DeleteEmptyNamespace </span><span class="cov8" title="1">{
                                        err = i.removeNamespace(ctx, dep.Instance.Scope, i.Config.RetryCount, i.Config.RetryIntervalInSec)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Debugf("failed to remove namespace: %s", err.Error())
                                        }</span>
                                }
                        }

                }
        }
        <span class="cov8" title="1">err = nil
        return ret, nil</span>
}
func deploymentToComponents(deployment v1.Deployment) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        components := make([]model.ComponentSpec, len(deployment.Spec.Template.Spec.Containers))
        for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                component := model.ComponentSpec{
                        Name:       c.Name,
                        Properties: make(map[string]interface{}),
                }
                component.Properties[model.ContainerImage] = c.Image
                policy := string(c.ImagePullPolicy)
                if policy != "" </span><span class="cov8" title="1">{
                        component.Properties["container.imagePullPolicy"] = policy
                }</span>
                <span class="cov8" title="1">if len(c.Ports) &gt; 0 </span><span class="cov8" title="1">{
                        ports, _ := json.Marshal(c.Ports)
                        component.Properties["container.ports"] = string(ports)
                }</span>
                <span class="cov8" title="1">if len(c.Args) &gt; 0 </span><span class="cov8" title="1">{
                        args, _ := json.Marshal(c.Args)
                        component.Properties["container.args"] = string(args)
                }</span>
                <span class="cov8" title="1">if len(c.Command) &gt; 0 </span><span class="cov0" title="0">{
                        commands, _ := json.Marshal(c.Command)
                        component.Properties["container.commands"] = string(commands)
                }</span>
                <span class="cov8" title="1">resources, _ := json.Marshal(c.Resources)
                if string(resources) != "{}" </span><span class="cov8" title="1">{
                        component.Properties["container.resources"] = string(resources)
                }</span>
                <span class="cov8" title="1">if len(c.VolumeMounts) &gt; 0 </span><span class="cov8" title="1">{
                        volumeMounts, _ := json.Marshal(c.VolumeMounts)
                        component.Properties["container.volumeMounts"] = string(volumeMounts)
                }</span>
                <span class="cov8" title="1">if len(c.Env) &gt; 0 </span><span class="cov0" title="0">{
                        for _, e := range c.Env </span><span class="cov0" title="0">{
                                component.Properties["env."+e.Name] = e.Value
                        }</span>
                }
                <span class="cov8" title="1">components[i] = component</span>
        }
        <span class="cov8" title="1">return components, nil</span>
}
func metadataToService(scope string, name string, metadata map[string]string) (*apiv1.Service, error) <span class="cov8" title="1">{
        if len(metadata) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">servicePorts := make([]apiv1.ServicePort, 0)

        if v, ok := metadata["service.ports"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                log.Debugf("  P (K8s Target Provider): metadataToService - service ports: %s", v)
                e := json.Unmarshal([]byte(v), &amp;servicePorts)
                if e != nil </span><span class="cov0" title="0">{
                        log.Errorf("  P (K8s Target Provider): metadataToService - unmarshal: %v", e)
                        return nil, e
                }</span>
        } else<span class="cov8" title="1"> {
                return nil, nil
        }</span>

        <span class="cov8" title="1">serviceName := utils.ReadString(metadata, "service.name", name)
        serviceType := utils.ReadString(metadata, "service.type", "ClusterIP")

        service := apiv1.Service{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      serviceName,
                        Namespace: scope,
                        Labels: map[string]string{
                                "app": name,
                        },
                },
                Spec: apiv1.ServiceSpec{
                        Type:  apiv1.ServiceType(serviceType),
                        Ports: servicePorts,
                        Selector: map[string]string{
                                "app": name,
                        },
                },
        }
        if _, ok := metadata["service.loadBalancerIP"]; ok </span><span class="cov8" title="1">{
                service.Spec.LoadBalancerIP = utils.ReadString(metadata, "service.loadBalancerIP", "")
        }</span>
        <span class="cov8" title="1">annotations := utils.CollectStringMap(metadata, "service.annotation.")
        if len(annotations) &gt; 0 </span><span class="cov8" title="1">{
                service.ObjectMeta.Annotations = make(map[string]string)
                for k, v := range annotations </span><span class="cov8" title="1">{
                        service.ObjectMeta.Annotations[k[19:]] = v
                }</span>
        }
        <span class="cov8" title="1">return &amp;service, nil</span>
}
func int32Ptr(i int32) *int32 <span class="cov8" title="1">{ return &amp;i }</span>
func componentsToDeployment(scope string, name string, metadata map[string]string, components []model.ComponentSpec, instanceName string) (*v1.Deployment, error) <span class="cov8" title="1">{
        deployment := v1.Deployment{
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: v1.DeploymentSpec{
                        Replicas: int32Ptr(utils.ReadInt32(metadata, "deployment.replicas", 1)),
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": name,
                                },
                        },
                        Template: apiv1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "app": name,
                                        },
                                },
                                Spec: apiv1.PodSpec{
                                        Containers: []apiv1.Container{},
                                },
                        },
                },
        }

        for _, c := range components </span><span class="cov8" title="1">{
                ports := make([]apiv1.ContainerPort, 0)
                if v, ok := c.Properties["container.ports"].(string); ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        e := json.Unmarshal([]byte(v), &amp;ports)
                        if e != nil </span><span class="cov0" title="0">{
                                return nil, e
                        }</span>
                }
                <span class="cov8" title="1">container := apiv1.Container{
                        Name:            c.Name,
                        Image:           c.Properties[model.ContainerImage].(string),
                        Ports:           ports,
                        ImagePullPolicy: apiv1.PullPolicy(utils.ReadStringFromMapCompat(c.Properties, "container.imagePullPolicy", "Always")),
                }
                if v, ok := c.Properties["container.args"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        args := make([]string, 0)
                        e := json.Unmarshal([]byte(fmt.Sprintf("%v", v)), &amp;args)
                        if e != nil </span><span class="cov0" title="0">{
                                return nil, e
                        }</span>
                        <span class="cov8" title="1">container.Args = args</span>
                }
                <span class="cov8" title="1">if v, ok := c.Properties["container.commands"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                        cmds := make([]string, 0)
                        e := json.Unmarshal([]byte(fmt.Sprintf("%v", v)), &amp;cmds)
                        if e != nil </span><span class="cov0" title="0">{
                                return nil, e
                        }</span>
                        <span class="cov0" title="0">container.Command = cmds</span>
                }
                <span class="cov8" title="1">if v, ok := c.Properties["container.resources"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        res := apiv1.ResourceRequirements{}
                        e := json.Unmarshal([]byte(fmt.Sprintf("%v", v)), &amp;res)
                        if e != nil </span><span class="cov0" title="0">{
                                return nil, e
                        }</span>
                        <span class="cov8" title="1">container.Resources = res</span>
                }
                <span class="cov8" title="1">if v, ok := c.Properties["container.volumeMounts"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        mounts := make([]apiv1.VolumeMount, 0)
                        e := json.Unmarshal([]byte(fmt.Sprintf("%v", v)), &amp;mounts)
                        if e != nil </span><span class="cov0" title="0">{
                                return nil, e
                        }</span>
                        <span class="cov8" title="1">container.VolumeMounts = mounts</span>
                }
                <span class="cov8" title="1">for k, v := range c.Properties </span><span class="cov8" title="1">{
                        // Transitioning from map[string]string to map[string]interface{}
                        // for now we'll assume that all relevant values are strings till we
                        // refactor the code to handle the new format
                        sv := fmt.Sprintf("%v", v)
                        if strings.HasPrefix(k, "env.") </span><span class="cov0" title="0">{
                                if container.Env == nil </span><span class="cov0" title="0">{
                                        container.Env = make([]apiv1.EnvVar, 0)
                                }</span>
                                <span class="cov0" title="0">container.Env = append(container.Env, apiv1.EnvVar{
                                        Name:  k[4:],
                                        Value: sv,
                                })</span>
                        }
                }
                <span class="cov8" title="1">agentName := metadata[ENV_NAME]
                if agentName != "" </span><span class="cov0" title="0">{
                        if container.Env == nil </span><span class="cov0" title="0">{
                                container.Env = make([]apiv1.EnvVar, 0)
                        }</span>
                        <span class="cov0" title="0">container.Env = append(container.Env, apiv1.EnvVar{
                                Name:  ENV_NAME,
                                Value: agentName + ".default.svc.cluster.local", //agent is currently always installed under deault
                        })</span>
                }
                <span class="cov8" title="1">deployment.Spec.Template.Spec.Containers = append(deployment.Spec.Template.Spec.Containers, container)</span>
        }
        <span class="cov8" title="1">if v, ok := metadata["deployment.imagePullSecrets"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                secrets := make([]apiv1.LocalObjectReference, 0)
                e := json.Unmarshal([]byte(v), &amp;secrets)
                if e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">deployment.Spec.Template.Spec.ImagePullSecrets = secrets</span>
        }
        <span class="cov8" title="1">if v, ok := metadata["pod.volumes"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                volumes := make([]apiv1.Volume, 0)
                e := json.Unmarshal([]byte(v), &amp;volumes)
                if e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov0" title="0">deployment.Spec.Template.Spec.Volumes = volumes</span>
        }
        <span class="cov8" title="1">if v, ok := metadata["deployment.nodeSelector"]; ok &amp;&amp; v != "" </span><span class="cov0" title="0">{
                selector := make(map[string]string)
                e := json.Unmarshal([]byte(v), &amp;selector)
                if e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov0" title="0">deployment.Spec.Template.Spec.NodeSelector = selector</span>
        }

        <span class="cov8" title="1">data, _ := json.Marshal(deployment)
        log.Debug(string(data))

        return &amp;deployment, nil</span>
}

func createProjector(projector string) (IK8sProjector, error) <span class="cov8" title="1">{
        switch projector </span>{
        case "noop":<span class="cov8" title="1">
                return &amp;projectors.NoOpProjector{}, nil</span>
        case "":<span class="cov8" title="1">
                return nil, nil</span>
        }
        <span class="cov8" title="1">return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("project type '%s' is unsupported", projector), v1alpha2.BadConfig)</span>
}

type IK8sProjector interface {
        ProjectDeployment(scope string, name string, metadata map[string]string, components []model.ComponentSpec, deployment *v1.Deployment) error
        ProjectService(scope string, name string, metadata map[string]string, service *apiv1.Service) error
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package projectors

import (
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        v1 "k8s.io/api/apps/v1"
        apiv1 "k8s.io/api/core/v1"
)

type NoOpProjector struct {
}

func (p *NoOpProjector) ProjectDeployment(scope string, name string, metadata map[string]string, components []model.ComponentSpec, deployment *v1.Deployment) error <span class="cov8" title="1">{
        return nil
}</span>
func (p *NoOpProjector) ProjectService(scope string, name string, metadata map[string]string, service *apiv1.Service) error <span class="cov8" title="1">{
        if name == "error" </span><span class="cov8" title="1">{
                return v1alpha2.NewCOAError(nil, "throw error project service", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package kubectl

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "path/filepath"
        "strconv"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        kerrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/serializer/yaml"
        utilyaml "k8s.io/apimachinery/pkg/util/yaml"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/discovery/cached/memory"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/restmapper"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"
)

var (
        decUnstructured = yaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme)
        sLog            = logger.NewLogger("coa.runtime")
)

type (
        // KubectlTargetProviderConfig is the configuration for the kubectl target provider
        KubectlTargetProviderConfig struct {
                Name       string `json:"name,omitempty"`
                ConfigType string `json:"configType,omitempty"`
                ConfigData string `json:"configData,omitempty"`
                Context    string `json:"context,omitempty"`
                InCluster  bool   `json:"inCluster"`
        }

        // KubectlTargetProvider is the kubectl target provider
        KubectlTargetProvider struct {
                Config          KubectlTargetProviderConfig
                Context         *contexts.ManagerContext
                Client          kubernetes.Interface
                DynamicClient   dynamic.Interface
                DiscoveryClient *discovery.DiscoveryClient
                Mapper          *restmapper.DeferredDiscoveryRESTMapper
                RESTConfig      *rest.Config
        }
)

// KubectlTargetProviderConfigFromMap converts a map to a KubectlTargetProviderConfig
func KubectlTargetProviderConfigFromMap(properties map[string]string) (KubectlTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := KubectlTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configType"]; ok </span><span class="cov8" title="1">{
                ret.ConfigType = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["configData"]; ok </span><span class="cov8" title="1">{
                ret.ConfigData = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["context"]; ok </span><span class="cov8" title="1">{
                ret.Context = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["inCluster"]; ok </span><span class="cov8" title="1">{
                val := v
                if val != "" </span><span class="cov8" title="1">{
                        bVal, err := strconv.ParseBool(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return ret, v1alpha2.NewCOAError(err, "invalid bool value in the 'inCluster' setting of kubectl provider", v1alpha2.BadConfig)
                        }</span>
                        <span class="cov8" title="1">ret.InCluster = bVal</span>
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}

// InitWithMap initializes the kubectl target provider with a map
func (i *KubectlTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := KubectlTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *KubectlTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

// Init initializes the kubectl target provider
func (i *KubectlTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "Kubectl Target Provider",
                context.TODO(),
                &amp;map[string]string{
                        "method": "Init",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("  P (Kubectl Target): Init()")

        updateConfig, err := toKubectlTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Kubectl Target): expected KubectlTargetProviderConfig - %+v", err)
                return err
        }</span>

        <span class="cov8" title="1">i.Config = updateConfig
        var kConfig *rest.Config
        if i.Config.InCluster </span><span class="cov0" title="0">{
                kConfig, err = rest.InClusterConfig()
        }</span> else<span class="cov8" title="1"> {
                switch i.Config.ConfigType </span>{
                case "path":<span class="cov8" title="1">
                        if i.Config.ConfigData == "" </span><span class="cov0" title="0">{
                                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                                        i.Config.ConfigData = filepath.Join(home, ".kube", "config")
                                }</span> else<span class="cov0" title="0"> {
                                        err = v1alpha2.NewCOAError(nil, "can't locate home direction to read default kubernetes config file, to run in cluster, set inCluster config setting to true", v1alpha2.BadConfig)
                                        sLog.Errorf("  P (Kubectl Target): %+v", err)
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">kConfig, err = clientcmd.BuildConfigFromFlags("", i.Config.ConfigData)</span>
                case "inline":<span class="cov8" title="1">
                        if i.Config.ConfigData != "" </span><span class="cov8" title="1">{
                                kConfig, err = clientcmd.RESTConfigFromKubeConfig([]byte(i.Config.ConfigData))
                                if err != nil </span><span class="cov8" title="1">{
                                        sLog.Errorf("  P (Kubectl Target):  %+v", err)
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                err = v1alpha2.NewCOAError(nil, "config data is not supplied", v1alpha2.BadConfig)
                                sLog.Errorf("  P (Kubectl Target): %+v", err)
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        err = v1alpha2.NewCOAError(nil, "unrecognized config type, accepted values are: path and inline", v1alpha2.BadConfig)
                        sLog.Errorf("  P (Kubectl Target): %+v", err)
                        return err</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P (Kubectl Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.Client, err = kubernetes.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Kubectl Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.DynamicClient, err = dynamic.NewForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Kubectl Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(kConfig)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Kubectl Target): %+v", err)
                return err
        }</span>

        <span class="cov0" title="0">i.Mapper = restmapper.NewDeferredDiscoveryRESTMapper(memory.NewMemCacheClient(i.DiscoveryClient))
        i.RESTConfig = kConfig
        return nil</span>
}

// toKubectlTargetProviderConfig converts a generic IProviderConfig to a KubectlTargetProviderConfig
func toKubectlTargetProviderConfig(config providers.IProviderConfig) (KubectlTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := KubectlTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

// Get gets the artifacts for a deployment
func (i *KubectlTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan(
                "Kubectl Target Provider",
                ctx, &amp;map[string]string{
                        "method": "Get",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Kubectl Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        ret := make([]model.ComponentSpec, 0)
        for _, component := range references </span><span class="cov0" title="0">{
                if v, ok := component.Component.Properties["yaml"].(string); ok </span><span class="cov0" title="0">{
                        chanMes, chanErr := readYaml(v)
                        stop := false
                        for !stop </span><span class="cov0" title="0">{
                                select </span>{
                                case dataBytes, ok := &lt;-chanMes:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                err = errors.New("failed to receive from data channel")
                                                sLog.Error("  P (Kubectl Target): +%v", err)
                                                return nil, err
                                        }</span>

                                        <span class="cov0" title="0">_, err = i.getCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                                        if err != nil </span><span class="cov0" title="0">{
                                                if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                        sLog.Infof("  P (Kubectl Target): resource not found: %s", err)
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">sLog.Error("  P (Kubectl Target): failed to read object: +%v", err)
                                                return nil, err</span>
                                        }

                                        <span class="cov0" title="0">ret = append(ret, component.Component)
                                        stop = true</span> //we do early stop as soon as we found the first resource. we may want to support different strategy in the future

                                case err, ok := &lt;-chanErr:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                err = errors.New("failed to receive from error channel")
                                                sLog.Error("  P (Kubectl Target): +%v", err)
                                                return nil, err
                                        }</span>

                                        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                                                stop = true
                                        }</span> else<span class="cov0" title="0"> {
                                                sLog.Error("  P (Kubectl Target): failed to apply Yaml: +%v", err)
                                                return nil, err
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> if component.Component.Properties["resource"] != nil </span><span class="cov0" title="0">{
                        var dataBytes []byte
                        dataBytes, err = json.Marshal(component.Component.Properties["resource"])
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Error("  P (Kubectl Target): failed to get deployment bytes from component: +%v", err)
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">_, err = i.getCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                        if err != nil </span><span class="cov0" title="0">{
                                if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        sLog.Infof("  P (Kubectl Target): resource not found: %s", err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">sLog.Error("  P (Kubectl Target): failed to read object: +%v", err)
                                return nil, err</span>
                        }

                        <span class="cov0" title="0">ret = append(ret, component.Component)</span>

                } else<span class="cov0" title="0"> {
                        err = errors.New("component doesn't have yaml or resource property")
                        sLog.Error("  P (Kubectl Target): component doesn't have yaml or resource property")
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return ret, nil</span>
}

// Apply applies the deployment artifacts
func (i *KubectlTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov0" title="0">{
        ctx, span := observability.StartSpan(
                "Kubectl Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Apply",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Kubectl Target):  applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isDryRun </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                for _, component := range components </span><span class="cov0" title="0">{
                        if component.Type == "yaml.k8s" </span><span class="cov0" title="0">{
                                if v, ok := component.Properties["yaml"].(string); ok </span><span class="cov0" title="0">{
                                        chanMes, chanErr := readYaml(v)
                                        stop := false
                                        for !stop </span><span class="cov0" title="0">{
                                                select </span>{
                                                case dataBytes, ok := &lt;-chanMes:<span class="cov0" title="0">
                                                        if !ok </span><span class="cov0" title="0">{
                                                                err = errors.New("failed to receive from data channel")
                                                                sLog.Error("  P (Kubectl Target):  +%v", err)
                                                                return ret, err
                                                        }</span>

                                                        <span class="cov0" title="0">i.ensureNamespace(ctx, deployment.Instance.Scope)
                                                        err = i.applyCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                sLog.Error("  P (Kubectl Target):  failed to apply Yaml: +%v", err)
                                                                return ret, err
                                                        }</span>

                                                case err, ok := &lt;-chanErr:<span class="cov0" title="0">
                                                        if !ok </span><span class="cov0" title="0">{
                                                                err = errors.New("failed to receive from error channel")
                                                                sLog.Error("  P (Kubectl Target):  +%v", err)
                                                                return ret, err
                                                        }</span>

                                                        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                                                                stop = true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                sLog.Error("  P (Kubectl Target):  failed to apply Yaml: +%v", err)
                                                                return ret, err
                                                        }</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> if component.Properties["resource"] != nil </span><span class="cov0" title="0">{
                                        var dataBytes []byte
                                        dataBytes, err = json.Marshal(component.Properties["resource"])
                                        if err != nil </span><span class="cov0" title="0">{
                                                sLog.Error("  P (Kubectl Target): failed to convert resource data to bytes: +%v", err)
                                                return ret, err
                                        }</span>

                                        <span class="cov0" title="0">i.ensureNamespace(ctx, deployment.Instance.Scope)
                                        err = i.applyCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sLog.Error("  P (Kubectl Target):  failed to apply custom resource: +%v", err)
                                                return ret, err
                                        }</span>

                                } else<span class="cov0" title="0"> {
                                        err = errors.New("component doesn't have yaml property or resource property")
                                        sLog.Error("  P (Kubectl Target):  component doesn't have yaml property or resource property")
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                for _, component := range components </span><span class="cov0" title="0">{
                        if component.Type == "yaml.k8s" </span><span class="cov0" title="0">{
                                if v, ok := component.Properties["yaml"].(string); ok </span><span class="cov0" title="0">{
                                        chanMes, chanErr := readYaml(v)
                                        stop := false
                                        for !stop </span><span class="cov0" title="0">{
                                                select </span>{
                                                case dataBytes, ok := &lt;-chanMes:<span class="cov0" title="0">
                                                        if !ok </span><span class="cov0" title="0">{
                                                                err = errors.New("failed to receive from data channel")
                                                                sLog.Error("  P (Kubectl Target):  +%v", err)
                                                                return ret, err
                                                        }</span>

                                                        <span class="cov0" title="0">err = i.deleteCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                sLog.Error("  P (Kubectl Target): failed to read object: +%v", err)
                                                                return ret, err
                                                        }</span>

                                                case err, ok := &lt;-chanErr:<span class="cov0" title="0">
                                                        if !ok </span><span class="cov0" title="0">{
                                                                err = errors.New("failed to receive from error channel")
                                                                sLog.Error("  P (Kubectl Target): +%v", err)
                                                                return ret, err
                                                        }</span>

                                                        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                                                                stop = true
                                                        }</span> else<span class="cov0" title="0"> {
                                                                sLog.Error("  P (Kubectl Target): failed to remove resource: +%v", err)
                                                                return ret, err
                                                        }</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> if component.Properties["resource"] != nil </span><span class="cov0" title="0">{
                                        var dataBytes []byte
                                        dataBytes, err = json.Marshal(component.Properties["resource"])
                                        if err != nil </span><span class="cov0" title="0">{
                                                sLog.Error("  P (Kubectl Target): failed to convert resource data to bytes: +%v", err)
                                                return ret, err
                                        }</span>

                                        <span class="cov0" title="0">err = i.deleteCustomResource(ctx, dataBytes, deployment.Instance.Scope)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sLog.Error("  P (Kubectl Target): failed to delete custom resource: +%v", err)
                                                return ret, err
                                        }</span>

                                } else<span class="cov0" title="0"> {
                                        err = errors.New("component doesn't have yaml property or resource property")
                                        sLog.Error("  P (Kubectl Target): component doesn't have yaml property or resource property")
                                        return ret, err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ret, nil</span>
}

// ensureNamespace ensures that the namespace exists
func (k *KubectlTargetProvider) ensureNamespace(ctx context.Context, namespace string) error <span class="cov0" title="0">{
        _, span := observability.StartSpan(
                "Kubectl Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "ensureNamespace",
                },
        )
        var err error
        defer utils.CloseSpanWithError(span, &amp;err)

        _, err = k.Client.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                _, err = k.Client.CoreV1().Namespaces().Create(ctx, &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: namespace,
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Error("~~~ Kubectl Target Provider ~~~ : failed to create namespace: +%v", err)
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                sLog.Error("~~~ Kubectl Target Provider ~~~ : failed to get namespace: +%v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetValidationRule returns validation rule for the provider
func (*KubectlTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov0" title="0">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{"yaml", "resource"},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {
                                Name: "*", //react to all property changes
                        },
                },
        }
}</span>

// ReadYaml reads yaml from url
func readYaml(yaml string) (&lt;-chan []byte, &lt;-chan error) <span class="cov0" title="0">{
        var (
                chanErr   = make(chan error)
                chanBytes = make(chan []byte)
        )
        go func() </span><span class="cov0" title="0">{
                response, err := http.Get(yaml)
                if err != nil </span><span class="cov0" title="0">{
                        chanErr &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">defer response.Body.Close()

                data, err := io.ReadAll(response.Body)
                if err != nil </span><span class="cov0" title="0">{
                        chanErr &lt;- err
                        return
                }</span>

                <span class="cov0" title="0">multidocReader := utilyaml.NewYAMLReader(bufio.NewReader(bytes.NewReader(data)))
                for </span><span class="cov0" title="0">{
                        buf, err := multidocReader.Read()
                        if err != nil </span><span class="cov0" title="0">{
                                chanErr &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">chanBytes &lt;- buf</span>
                }

        }()
        <span class="cov0" title="0">return chanBytes, chanErr</span>
}

// BuildDynamicResourceClient builds a new dynamic client
func (i KubectlTargetProvider) buildDynamicResourceClient(data []byte, scope string) (obj *unstructured.Unstructured, dr dynamic.ResourceInterface, err error) <span class="cov0" title="0">{
        // Decode YAML manifest into unstructured.Unstructured
        obj = &amp;unstructured.Unstructured{}
        _, gvk, err := decUnstructured.Decode(data, nil, obj)
        if err != nil </span><span class="cov0" title="0">{
                return obj, dr, err
        }</span>

        // Find GVR
        <span class="cov0" title="0">mapping, err := i.Mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
        if err != nil </span><span class="cov0" title="0">{
                return obj, dr, err
        }</span>

        <span class="cov0" title="0">i.DynamicClient, err = dynamic.NewForConfig(i.RESTConfig)
        if err != nil </span><span class="cov0" title="0">{
                return obj, dr, err
        }</span>

        // Obtain REST interface for the GVR
        <span class="cov0" title="0">if mapping.Scope.Name() == meta.RESTScopeNameNamespace </span><span class="cov0" title="0">{
                // namespaced resources should specify the namespace
                obj.SetNamespace(scope)
                dr = i.DynamicClient.Resource(mapping.Resource).Namespace(scope)
        }</span> else<span class="cov0" title="0"> {
                // for cluster-wide resources
                dr = i.DynamicClient.Resource(mapping.Resource)
        }</span>

        <span class="cov0" title="0">return obj, dr, nil</span>
}

// getCustomResource gets a custom resource from a byte array
func (i *KubectlTargetProvider) getCustomResource(ctx context.Context, dataBytes []byte, scope string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        obj, dr, err := i.buildDynamicResourceClient(dataBytes, scope)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Kubectl Target): failed to build a new dynamic client: +%v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">obj, err = dr.Get(ctx, obj.GetName(), metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Kubectl Target): failed to read object: +%v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return obj, nil</span>
}

// deleteCustomResource deletes a custom resource from a byte array
func (i *KubectlTargetProvider) deleteCustomResource(ctx context.Context, dataBytes []byte, scope string) error <span class="cov0" title="0">{
        obj, dr, err := i.buildDynamicResourceClient(dataBytes, scope)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Kubectl Target): failed to build a new dynamic client: +%v", err)
                return err
        }</span>

        <span class="cov0" title="0">err = dr.Delete(ctx, obj.GetName(), metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Error("  P (Kubectl Target): failed to delete Yaml: +%v", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// applyCustomResource applies a custom resource from a byte array
func (i *KubectlTargetProvider) applyCustomResource(ctx context.Context, dataBytes []byte, scope string) error <span class="cov0" title="0">{
        obj, dr, err := i.buildDynamicResourceClient(dataBytes, scope)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Kubectl Target): failed to build a new dynamic client: +%v", err)
                return err
        }</span>

        // Check if the object exists
        <span class="cov0" title="0">existing, err := dr.Get(ctx, obj.GetName(), metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Error("  P (Kubectl Target): failed to read object: +%v", err)
                        return err
                }</span>
                // Create the object
                <span class="cov0" title="0">_, err = dr.Create(ctx, obj, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Error("  P (Kubectl Target): failed to create Yaml: +%v", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Update the object
        <span class="cov0" title="0">obj.SetResourceVersion(existing.GetResourceVersion())
        _, err = dr.Update(ctx, obj, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sLog.Error("  P (Kubectl Target): failed to apply Yaml: +%v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package mock

import (
        "context"
        "encoding/json"
        "sync"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
)

type MockTargetProviderConfig struct {
        ID string `json:"id"`
}
type MockTargetProvider struct {
        Config  MockTargetProviderConfig
        Context *contexts.ManagerContext
}

var cache map[string][]model.ComponentSpec
var mLock sync.Mutex

func (m *MockTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "Mock Target Provider",
                context.TODO(),
                &amp;map[string]string{
                        "method": "Init",
                },
        )
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        mLock.Lock()
        defer mLock.Unlock()

        mockConfig, err := toMockTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.Config = mockConfig
        if cache == nil </span><span class="cov8" title="1">{
                cache = make(map[string][]model.ComponentSpec)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (s *MockTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func toMockTargetProviderConfig(config providers.IProviderConfig) (MockTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := MockTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *MockTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := MockTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}
func MockTargetProviderConfigFromMap(properties map[string]string) (MockTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := MockTargetProviderConfig{}
        ret.ID = properties["id"]
        return ret, nil
}</span>
func (m *MockTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        mLock.Lock()
        defer mLock.Unlock()

        _, span := observability.StartSpan(
                "Mock Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Get",
                },
        )
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        ret := make([]model.ComponentSpec, 0)
        for _, c := range cache[m.Config.ID] </span><span class="cov0" title="0">{
                for _, r := range references </span><span class="cov0" title="0">{
                        if c.Name == r.Component.Name </span><span class="cov0" title="0">{
                                ret = append(ret, c)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (m *MockTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan(
                "Mock Target Provider",
                ctx,
                &amp;map[string]string{
                        "method": "Apply",
                },
        )
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        mLock.Lock()
        defer mLock.Unlock()
        if cache[m.Config.ID] == nil </span><span class="cov8" title="1">{
                cache[m.Config.ID] = make([]model.ComponentSpec, 0)
        }</span>
        <span class="cov8" title="1">for _, c := range step.Components </span><span class="cov8" title="1">{
                found := false
                for i, _ := range cache[m.Config.ID] </span><span class="cov8" title="1">{
                        if cache[m.Config.ID][i].Name == c.Component.Name </span><span class="cov8" title="1">{
                                found = true
                                if c.Action == "delete" </span><span class="cov8" title="1">{
                                        cache[m.Config.ID] = append(cache[m.Config.ID][:i], cache[m.Config.ID][i+1:]...)
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        cache[m.Config.ID] = append(cache[m.Config.ID], c.Component)
                }</span>
        }
        <span class="cov8" title="1">ret := make(map[string]model.ComponentResultSpec)
        for _, c := range cache[m.Config.ID] </span><span class="cov8" title="1">{
                ret[c.Name] = model.ComponentResultSpec{
                        Status:  v1alpha2.OK,
                        Message: "",
                }
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (m *MockTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov0" title="0">{
        return model.ValidationRule{}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package mqtt

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "sync"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        gmqtt "github.com/eclipse/paho.mqtt.golang"
        "github.com/google/uuid"
)

var sLog = logger.NewLogger("coa.runtime")

type MQTTTargetProviderConfig struct {
        Name               string `json:"name"`
        BrokerAddress      string `json:"brokerAddress"`
        ClientID           string `json:"clientID"`
        RequestTopic       string `json:"requestTopic"`
        ResponseTopic      string `json:"responseTopic"`
        TimeoutSeconds     int    `json:"timeoutSeconds,omitempty"`
        KeepAliveSeconds   int    `json:"keepAliveSeconds,omitempty"`
        PingTimeoutSeconds int    `json:"pingTimeoutSeconds,omitempty"`
}

var lock sync.Mutex

type ProxyResponse struct {
        IsOK    bool
        State   v1alpha2.State
        Payload interface{}
}
type MQTTTargetProvider struct {
        Config          MQTTTargetProviderConfig
        Context         *contexts.ManagerContext
        MQTTClient      gmqtt.Client
        GetChan         chan ProxyResponse
        RemoveChan      chan ProxyResponse
        NeedsUpdateChan chan ProxyResponse
        NeedsRemoveChan chan ProxyResponse
        ApplyChan       chan ProxyResponse
        Initialized     bool
}

func MQTTTargetProviderConfigFromMap(properties map[string]string) (MQTTTargetProviderConfig, error) <span class="cov0" title="0">{
        ret := MQTTTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov0" title="0">{
                ret.Name = v
        }</span>
        <span class="cov0" title="0">if v, ok := properties["brokerAddress"]; ok </span><span class="cov0" title="0">{
                ret.BrokerAddress = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "'brokerAdress' is missing in MQTT provider config", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["clientID"]; ok </span><span class="cov0" title="0">{
                ret.ClientID = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "'clientID' is missing in MQTT provider config", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["requestTopic"]; ok </span><span class="cov0" title="0">{
                ret.RequestTopic = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "'requestTopic' is missing in MQTT provider config", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["responseTopic"]; ok </span><span class="cov0" title="0">{
                ret.ResponseTopic = v
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "'responseTopic' is missing in MQTT provider config", v1alpha2.BadConfig)
        }</span>
        <span class="cov0" title="0">if v, ok := properties["timeoutSeconds"]; ok </span><span class="cov0" title="0">{
                if num, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                        ret.TimeoutSeconds = num
                }</span> else<span class="cov0" title="0"> {
                        return ret, v1alpha2.NewCOAError(nil, "'timeoutSeconds' is not an integer in MQTT provider config", v1alpha2.BadConfig)
                }</span>
        } else<span class="cov0" title="0"> {
                ret.TimeoutSeconds = 8
        }</span>
        <span class="cov0" title="0">if v, ok := properties["keepAliveSeconds"]; ok </span><span class="cov0" title="0">{
                if num, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                        ret.KeepAliveSeconds = num
                }</span> else<span class="cov0" title="0"> {
                        return ret, v1alpha2.NewCOAError(nil, "'keepAliveSeconds' is not an integer in MQTT provider config", v1alpha2.BadConfig)
                }</span>
        } else<span class="cov0" title="0"> {
                ret.KeepAliveSeconds = 2
        }</span>
        <span class="cov0" title="0">if v, ok := properties["pingTimeoutSeconds"]; ok </span><span class="cov0" title="0">{
                if num, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                        ret.PingTimeoutSeconds = num
                }</span> else<span class="cov0" title="0"> {
                        return ret, v1alpha2.NewCOAError(nil, "'pingTimeoutSeconds' is not an integer in MQTT provider config", v1alpha2.BadConfig)
                }</span>
        } else<span class="cov0" title="0"> {
                ret.PingTimeoutSeconds = 1
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func (i *MQTTTargetProvider) InitWithMap(properties map[string]string) error <span class="cov0" title="0">{
        config, err := MQTTTargetProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return i.Init(config)</span>
}

func (s *MQTTTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *MQTTTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        lock.Lock()
        defer lock.Unlock()

        _, span := observability.StartSpan("MQTT Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (MQTT Target): Init()")

        if i.Initialized </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">updateConfig, err := toMQTTTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (MQTT Target): expected HttpTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        id := uuid.New()
        opts := gmqtt.NewClientOptions().AddBroker(i.Config.BrokerAddress).SetClientID(id.String())
        opts.SetKeepAlive(time.Duration(i.Config.KeepAliveSeconds) * time.Second)
        opts.SetPingTimeout(time.Duration(i.Config.PingTimeoutSeconds) * time.Second)
        opts.CleanSession = true
        i.MQTTClient = gmqtt.NewClient(opts)
        if token := i.MQTTClient.Connect(); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov8" title="1">{
                sLog.Errorf("  P (MQTT Target): faild to connect to MQTT broker - %+v", err)
                return v1alpha2.NewCOAError(token.Error(), "failed to connect to MQTT broker", v1alpha2.InternalError)
        }</span>

        <span class="cov0" title="0">i.GetChan = make(chan ProxyResponse)
        i.RemoveChan = make(chan ProxyResponse)
        i.NeedsUpdateChan = make(chan ProxyResponse)
        i.NeedsRemoveChan = make(chan ProxyResponse)
        i.ApplyChan = make(chan ProxyResponse)

        if token := i.MQTTClient.Subscribe(i.Config.ResponseTopic, 0, func(client gmqtt.Client, msg gmqtt.Message) </span><span class="cov0" title="0">{
                var response v1alpha2.COAResponse
                json.Unmarshal(msg.Payload(), &amp;response)
                proxyResponse := ProxyResponse{
                        IsOK:  response.State == v1alpha2.OK || response.State == v1alpha2.Accepted,
                        State: response.State,
                }
                if !proxyResponse.IsOK </span><span class="cov0" title="0">{
                        proxyResponse.Payload = string(response.Body)
                }</span>
                <span class="cov0" title="0">switch response.Metadata["call-context"] </span>{
                case "TargetProvider-Get":<span class="cov0" title="0">
                        if proxyResponse.IsOK </span><span class="cov0" title="0">{
                                var ret []model.ComponentSpec
                                err = json.Unmarshal(response.Body, &amp;ret)
                                if err != nil </span><span class="cov0" title="0">{
                                        sLog.Errorf("  P (MQTT Target): faild to deserialize components from MQTT - %+v, %s", err.Error(), string(response.Body))
                                }</span>
                                <span class="cov0" title="0">proxyResponse.Payload = ret</span>
                        }
                        <span class="cov0" title="0">i.GetChan &lt;- proxyResponse</span>
                case "TargetProvider-Remove":<span class="cov0" title="0">
                        i.RemoveChan &lt;- proxyResponse</span>
                case "TargetProvider-NeedsUpdate":<span class="cov0" title="0">
                        i.NeedsUpdateChan &lt;- proxyResponse</span>
                case "TargetProvider-NeedsRemove":<span class="cov0" title="0">
                        i.NeedsRemoveChan &lt;- proxyResponse</span>
                case "TargetProvider-Apply":<span class="cov0" title="0">
                        i.ApplyChan &lt;- proxyResponse</span>
                }
        }); token.Wait() &amp;&amp; token.Error() != nil <span class="cov0" title="0">{
                if token.Error().Error() != "subscription exists" </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (MQTT Target): faild to connect to subscribe to the response topic - %+v", token.Error())
                        err = v1alpha2.NewCOAError(token.Error(), "failed to subscribe to response topic", v1alpha2.InternalError)
                        return err
                }</span>
        }
        <span class="cov0" title="0">i.Initialized = true
        return nil</span>
}
func toMQTTTargetProviderConfig(config providers.IProviderConfig) (MQTTTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := MQTTTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

func (i *MQTTTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov0" title="0">{
        _, span := observability.StartSpan("MQTT Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (MQTT Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        data, _ := json.Marshal(deployment)
        request := v1alpha2.COARequest{
                Route:  "instances",
                Method: "GET",
                Body:   data,
                Metadata: map[string]string{
                        "call-context": "TargetProvider-Get",
                },
        }
        data, _ = json.Marshal(request)

        if token := i.MQTTClient.Publish(i.Config.RequestTopic, 0, false, data); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                sLog.Infof("  P (MQTT Target): failed to getting artifacts - %s", token.Error())
                err = token.Error()
                return nil, err
        }</span>

        <span class="cov0" title="0">timeout := time.After(time.Duration(i.Config.TimeoutSeconds) * time.Second)
        select </span>{
        case resp := &lt;-i.GetChan:<span class="cov0" title="0">
                if resp.IsOK </span><span class="cov0" title="0">{
                        var data []byte
                        data, err = json.Marshal(resp.Payload)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Infof("  P (MQTT Target): failed to serialize payload - %s - %s", err.Error(), fmt.Sprint(resp.Payload))
                                err = v1alpha2.NewCOAError(nil, err.Error(), v1alpha2.InternalError)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">var ret []model.ComponentSpec
                        err = json.Unmarshal(data, &amp;ret)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Infof("  P (MQTT Target): failed to deserialize components - %s - %s", err.Error(), fmt.Sprint(data))
                                err = v1alpha2.NewCOAError(nil, err.Error(), v1alpha2.InternalError)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return ret, nil</span>
                } else<span class="cov0" title="0"> {
                        err = v1alpha2.NewCOAError(nil, fmt.Sprint(resp.Payload), resp.State)
                        return nil, err
                }</span>
        case &lt;-timeout:<span class="cov0" title="0">
                err = v1alpha2.NewCOAError(nil, "didn't get response to Get() call over MQTT", v1alpha2.InternalError)
                return nil, err</span>
        }
}
func (i *MQTTTargetProvider) Remove(ctx context.Context, deployment model.DeploymentSpec, currentRef []model.ComponentSpec) error <span class="cov0" title="0">{
        _, span := observability.StartSpan("MQTT Target Provider", ctx, &amp;map[string]string{
                "method": "Remove",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (MQTT Target): deleting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        data, _ := json.Marshal(deployment)
        request := v1alpha2.COARequest{
                Route:  "instances",
                Method: "DELETE",
                Body:   data,
                Metadata: map[string]string{
                        "call-context": "TargetProvider-Remove",
                },
        }
        data, _ = json.Marshal(request)

        if token := i.MQTTClient.Publish(i.Config.RequestTopic, 0, false, data); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                err = token.Error()
                return err
        }</span>

        <span class="cov0" title="0">timeout := time.After(time.Duration(i.Config.TimeoutSeconds) * time.Second)
        select </span>{
        case resp := &lt;-i.RemoveChan:<span class="cov0" title="0">
                if resp.IsOK </span><span class="cov0" title="0">{
                        err = nil
                        return err
                }</span> else<span class="cov0" title="0"> {
                        err = v1alpha2.NewCOAError(nil, fmt.Sprint(resp.Payload), resp.State)
                        return err
                }</span>
        case &lt;-timeout:<span class="cov0" title="0">
                err = v1alpha2.NewCOAError(nil, "didn't get response to Remove() call over MQTT", v1alpha2.InternalError)
                return err</span>
        }
}

func (i *MQTTTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("MQTT Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (MQTT Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov0" title="0">ret := step.PrepareResultMap()
        data, _ := json.Marshal(deployment)

        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{

                request := v1alpha2.COARequest{
                        Route:  "instances",
                        Method: "POST",
                        Body:   data,
                        Metadata: map[string]string{
                                "call-context": "TargetProvider-Apply",
                        },
                }
                data, _ = json.Marshal(request)

                if token := i.MQTTClient.Publish(i.Config.RequestTopic, 0, false, data); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                        err = token.Error()
                        return ret, err
                }</span>

                <span class="cov0" title="0">timeout := time.After(time.Duration(i.Config.TimeoutSeconds) * time.Second)
                select </span>{
                case resp := &lt;-i.ApplyChan:<span class="cov0" title="0">
                        if resp.IsOK </span><span class="cov0" title="0">{
                                err = nil
                                return ret, err
                        }</span> else<span class="cov0" title="0"> {
                                err = v1alpha2.NewCOAError(nil, fmt.Sprint(resp.Payload), resp.State)
                                return ret, err
                        }</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        err = v1alpha2.NewCOAError(nil, "didn't get response to Apply() call over MQTT", v1alpha2.InternalError)
                        return ret, err</span>
                }
        }
        <span class="cov0" title="0">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov0" title="0">{
                request := v1alpha2.COARequest{
                        Route:  "instances",
                        Method: "DELETE",
                        Body:   data,
                        Metadata: map[string]string{
                                "call-context": "TargetProvider-Remove",
                        },
                }
                data, _ = json.Marshal(request)

                if token := i.MQTTClient.Publish(i.Config.RequestTopic, 0, false, data); token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                        err = token.Error()
                        return ret, err
                }</span>

                <span class="cov0" title="0">timeout := time.After(time.Duration(i.Config.TimeoutSeconds) * time.Second)
                select </span>{
                case resp := &lt;-i.RemoveChan:<span class="cov0" title="0">
                        if resp.IsOK </span><span class="cov0" title="0">{
                                err = nil
                                return ret, err
                        }</span> else<span class="cov0" title="0"> {
                                err = v1alpha2.NewCOAError(nil, fmt.Sprint(resp.Payload), resp.State)
                                return ret, err
                        }</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        err = v1alpha2.NewCOAError(nil, "didn't get response to Remove() call over MQTT", v1alpha2.InternalError)
                        return ret, err</span>
                }
        }
        //TODO: Should we remove empty namespaces?
        <span class="cov0" title="0">err = nil
        return ret, nil</span>
}

func (*MQTTTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>

type TwoComponentSlices struct {
        Current []model.ComponentSpec `json:"current"`
        Desired []model.ComponentSpec `json:"desired"`
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package proxy

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "net/http"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type ProxyUpdateProviderConfig struct {
        Name      string `json:"name"`
        ServerURL string `json:"serverUrl"`
}

type ProxyUpdateProvider struct {
        Config  ProxyUpdateProviderConfig
        Context *contexts.ManagerContext
}

func ProxyUpdateProviderConfigFromMap(properties map[string]string) (ProxyUpdateProviderConfig, error) <span class="cov8" title="1">{
        ret := ProxyUpdateProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = utils.ParseProperty(v)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["serverUrl"]; ok </span><span class="cov8" title="1">{
                ret.ServerURL = utils.ParseProperty(v)
        }</span> else<span class="cov0" title="0"> {
                return ret, v1alpha2.NewCOAError(nil, "proxy update provider server url is not set", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *ProxyUpdateProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := ProxyUpdateProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *ProxyUpdateProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *ProxyUpdateProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Proxy Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("~~~ Proxy Provider ~~~ : Init()")

        updateConfig, err := toProxyUpdateProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("expected ProxyUpdateProviderConfig")
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        return nil</span>
}
func toProxyUpdateProviderConfig(config providers.IProviderConfig) (ProxyUpdateProviderConfig, error) <span class="cov8" title="1">{
        ret := ProxyUpdateProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        ret.Name = utils.ParseProperty(ret.Name)
        ret.ServerURL = utils.ParseProperty(ret.ServerURL)
        return ret, err</span>
}

func (a *ProxyUpdateProvider) callRestAPI(route string, method string, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        client := &amp;http.Client{}
        url := a.Config.ServerURL + route
        req, err := http.NewRequest(method, url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to invoke Percept API: %v", err), v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to invoke Percept API: %v", err), v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        bodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to invoke Percept API: %v", err), v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(err, fmt.Sprintf("failed to invoke Percept API: %v", string(bodyBytes)), v1alpha2.InternalError)
        }</span>
        <span class="cov8" title="1">return bodyBytes, nil</span>
}

func (i *ProxyUpdateProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("Proxy Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("~~~ Proxy Provider ~~~ : getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        data, _ := json.Marshal(deployment)
        payload, err := i.callRestAPI("instances", "GET", data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := make([]model.ComponentSpec, 0)
        err = json.Unmarshal(payload, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func (i *ProxyUpdateProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Proxy Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("~~~ Proxy Provider ~~~ : applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                data, _ := json.Marshal(deployment)

                _, err = i.callRestAPI("instances", "POST", data)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
        }
        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                data, _ := json.Marshal(deployment)
                _, err = i.callRestAPI("instances", "DELETE", data)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
        }
        //TODO: Should we remove empty namespaces?
        <span class="cov8" title="1">err = nil
        return ret, nil</span>
}

func (*ProxyUpdateProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>

type TwoComponentSlices struct {
        Current []model.ComponentSpec `json:"current"`
        Desired []model.ComponentSpec `json:"desired"`
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package script

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/google/uuid"
)

var sLog = logger.NewLogger("coa.runtime")

type ScriptProviderConfig struct {
        Name          string `json:"name"`
        ApplyScript   string `json:"applyScript"`
        RemoveScript  string `json:"removeScript"`
        GetScript     string `json:"getScript"`
        ScriptFolder  string `json:"scriptFolder,omitempty"`
        StagingFolder string `json:"stagingFolder,omitempty"`
        ScriptEngine  string `json:"scriptEngine,omitempty"`
}

type ScriptProvider struct {
        Config  ScriptProviderConfig
        Context *contexts.ManagerContext
}

func ScriptProviderConfigFromMap(properties map[string]string) (ScriptProviderConfig, error) <span class="cov8" title="1">{
        ret := ScriptProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["stagingFolder"]; ok </span><span class="cov8" title="1">{
                ret.StagingFolder = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["scriptFolder"]; ok </span><span class="cov8" title="1">{
                ret.ScriptFolder = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["applyScript"]; ok </span><span class="cov8" title="1">{
                ret.ApplyScript = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "invalid script provider config, exptected 'applyScript'", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["removeScript"]; ok </span><span class="cov8" title="1">{
                ret.RemoveScript = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "invalid script provider config, exptected 'removeScript'", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["getScript"]; ok </span><span class="cov8" title="1">{
                ret.GetScript = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "invalid script provider config, exptected 'getScript'", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">if v, ok := properties["scriptEngine"]; ok </span><span class="cov8" title="1">{
                ret.ScriptEngine = v
        }</span> else<span class="cov0" title="0"> {
                ret.ScriptEngine = "bash"
        }</span>
        <span class="cov8" title="1">if ret.ScriptEngine != "bash" &amp;&amp; ret.ScriptEngine != "powershell" </span><span class="cov0" title="0">{
                return ret, v1alpha2.NewCOAError(nil, "invalid script engine, exptected 'bash' or 'powershell'", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *ScriptProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := ScriptProviderConfigFromMap(properties)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *ScriptProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *ScriptProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Script Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("  P (Script Target): Init()")

        updateConfig, err := toScriptProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("expected ScriptProviderConfig")
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov8" title="1">{
                err = downloadFile(i.Config.ScriptFolder, i.Config.ApplyScript, i.Config.StagingFolder)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = downloadFile(i.Config.ScriptFolder, i.Config.RemoveScript, i.Config.StagingFolder)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = downloadFile(i.Config.ScriptFolder, i.Config.GetScript, i.Config.StagingFolder)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = nil
        return nil</span>
}
func downloadFile(scriptFolder string, script string, stagingFolder string) error <span class="cov8" title="1">{
        sPath, err := url.JoinPath(scriptFolder, script)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tPath := filepath.Join(stagingFolder, script)

        out, err := os.Create(tPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer out.Close()

        resp, err := http.Get(sPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        _, err = io.Copy(out, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.Chmod(tPath, 0755)</span>
}
func toScriptProviderConfig(config providers.IProviderConfig) (ScriptProviderConfig, error) <span class="cov8" title="1">{
        ret := ScriptProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}

func (i *ScriptProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("Script Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("  P (Script Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        id := uuid.New().String()
        input := id + ".json"
        input_ref := id + "-ref.json"
        output := id + "-output.json"

        staging := filepath.Join(i.Config.StagingFolder, input)
        file, _ := json.MarshalIndent(deployment, "", " ")
        _ = ioutil.WriteFile(staging, file, 0644)

        staging_ref := filepath.Join(i.Config.StagingFolder, input_ref)
        file_ref, _ := json.MarshalIndent(references, "", " ")
        _ = ioutil.WriteFile(staging_ref, file_ref, 0644)

        abs, _ := filepath.Abs(staging)
        abs_ref, _ := filepath.Abs(staging_ref)

        defer os.Remove(abs)
        defer os.Remove(abs_ref)

        scriptAbs, _ := filepath.Abs(filepath.Join(i.Config.ScriptFolder, i.Config.GetScript))
        if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov0" title="0">{
                scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.StagingFolder, i.Config.GetScript))
        }</span>

        <span class="cov8" title="1">o, err := i.runCommand(scriptAbs, abs, abs_ref)
        sLog.Debugf("  P (Script Target): get script output: %s", o)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to run get script: %+v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">outputStaging := filepath.Join(i.Config.StagingFolder, output)

        data, err := ioutil.ReadFile(outputStaging)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to parse get script output (expected []ComponentSpec): %+v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">abs_output, _ := filepath.Abs(outputStaging)

        defer os.Remove(abs_output)

        ret := make([]model.ComponentSpec, 0)
        err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to parse get script output (expected []ComponentSpec): %+v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *ScriptProvider) runScriptOnComponents(deployment model.DeploymentSpec, components []model.ComponentSpec, isRemove bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        id := uuid.New().String()
        deploymentId := id + ".json"
        currenRefId := id + "-ref.json"
        output := id + "-output.json"

        stagingDeployment := filepath.Join(i.Config.StagingFolder, deploymentId)
        file, _ := json.MarshalIndent(deployment, "", " ")
        _ = ioutil.WriteFile(stagingDeployment, file, 0644)

        stagingRef := filepath.Join(i.Config.StagingFolder, currenRefId)
        file, _ = json.MarshalIndent(components, "", " ")
        _ = ioutil.WriteFile(stagingRef, file, 0644)

        absDeployment, _ := filepath.Abs(stagingDeployment)
        absRef, _ := filepath.Abs(stagingRef)

        var scriptAbs = ""
        if isRemove </span><span class="cov8" title="1">{
                scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.ScriptFolder, i.Config.RemoveScript))
                if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov0" title="0">{
                        scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.StagingFolder, i.Config.RemoveScript))
                }</span>
        } else<span class="cov8" title="1"> {
                scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.ScriptFolder, i.Config.ApplyScript))
                if strings.HasPrefix(i.Config.ScriptFolder, "http") </span><span class="cov0" title="0">{
                        scriptAbs, _ = filepath.Abs(filepath.Join(i.Config.StagingFolder, i.Config.ApplyScript))
                }</span>
        }
        <span class="cov8" title="1">o, err := i.runCommand(scriptAbs, absDeployment, absRef)
        sLog.Debugf("  P (Script Target): apply script output: %s", o)

        defer os.Remove(absDeployment)
        defer os.Remove(absRef)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to run apply script: %+v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">outputStaging := filepath.Join(i.Config.StagingFolder, output)

        data, err := ioutil.ReadFile(outputStaging)

        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to parse apply script output (expected map[string]model.ComponentResultSpec): %+v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">abs_output, _ := filepath.Abs(outputStaging)

        defer os.Remove(abs_output)

        ret := make(map[string]model.ComponentResultSpec)
        err = json.Unmarshal(data, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Script Target): failed to parse get script output (expected map[string]model.ComponentResultSpec): %+v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *ScriptProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Script Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        sLog.Infof("  P (Script Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        err = i.GetValidationRule(ctx).Validate([]model.ComponentSpec{}) //this provider doesn't handle any components        TODO: is this right?
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()
        components := step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                var retU map[string]model.ComponentResultSpec
                retU, err = i.runScriptOnComponents(deployment, components, false)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Script Target): failed to run apply script: %+v", err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">for k, v := range retU </span><span class="cov8" title="1">{
                        ret[k] = v
                }</span>
        }
        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                var retU map[string]model.ComponentResultSpec
                retU, err = i.runScriptOnComponents(deployment, components, true)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Script Target): failed to run remove script: %+v", err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">for k, v := range retU </span><span class="cov8" title="1">{
                        ret[k] = v
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (*ScriptProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>

func (i *ScriptProvider) runCommand(scriptAbs string, parameters ...string) ([]byte, error) <span class="cov8" title="1">{
        // Sanitize input to prevent command injection
        scriptAbs = strings.ReplaceAll(scriptAbs, "|", "")
        scriptAbs = strings.ReplaceAll(scriptAbs, "&amp;", "")
        for idx, param := range parameters </span><span class="cov8" title="1">{
                parameters[idx] = strings.ReplaceAll(param, "|", "")
                parameters[idx] = strings.ReplaceAll(param, "&amp;", "")
        }</span>

        <span class="cov8" title="1">var err error
        var out []byte
        params := make([]string, 0)
        if i.Config.ScriptEngine == "" || i.Config.ScriptEngine == "bash" </span><span class="cov8" title="1">{
                params = append(params, parameters...)
                out, err = exec.Command(scriptAbs, params...).Output()
        }</span> else<span class="cov0" title="0"> {
                params = append(params, scriptAbs)
                params = append(params, parameters...)
                out, err = exec.Command("powershell", params...).Output()
        }</span>
        <span class="cov8" title="1">return out, err</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package staging

import (
        "context"
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type StagingTargetProviderConfig struct {
        Name       string `json:"name"`
        TargetName string `json:"targetName"`
}

type StagingTargetProvider struct {
        Config  StagingTargetProviderConfig
        Context *contexts.ManagerContext
}

func StagingProviderConfigFromMap(properties map[string]string) (StagingTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := StagingTargetProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["targetName"]; ok </span><span class="cov8" title="1">{
                ret.TargetName = v
        }</span> else<span class="cov8" title="1"> {
                return ret, v1alpha2.NewCOAError(nil, "invalid staging provider config, exptected 'targetName'", v1alpha2.BadConfig)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func (i *StagingTargetProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := StagingProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *StagingTargetProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *StagingTargetProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Staging Target Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)
        sLog.Info("  P (Staging Target): Init()")

        updateConfig, err := toStagingTargetProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Staging Target): expected StagingTargetProviderConfig: %+v", err)
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig
        return nil</span>
}
func toStagingTargetProviderConfig(config providers.IProviderConfig) (StagingTargetProviderConfig, error) <span class="cov8" title="1">{
        ret := StagingTargetProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *StagingTargetProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Staging Target Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        sLog.Infof("  P (Staging Target): getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        var err error
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        scope := deployment.Instance.Scope
        if scope == "" </span><span class="cov8" title="1">{
                scope = "default"
        }</span>
        <span class="cov8" title="1">catalog, err := utils.GetCatalog(
                ctx,
                i.Context.SiteInfo.CurrentSite.BaseUrl,
                deployment.Instance.Name+"-"+i.Config.TargetName,
                i.Context.SiteInfo.CurrentSite.Username,
                i.Context.SiteInfo.CurrentSite.Password)

        if err != nil </span><span class="cov0" title="0">{
                if v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                        sLog.Infof("  P (Staging Target): no staged artifact found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
                return nil, err</span>
        }

        <span class="cov8" title="1">if spec, ok := catalog.Spec.Properties["components"]; ok </span><span class="cov8" title="1">{
                var components []model.ComponentSpec
                jData, _ := json.Marshal(spec)
                err = json.Unmarshal(jData, &amp;components)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret := make([]model.ComponentSpec, len(references))
                for i, reference := range references </span><span class="cov8" title="1">{
                        for _, component := range components </span><span class="cov8" title="1">{
                                if component.Name == reference.Component.Name </span><span class="cov8" title="1">{
                                        ret[i] = component
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return ret, nil</span>
        }
        <span class="cov0" title="0">err = v1alpha2.NewCOAError(nil, "staged artifact is not found as a 'spec' property", v1alpha2.NotFound)
        sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
        return nil, err</span>
}
func (i *StagingTargetProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Staging Target Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        sLog.Infof("  P (Staging Target): applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        var err error
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        err = i.GetValidationRule(ctx).Validate([]model.ComponentSpec{}) //this provider doesn't handle any components        TODO: is this right?
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Staging Target): failed to validate components: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                sLog.Infof("  P (Staging Target): dry run, skipping apply")
                return nil, nil
        }</span>
        <span class="cov8" title="1">ret := step.PrepareResultMap()

        scope := deployment.Instance.Scope
        if scope == "" </span><span class="cov8" title="1">{
                scope = "default"
        }</span>

        <span class="cov8" title="1">var catalog model.CatalogState

        catalog, err = utils.GetCatalog(
                ctx,
                i.Context.SiteInfo.CurrentSite.BaseUrl,
                deployment.Instance.Name+"-"+i.Config.TargetName,
                i.Context.SiteInfo.CurrentSite.Username,
                i.Context.SiteInfo.CurrentSite.Password)
        if err != nil &amp;&amp; !v1alpha2.IsNotFound(err) </span><span class="cov8" title="1">{
                sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
                return ret, err
        }</span>

        <span class="cov8" title="1">if catalog.Spec == nil </span><span class="cov0" title="0">{
                catalog.Id = deployment.Instance.Name + "-" + i.Config.TargetName
                catalog.Spec = &amp;model.CatalogSpec{
                        SiteId: i.Context.SiteInfo.SiteId,
                        Type:   "staged",
                        Name:   catalog.Id,
                }
        }</span>
        <span class="cov8" title="1">if catalog.Spec.Properties == nil </span><span class="cov0" title="0">{
                catalog.Spec.Properties = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">var existing []model.ComponentSpec
        if v, ok := catalog.Spec.Properties["components"]; ok </span><span class="cov8" title="1">{
                jData, _ := json.Marshal(v)
                err = json.Unmarshal(jData, &amp;existing)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
                        return ret, err
                }</span>
        }

        <span class="cov8" title="1">components := step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for i, component := range components </span><span class="cov8" title="1">{
                        found := false
                        for j, c := range existing </span><span class="cov8" title="1">{
                                if c.Name == component.Name </span><span class="cov8" title="1">{
                                        found = true
                                        existing[j] = components[i]
                                        ret[component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.Updated,
                                                Message: "",
                                        }
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                existing = append(existing, component)
                        }</span>
                }
        }

        <span class="cov8" title="1">var deleted []model.ComponentSpec
        if v, ok := catalog.Spec.Properties["removed-components"]; ok </span><span class="cov0" title="0">{
                jData, _ := json.Marshal(v)
                err = json.Unmarshal(jData, &amp;deleted)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("  P (Staging Target): failed to get staged artifact: %v", err)
                        return ret, err
                }</span>
        }

        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for i, component := range components </span><span class="cov8" title="1">{
                        found := false
                        for j, c := range deleted </span><span class="cov0" title="0">{
                                if c.Name == component.Name </span><span class="cov0" title="0">{
                                        found = true
                                        deleted[j] = components[i]
                                        ret[component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.Updated,
                                                Message: "",
                                        }
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                deleted = append(deleted, component)
                        }</span>
                }
        }

        <span class="cov8" title="1">catalog.Spec.Properties["components"] = existing
        catalog.Spec.Properties["removed-components"] = deleted
        jData, _ := json.Marshal(catalog.Spec)
        err = utils.UpsertCatalog(
                ctx,
                i.Context.SiteInfo.CurrentSite.BaseUrl,
                deployment.Instance.Name+"-"+i.Config.TargetName,
                i.Context.SiteInfo.CurrentSite.Username,
                i.Context.SiteInfo.CurrentSite.Password, jData)
        if err != nil </span><span class="cov0" title="0">{
                sLog.Errorf("  P (Staging Target): failed to upsert staged artifact: %v", err)
        }</span>
        <span class="cov8" title="1">return ret, err</span>
}

func (*StagingTargetProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package sideload

import (
        "context"
        "encoding/json"
        "errors"
        "os/exec"
        "regexp"
        "strconv"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/contexts"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type Win10SideLoadProviderConfig struct {
        Name                string `json:"name"`
        IPAddress           string `json:"ipAddress"`
        Pin                 string `json:"pin,omitempty"`
        WinAppDeployCmdPath string `json:"winAppDeployCmdPath"`
        NetworkUser         string `json:"networkUser,omitempty"`
        NetworkPassword     string `json:"networkPassword,omitempty"`
        Silent              bool   `json:"silent,omitempty"`
}

type Win10SideLoadProvider struct {
        Config  Win10SideLoadProviderConfig
        Context *contexts.ManagerContext
}

func Win10SideLoadProviderConfigFromMap(properties map[string]string) (Win10SideLoadProviderConfig, error) <span class="cov8" title="1">{
        ret := Win10SideLoadProviderConfig{}
        if v, ok := properties["name"]; ok </span><span class="cov8" title="1">{
                ret.Name = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["ipAddress"]; ok </span><span class="cov8" title="1">{
                ret.IPAddress = v
        }</span> else<span class="cov0" title="0"> {
                ret.IPAddress = "localhost"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["pin"]; ok </span><span class="cov8" title="1">{
                ret.Pin = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["winAppDeployCmdPath"]; ok </span><span class="cov8" title="1">{
                ret.WinAppDeployCmdPath = v
        }</span> else<span class="cov0" title="0"> {
                ret.WinAppDeployCmdPath = "c:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.19041.0\\x86\\WinAppDeployCmd.exe"
        }</span>
        <span class="cov8" title="1">if v, ok := properties["networkUser"]; ok </span><span class="cov8" title="1">{
                ret.NetworkUser = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["networkPassword"]; ok </span><span class="cov8" title="1">{
                ret.NetworkPassword = v
        }</span>
        <span class="cov8" title="1">if v, ok := properties["silent"]; ok </span><span class="cov8" title="1">{
                bVal, err := strconv.ParseBool(v)
                if err != nil </span><span class="cov0" title="0">{
                        ret.Silent = false
                }</span> else<span class="cov8" title="1"> {
                        ret.Silent = bVal
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (i *Win10SideLoadProvider) InitWithMap(properties map[string]string) error <span class="cov8" title="1">{
        config, err := Win10SideLoadProviderConfigFromMap(properties)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.Init(config)</span>
}

func (s *Win10SideLoadProvider) SetContext(ctx *contexts.ManagerContext) <span class="cov0" title="0">{
        s.Context = ctx
}</span>

func (i *Win10SideLoadProvider) Init(config providers.IProviderConfig) error <span class="cov8" title="1">{
        _, span := observability.StartSpan("Win 10 Sideload Provider", context.TODO(), &amp;map[string]string{
                "method": "Init",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Info("~~~ Win 10 Sideload Provider ~~~ : Init()")

        updateConfig, err := toWin10SideLoadProviderConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("expected Win10SideLoadProviderConfig")
                return err
        }</span>
        <span class="cov8" title="1">i.Config = updateConfig

        return nil</span>
}
func toWin10SideLoadProviderConfig(config providers.IProviderConfig) (Win10SideLoadProviderConfig, error) <span class="cov8" title="1">{
        ret := Win10SideLoadProviderConfig{}
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;ret)
        return ret, err</span>
}
func (i *Win10SideLoadProvider) Get(ctx context.Context, deployment model.DeploymentSpec, references []model.ComponentStep) ([]model.ComponentSpec, error) <span class="cov8" title="1">{
        _, span := observability.StartSpan("Win 10 Sideload Provider", ctx, &amp;map[string]string{
                "method": "Get",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("~~~ Win 10 Sideload Provider ~~~ : getting artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        params := make([]string, 0)
        params = append(params, "list")
        params = append(params, "-ip")
        params = append(params, i.Config.IPAddress)
        if i.Config.Pin != "" </span><span class="cov8" title="1">{
                params = append(params, "-pin")
                params = append(params, i.Config.Pin)
        }</span>

        <span class="cov8" title="1">out, err := exec.Command(i.Config.WinAppDeployCmdPath, params...).Output()

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">str := string(out)
        lines := strings.Split(str, "\r\n")

        desired := deployment.GetComponentSlice()

        re := regexp.MustCompile(`^(\w+\.)+\w+$`)
        ret := make([]model.ComponentSpec, 0)
        for _, line := range lines </span><span class="cov0" title="0">{
                if re.Match([]byte(line)) </span><span class="cov0" title="0">{
                        mLine := line
                        if strings.LastIndex(line, "__") &gt; 0 </span><span class="cov0" title="0">{
                                mLine = line[:strings.LastIndex(line, "__")]
                        }</span>
                        <span class="cov0" title="0">for _, component := range desired </span><span class="cov0" title="0">{
                                if component.Name == mLine </span><span class="cov0" title="0">{
                                        ret = append(ret, model.ComponentSpec{
                                                Name: line,
                                                Type: "win.uwp",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return ret, nil</span>
}
func (i *Win10SideLoadProvider) Apply(ctx context.Context, deployment model.DeploymentSpec, step model.DeploymentStep, isDryRun bool) (map[string]model.ComponentResultSpec, error) <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Win 10 Sideload Provider", ctx, &amp;map[string]string{
                "method": "Apply",
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        sLog.Infof("~~~ Win 10 Sideload Provider ~~~ : applying artifacts: %s - %s", deployment.Instance.Scope, deployment.Instance.Name)

        components := step.GetComponents()
        err = i.GetValidationRule(ctx).Validate(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDryRun </span><span class="cov8" title="1">{
                err = nil
                return nil, nil
        }</span>

        <span class="cov8" title="1">ret := step.PrepareResultMap()
        components = step.GetUpdatedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for _, component := range components </span><span class="cov8" title="1">{
                        if path, ok := component.Properties["app.package.path"].(string); ok </span><span class="cov8" title="1">{
                                params := make([]string, 0)
                                params = append(params, "install")
                                params = append(params, "-ip")
                                params = append(params, i.Config.IPAddress)
                                if i.Config.Pin != "" </span><span class="cov8" title="1">{
                                        params = append(params, "-pin")
                                        params = append(params, i.Config.Pin)
                                }</span>
                                <span class="cov8" title="1">params = append(params, "-file")
                                params = append(params, path)

                                cmd := exec.Command(i.Config.WinAppDeployCmdPath, params...)
                                err = cmd.Run()
                                if err != nil </span><span class="cov8" title="1">{
                                        ret[component.Name] = model.ComponentResultSpec{
                                                Status:  v1alpha2.UpdateFailed,
                                                Message: err.Error(),
                                        }
                                        if i.Config.Silent </span><span class="cov0" title="0">{
                                                return ret, nil
                                        }</span> else<span class="cov8" title="1"> {
                                                return ret, err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">components = step.GetDeletedComponents()
        if len(components) &gt; 0 </span><span class="cov8" title="1">{
                for _, component := range components </span><span class="cov8" title="1">{
                        if component.Name != "" </span><span class="cov8" title="1">{
                                params := make([]string, 0)
                                params = append(params, "uninstall")
                                params = append(params, "-ip")
                                params = append(params, i.Config.IPAddress)
                                if i.Config.Pin != "" </span><span class="cov8" title="1">{
                                        params = append(params, "-pin")
                                        params = append(params, i.Config.Pin)
                                }</span>
                                <span class="cov8" title="1">params = append(params, "-package")

                                name := component.Name

                                // TODO: this is broken due to the refactor, the current reference is no longer available
                                // for _, ref := range currentRef {
                                //         if ref.Name == name || strings.HasPrefix(ref.Name, name) {
                                //                 name = ref.Name
                                //                 break
                                //         }
                                // }

                                params = append(params, name)

                                cmd := exec.Command(i.Config.WinAppDeployCmdPath, params...)
                                err = cmd.Run()
                                if err != nil </span><span class="cov8" title="1">{
                                        if i.Config.Silent </span><span class="cov8" title="1">{
                                                return ret, nil
                                        }</span> else<span class="cov0" title="0"> {
                                                return ret, err
                                        }</span>
                                }

                        }
                }
        }
        <span class="cov0" title="0">err = nil
        return ret, nil</span>
}

func (i *Win10SideLoadProvider) NeedsUpdate(ctx context.Context, desired []model.ComponentSpec, current []model.ComponentSpec) bool <span class="cov8" title="1">{
        for _, d := range desired </span><span class="cov8" title="1">{
                found := false
                for _, c := range current </span><span class="cov8" title="1">{
                        if c.Name == d.Name || strings.HasPrefix(c.Name, d.Name) </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
func (i *Win10SideLoadProvider) NeedsRemove(ctx context.Context, desired []model.ComponentSpec, current []model.ComponentSpec) bool <span class="cov8" title="1">{
        for _, d := range desired </span><span class="cov8" title="1">{
                for _, c := range current </span><span class="cov8" title="1">{
                        if c.Name == d.Name || strings.HasPrefix(c.Name, d.Name) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (*Win10SideLoadProvider) GetValidationRule(ctx context.Context) model.ValidationRule <span class="cov8" title="1">{
        return model.ValidationRule{
                RequiredProperties:    []string{},
                OptionalProperties:    []string{},
                RequiredComponentType: "",
                RequiredMetadata:      []string{},
                OptionalMetadata:      []string{},
                ChangeDetectionProperties: []model.PropertyDesc{
                        {Name: "", IsComponentName: true, IgnoreCase: true, PrefixMatch: true},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package utils

import (
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "text/scanner"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
)

type Token int

const (
        EOF Token = iota
        NUMBER
        INT
        DOLLAR
        IDENT
        OPAREN
        CPAREN
        OBRACKET
        CBRACKET
        OCURLY
        CCURLY
        PLUS
        MINUS
        MULT
        DIV
        COMMA
        PERIOD
        COLON
        QUESTION
        EQUAL
        STRING
        RUNON
        AMPHERSAND
        SLASH
        TILDE
)

var opNames = map[Token]string{
        PLUS:       "+",
        MINUS:      "-",
        MULT:       "*",
        DIV:        "/",
        SLASH:      "\\",
        COMMA:      ",",
        PERIOD:     ".",
        COLON:      ":",
        QUESTION:   "?",
        EQUAL:      "=",
        AMPHERSAND: "&amp;",
        TILDE:      "~",
}

type Node interface {
        Eval(context utils.EvaluationContext) (interface{}, error)
}

type NumberNode struct {
        Value float64
}

func (n *NumberNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov0" title="0">{
        return n.Value, nil
}</span>

type IntNode struct {
        Value int64
}

func (n *IntNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        return n.Value, nil
}</span>

type IdentifierNode struct {
        Value string
}

func removeQuotes(s string) string <span class="cov8" title="1">{
        if len(s) &lt; 2 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">first := s[0]
        last := s[len(s)-1]
        if first == '\'' &amp;&amp; last == '\'' </span><span class="cov8" title="1">{
                return s[1 : len(s)-1]
        }</span>
        <span class="cov8" title="1">return s</span>
}

func (n *IdentifierNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        return removeQuotes(n.Value), nil
}</span>

type NullNode struct {
}

func (n *NullNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov0" title="0">{
        return "", nil
}</span>

type UnaryNode struct {
        Op   Token
        Expr Node
}

func (n *UnaryNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        switch n.Op </span>{
        case PLUS:<span class="cov8" title="1">
                if n.Expr != nil </span><span class="cov8" title="1">{
                        return n.Expr.Eval(context)
                }</span>
                <span class="cov8" title="1">return "", nil</span>
        case MINUS:<span class="cov8" title="1">
                if n.Expr != nil </span><span class="cov8" title="1">{
                        val, err := n.Expr.Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return val, err
                        }</span>
                        <span class="cov8" title="1">if v, ok := val.(int64); ok </span><span class="cov8" title="1">{
                                return -v, nil
                        }</span>
                        <span class="cov8" title="1">if v, ok := val.(float64); ok </span><span class="cov0" title="0">{
                                return -v, nil
                        }</span>
                        <span class="cov8" title="1">return fmt.Sprintf("-%v", val), nil</span>
                }
                <span class="cov8" title="1">return "", nil</span>
        case OBRACKET:<span class="cov8" title="1">
                val, err := n.Expr.Eval(context)
                if err != nil </span><span class="cov0" title="0">{
                        return val, err
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("[%v]", val), nil</span>
        case OCURLY:<span class="cov8" title="1">
                val, err := n.Expr.Eval(context)
                if err != nil </span><span class="cov0" title="0">{
                        return val, err
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("{%v}", val), nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("operator '%s' is not allowed in this context", opNames[n.Op])</span>
}

type BinaryNode struct {
        Op    Token
        Left  Node
        Right Node
}

func (n *BinaryNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        switch n.Op </span>{
        case PLUS:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return formatFloats(lv, rv, ""), nil</span>
        case MINUS:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return formatFloats(lv, rv, "-"), nil</span>
        case COMMA:<span class="cov8" title="1">
                lv, le := n.Left.Eval(context)
                if le != nil </span><span class="cov0" title="0">{
                        return nil, le
                }</span>
                <span class="cov8" title="1">rv, re := n.Right.Eval(context)
                if re != nil </span><span class="cov0" title="0">{
                        return nil, re
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%v,%v", lv, rv), nil</span>
        case MULT:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return formatFloats(lv, rv, "*"), nil</span>
        case DIV:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return formatFloats(lv, rv, "/"), nil</span>
        case SLASH:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov0" title="0">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov0" title="0">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v\\%v", lv, rv), nil</span>
        case PERIOD:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return formatFloats(lv, rv, "."), nil</span>
        case COLON:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v:%v", lv, rv), nil</span>
        case QUESTION:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v?%v", lv, rv), nil</span>
        case EQUAL:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v=%v", lv, rv), nil</span>
        case AMPHERSAND:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v&amp;%v", lv, rv), nil</span>
        case TILDE:<span class="cov8" title="1">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov8" title="1">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov8" title="1">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov8" title="1">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("%v~%v", lv, rv), nil</span>
        case RUNON:<span class="cov0" title="0">
                var lv interface{} = ""
                var le error
                if n.Left != nil </span><span class="cov0" title="0">{
                        lv, le = n.Left.Eval(context)
                        if le != nil </span><span class="cov0" title="0">{
                                return nil, le
                        }</span>
                }
                <span class="cov0" title="0">var rv interface{} = ""
                var re error
                if n.Right != nil </span><span class="cov0" title="0">{
                        rv, re = n.Right.Eval(context)
                        if re != nil </span><span class="cov0" title="0">{
                                return nil, re
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("%v%v", lv, rv), nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("operator '%s' is not allowed in this context", opNames[n.Op])</span>
}

type FunctionNode struct {
        Name string
        Args []Node
}

func readProperty(properties map[string]string, key string) (string, error) <span class="cov8" title="1">{
        if v, ok := properties[key]; ok </span><span class="cov8" title="1">{
                return v, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("property %s is not found", key)</span>
}
func readPropertyInterface(properties map[string]interface{}, key string) (interface{}, error) <span class="cov8" title="1">{
        if v, ok := properties[key]; ok </span><span class="cov8" title="1">{
                return v, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("property %s is not found", key)</span>
}
func readArgument(deployment model.DeploymentSpec, component string, key string) (string, error) <span class="cov8" title="1">{

        arguments := deployment.Instance.Arguments
        if ca, ok := arguments[component]; ok </span><span class="cov8" title="1">{
                if a, ok := ca[key]; ok </span><span class="cov8" title="1">{
                        return a, nil
                }</span>
        }
        <span class="cov8" title="1">components := deployment.Solution.Components
        for _, c := range components </span><span class="cov8" title="1">{
                if c.Name == component </span><span class="cov8" title="1">{
                        if v, ok := c.Parameters[key]; ok </span><span class="cov8" title="1">{
                                return v, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", fmt.Errorf("parameter %s is not found on component %s", key, component)</span>
}

func toIntIfPossible(f float64) interface{} <span class="cov8" title="1">{
        i := int64(f)
        if float64(i) == f </span><span class="cov8" title="1">{
                return i
        }</span>
        <span class="cov8" title="1">return f</span>
}

func formatFloats(left interface{}, right interface{}, operator string) interface{} <span class="cov8" title="1">{
        var lv_f, rv_f float64
        var okl, okr bool
        if lv_i, ok := left.(int64); ok </span><span class="cov8" title="1">{
                lv_f = float64(lv_i)
                okl = true
        }</span> else<span class="cov8" title="1"> {
                lv_f, okl = left.(float64)
        }</span>
        <span class="cov8" title="1">if rv_i, ok := right.(int64); ok </span><span class="cov8" title="1">{
                rv_f = float64(rv_i)
                okr = true
        }</span> else<span class="cov8" title="1"> {
                rv_f, okr = right.(float64)
        }</span>
        <span class="cov8" title="1">if okl &amp;&amp; okr </span><span class="cov8" title="1">{
                switch operator </span>{
                case "":<span class="cov8" title="1">
                        return toIntIfPossible(lv_f + rv_f)</span>
                case "-":<span class="cov8" title="1">
                        return toIntIfPossible(lv_f - rv_f)</span>
                case "*":<span class="cov8" title="1">
                        return toIntIfPossible(lv_f * rv_f)</span>
                case "/":<span class="cov8" title="1">
                        if rv_f != 0 </span><span class="cov8" title="1">{
                                return toIntIfPossible(lv_f / rv_f)
                        }</span> else<span class="cov8" title="1"> {
                                lv_str := strconv.FormatFloat(lv_f, 'f', -1, 64)
                                rv_str := strconv.FormatFloat(rv_f, 'f', -1, 64)
                                return fmt.Sprintf("%v%s%v", lv_str, operator, rv_str)
                        }</span>
                case ".":<span class="cov8" title="1">
                        lv_str := strconv.FormatFloat(lv_f, 'f', -1, 64)
                        rv_str := strconv.FormatFloat(rv_f, 'f', -1, 64)
                        return fmt.Sprintf("%v%s%v", lv_str, operator, rv_str)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("operator '%s' is not allowed in this context", operator)</span>
                }
        } else<span class="cov8" title="1"> if okl </span><span class="cov8" title="1">{
                lv_str := strconv.FormatFloat(lv_f, 'f', -1, 64)
                return fmt.Sprintf("%v%s%v", lv_str, operator, right)
        }</span> else<span class="cov8" title="1"> if okr </span><span class="cov8" title="1">{
                rv_str := strconv.FormatFloat(rv_f, 'f', -1, 64)
                return fmt.Sprintf("%v%s%v", left, operator, rv_str)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%v%s%v", left, operator, right)
        }</span>
}

func (n *FunctionNode) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        switch n.Name </span>{
        case "param":<span class="cov8" title="1">
                if len(n.Args) == 1 </span><span class="cov8" title="1">{
                        if context.Component == "" </span><span class="cov8" title="1">{
                                return nil, errors.New("a component name is needed to evaluate $param()")
                        }</span>
                        <span class="cov8" title="1">key, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if deploymentSpec, ok := context.DeploymentSpec.(model.DeploymentSpec); ok </span><span class="cov8" title="1">{
                                argument, err := readArgument(deploymentSpec, context.Component, key.(string))
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">return argument, nil</span>
                        }
                        <span class="cov0" title="0">return nil, errors.New("deployment spec is not found")</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$params() expects 1 argument, found %d", len(n.Args))</span>
        case "property":<span class="cov8" title="1">
                if len(n.Args) == 1 </span><span class="cov8" title="1">{
                        if context.Properties == nil || len(context.Properties) == 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("a property collection is needed to evaluate $property()")
                        }</span>
                        <span class="cov8" title="1">key, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">property, err := readProperty(context.Properties, key.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return property, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$property() expects 1 argument, found %d", len(n.Args))</span>
        case "input":<span class="cov8" title="1">
                if len(n.Args) == 1 </span><span class="cov8" title="1">{
                        if context.Inputs == nil || len(context.Inputs) == 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("an input collection is needed to evaluate $input()")
                        }</span>
                        <span class="cov8" title="1">key, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">property, err := readPropertyInterface(context.Inputs, key.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return property, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$input() expects 1 argument, found %d", len(n.Args))</span>
        case "output":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        if context.Outputs == nil || len(context.Outputs) == 0 </span><span class="cov0" title="0">{
                                //return nil, errors.New("an output collection is needed to evaluate $output()")
                                return "", nil
                        }</span>
                        <span class="cov8" title="1">step, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">key, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if _, ok := context.Outputs[step.(string)]; !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("step %s is not found in output collection", step.(string))
                        }</span>
                        <span class="cov8" title="1">property, err := readPropertyInterface(context.Outputs[step.(string)], key.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return property, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$output() expects 2 argument, found %d", len(n.Args))</span>
        case "equal":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        v1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">v2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return compareInterfaces(v1, v2), nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$equal() expects 2 arguments, found %d", len(n.Args))</span>
        case "and":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return andBools(val1, val2)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$and() expects 2 arguments, found %d", len(n.Args))</span>
        case "or":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return orBools(val1, val2)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$or() expects 2 arguments, found %d", len(n.Args))</span>
        case "not":<span class="cov8" title="1">
                if len(n.Args) == 1 </span><span class="cov8" title="1">{
                        val, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return notBool(val)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$not() expects 1 argument, found %d", len(n.Args))</span>
        case "gt":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fVal1, ok1 := toNumber(val1); ok1 </span><span class="cov8" title="1">{
                                if fVal2, ok2 := toNumber((val2)); ok2 </span><span class="cov8" title="1">{
                                        return fVal1 &gt; fVal2, nil
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val2)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val1)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$gt() expects 2 arguments, found %d", len(n.Args))</span>
        case "ge":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fVal1, ok1 := toNumber(val1); ok1 </span><span class="cov8" title="1">{
                                if fVal2, ok2 := toNumber((val2)); ok2 </span><span class="cov8" title="1">{
                                        return fVal1 &gt;= fVal2, nil
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val2)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val1)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$ge() expects 2 arguments, found %d", len(n.Args))</span>
        case "if":<span class="cov8" title="1">
                if len(n.Args) == 3 </span><span class="cov8" title="1">{
                        cond, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fmt.Sprintf("%v", cond) == "true" </span><span class="cov8" title="1">{
                                return n.Args[1].Eval(context)
                        }</span> else<span class="cov8" title="1"> {
                                return n.Args[2].Eval(context)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$if() expects 3 arguments, found %d", len(n.Args))</span>
        case "in":<span class="cov8" title="1">
                if len(n.Args) &gt;= 2 </span><span class="cov8" title="1">{
                        val, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">for i := 1; i &lt; len(n.Args); i++ </span><span class="cov8" title="1">{
                                v, err := n.Args[i].Eval(context)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if fmt.Sprintf("%v", val) == fmt.Sprintf("%v", v) </span><span class="cov8" title="1">{
                                        return true, nil
                                }</span>
                        }
                        <span class="cov8" title="1">return false, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$in() expects at least 2 arguments, found %d", len(n.Args))</span>
        case "lt":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fVal1, ok1 := toNumber(val1); ok1 </span><span class="cov8" title="1">{
                                if fVal2, ok2 := toNumber((val2)); ok2 </span><span class="cov8" title="1">{
                                        return fVal1 &lt; fVal2, nil
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val2)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val1)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$lt() expects 2 arguments, found %d", len(n.Args))</span>
        case "between":<span class="cov8" title="1">
                if len(n.Args) == 3 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val3, err := n.Args[2].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fVal1, ok1 := toNumber(val1); ok1 </span><span class="cov8" title="1">{
                                if fVal2, ok2 := toNumber((val2)); ok2 </span><span class="cov8" title="1">{
                                        if fVal3, ok2 := toNumber((val3)); ok2 </span><span class="cov8" title="1">{
                                                return fVal1 &gt;= fVal2 &amp;&amp; fVal1 &lt;= fVal3, nil
                                        }</span>
                                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val3)</span>
                                }
                                <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val2)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val1)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$le() expects 2 arguments, found %d", len(n.Args))</span>
        case "le":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        val1, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val2, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fVal1, ok1 := toNumber(val1); ok1 </span><span class="cov8" title="1">{
                                if fVal2, ok2 := toNumber((val2)); ok2 </span><span class="cov8" title="1">{
                                        return fVal1 &lt;= fVal2, nil
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val2)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%v is not a valid number", val1)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$le() expects 2 arguments, found %d", len(n.Args))</span>
        case "config":<span class="cov8" title="1">
                if len(n.Args) &gt;= 2 </span><span class="cov8" title="1">{
                        if context.ConfigProvider == nil </span><span class="cov8" title="1">{
                                return nil, errors.New("a config provider is needed to evaluate $config()")
                        }</span>
                        <span class="cov8" title="1">obj, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">field, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">var overlays []string
                        if len(n.Args) &gt; 2 </span><span class="cov0" title="0">{
                                for i := 2; i &lt; len(n.Args); i++ </span><span class="cov0" title="0">{
                                        overlay, err := n.Args[i].Eval(context)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">overlays = append(overlays, overlay.(string))</span>
                                }
                        }

                        <span class="cov8" title="1">return context.ConfigProvider.Get(obj.(string), field.(string), overlays, context)</span>
                }
                <span class="cov8" title="1">return nil, fmt.Errorf("$config() expects 2 arguments, found %d", len(n.Args))</span>
        case "secret":<span class="cov8" title="1">
                if len(n.Args) == 2 </span><span class="cov8" title="1">{
                        if context.SecretProvider == nil </span><span class="cov8" title="1">{
                                return nil, errors.New("a secret provider is needed to evaluate $secret()")
                        }</span>
                        <span class="cov8" title="1">obj, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">field, err := n.Args[1].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return context.SecretProvider.Get(obj.(string), field.(string))</span>
                }
                <span class="cov8" title="1">return nil, fmt.Errorf("$secret() expects 2 arguments, found %d", len(n.Args))</span>
        case "instance":<span class="cov8" title="1">
                if len(n.Args) == 0 </span><span class="cov8" title="1">{
                        if deploymentSpec, ok := context.DeploymentSpec.(model.DeploymentSpec); ok </span><span class="cov8" title="1">{
                                return deploymentSpec.Instance.Name, nil
                        }</span>
                        <span class="cov0" title="0">return nil, errors.New("deployment spec is not found")</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$instance() expects 0 arguments, found %d", len(n.Args))</span>
        case "val", "context":<span class="cov8" title="1">
                if len(n.Args) == 0 </span><span class="cov8" title="1">{
                        return context.Value, nil
                }</span>
                <span class="cov8" title="1">if len(n.Args) == 1 </span><span class="cov8" title="1">{
                        obj, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">path := obj.(string)
                        if strings.HasPrefix(path, "$") || strings.HasPrefix(path, "{$") </span><span class="cov8" title="1">{
                                result, err := JsonPathQuery(context.Value, obj.(string))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">return result, nil</span>
                        } else<span class="cov8" title="1"> {
                                if mobj, ok := context.Value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        if v, ok := mobj[path]; ok </span><span class="cov8" title="1">{
                                                return v, nil
                                        }</span> else<span class="cov0" title="0"> {
                                                return nil, fmt.Errorf("key %s is not found in context value", path)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("context value '%v' is not a map", context.Value)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$val() or $context() expects 0 or 1 argument, found %d", len(n.Args))</span>
        case "json":<span class="cov0" title="0">
                if len(n.Args) == 1 </span><span class="cov0" title="0">{
                        val, err := n.Args[0].Eval(context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">jData, err := json.Marshal(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return string(jData), nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("$json() expects 1 argument, fount %d", len(n.Args))</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("invalid function name: '%s'", n.Name)</span>
}

type Parser struct {
        Segments     []string
        OriginalText string
}

type ExpressionParser struct {
        s     *scanner.Scanner
        token Token
        text  string
}

func NewParser(text string) *Parser <span class="cov8" title="1">{
        re := regexp.MustCompile(`(\${{.*?}})`)
        loc := re.FindAllStringIndex(text, -1)

        segments := make([]string, 0, len(loc)*2+1)
        start := 0
        for _, l := range loc </span><span class="cov8" title="1">{
                if start != l[0] </span><span class="cov8" title="1">{
                        segments = append(segments, text[start:l[0]])
                }</span>
                <span class="cov8" title="1">segments = append(segments, text[l[0]:l[1]])
                start = l[1]</span>
        }
        <span class="cov8" title="1">if start &lt; len(text) </span><span class="cov8" title="1">{
                segments = append(segments, text[start:])
        }</span>

        <span class="cov8" title="1">p := &amp;Parser{
                Segments: segments,
        }
        return p</span>
}

func (p *Parser) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        results := make([]interface{}, 0)
        for _, s := range p.Segments </span><span class="cov8" title="1">{
                if strings.HasPrefix(s, "${{") &amp;&amp; strings.HasSuffix(s, "}}") </span><span class="cov8" title="1">{
                        text := s[3 : len(s)-2]
                        parser := newExpressionParser(text)
                        n, err := parser.Eval(context)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">results = append(results, n)</span>
                } else<span class="cov8" title="1"> {
                        results = append(results, s)
                }</span>
        }
        <span class="cov8" title="1">if len(results) == 1 </span><span class="cov8" title="1">{
                return results[0], nil
        }</span>
        //join the results as string
        <span class="cov8" title="1">var ret interface{}
        for _, v := range results </span><span class="cov8" title="1">{
                if ret == nil </span><span class="cov8" title="1">{
                        ret = fmt.Sprintf("%v", v)
                }</span> else<span class="cov8" title="1"> {
                        ret = fmt.Sprintf("%v%v", ret, v)
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func newExpressionParser(text string) *ExpressionParser <span class="cov8" title="1">{
        var s scanner.Scanner // TODO: this is mostly used to scan go code, we should use a custom scanner
        s.Init(strings.NewReader(strings.TrimSpace(text)))
        s.Mode = scanner.ScanIdents | scanner.ScanChars | scanner.ScanStrings | scanner.ScanInts
        p := &amp;ExpressionParser{
                s:    &amp;s,
                text: text,
        }
        p.next()
        return p
}</span>

func (p *ExpressionParser) Eval(context utils.EvaluationContext) (interface{}, error) <span class="cov8" title="1">{
        var ret interface{}
        for </span><span class="cov8" title="1">{
                n, err := p.expr(false)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, ok := n.(*NullNode); !ok </span><span class="cov8" title="1">{
                        v, r := n.Eval(context)
                        if r != nil </span><span class="cov8" title="1">{
                                return "", r
                        }</span>
                        <span class="cov8" title="1">if vt, ok := v.([]string); ok </span><span class="cov0" title="0">{
                                if ret == nil </span><span class="cov0" title="0">{
                                        ret = vt
                                }</span> else<span class="cov0" title="0"> if vr, o := ret.([]string); o </span><span class="cov0" title="0">{
                                        vr = append(vr, vt...)
                                        ret = vr
                                }</span> else<span class="cov0" title="0"> {
                                        jData, _ := json.Marshal(v)
                                        ret = fmt.Sprintf("%v%v", ret, string(jData))
                                }</span>
                        } else<span class="cov8" title="1"> if vt, ok := v.([]interface{}); ok </span><span class="cov8" title="1">{
                                if ret == nil </span><span class="cov8" title="1">{
                                        ret = vt
                                }</span> else<span class="cov0" title="0"> if vr, o := ret.([]interface{}); o </span><span class="cov0" title="0">{
                                        vr = append(vr, vt...)
                                        ret = vr
                                }</span> else<span class="cov0" title="0"> {
                                        jData, _ := json.Marshal(v)
                                        ret = fmt.Sprintf("%v%v", ret, string(jData))
                                }</span>
                        } else<span class="cov8" title="1"> if vt, ok := v.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if ret == nil </span><span class="cov0" title="0">{
                                        ret = vt
                                }</span> else<span class="cov0" title="0"> if vr, o := ret.(map[string]interface{}); o </span><span class="cov0" title="0">{
                                        for k, v := range vt </span><span class="cov0" title="0">{
                                                vr[k] = v
                                        }</span>
                                        <span class="cov0" title="0">ret = vr</span>
                                } else<span class="cov0" title="0"> {
                                        jData, _ := json.Marshal(v)
                                        ret = fmt.Sprintf("%v%v", ret, string(jData))
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if ret == nil </span><span class="cov8" title="1">{
                                        ret = v
                                }</span> else<span class="cov8" title="1"> {
                                        ret = fmt.Sprintf("%v%v", ret, v)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return ret, nil
                }</span>
                <span class="cov8" title="1">p.next()</span>
        }
}

func (p *ExpressionParser) next() <span class="cov8" title="1">{
        p.token = p.scan()
}</span>

func (p *ExpressionParser) scan() Token <span class="cov8" title="1">{
        tok := p.s.Scan()
        p.text = p.s.TokenText()
        switch tok </span>{
        case scanner.EOF:<span class="cov8" title="1">
                return EOF</span>
        case scanner.Float:<span class="cov0" title="0">
                return NUMBER</span>
        case scanner.Ident:<span class="cov8" title="1">
                return IDENT</span>
        case '$':<span class="cov8" title="1">
                return DOLLAR</span>
        case '(':<span class="cov8" title="1">
                return OPAREN</span>
        case ')':<span class="cov8" title="1">
                return CPAREN</span>
        case '[':<span class="cov8" title="1">
                return OBRACKET</span>
        case ']':<span class="cov8" title="1">
                return CBRACKET</span>
        case '{':<span class="cov8" title="1">
                return OCURLY</span>
        case '}':<span class="cov8" title="1">
                return CCURLY</span>
        case '+':<span class="cov8" title="1">
                return PLUS</span>
        case '-':<span class="cov8" title="1">
                return MINUS</span>
        case '*':<span class="cov8" title="1">
                return MULT</span>
        case '/':<span class="cov8" title="1">
                return DIV</span>
        case '\\':<span class="cov8" title="1">
                return SLASH</span>
        case ',':<span class="cov8" title="1">
                return COMMA</span>
        case '.':<span class="cov8" title="1">
                return PERIOD</span>
        case ':':<span class="cov8" title="1">
                return COLON</span>
        case '?':<span class="cov8" title="1">
                return QUESTION</span>
        case '=':<span class="cov8" title="1">
                return EQUAL</span>
        case '&amp;':<span class="cov8" title="1">
                return AMPHERSAND</span>
        case '~':<span class="cov8" title="1">
                return TILDE</span>
        }
        <span class="cov8" title="1">if _, err := strconv.ParseInt(p.text, 10, 64); err == nil </span><span class="cov8" title="1">{
                return INT
        }</span>

        <span class="cov8" title="1">if _, err := strconv.ParseFloat(p.text, 64); err == nil </span><span class="cov0" title="0">{
                return NUMBER
        }</span>
        <span class="cov8" title="1">return IDENT</span>
}

func (p *ExpressionParser) match(t Token) error <span class="cov8" title="1">{
        if p.token == t </span><span class="cov8" title="1">{
                p.next()
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("expected %T, got %s", t, p.text)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *ExpressionParser) primary() (Node, error) <span class="cov8" title="1">{
        switch p.token </span>{
        case INT:<span class="cov8" title="1">
                v, _ := strconv.ParseInt(p.text, 10, 64)
                p.next()
                return &amp;IntNode{v}, nil</span>
        case NUMBER:<span class="cov0" title="0">
                v, _ := strconv.ParseFloat(p.text, 64)
                p.next()
                return &amp;NumberNode{v}, nil</span>
        case DOLLAR:<span class="cov8" title="1">
                return p.function()</span>
        case OPAREN:<span class="cov8" title="1">
                p.next()
                node, err := p.expr(false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">expr := node
                if err := p.match(CPAREN); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return expr, nil</span>
        case OBRACKET:<span class="cov8" title="1">
                p.next()
                node, err := p.expr(false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">bexpr := node
                if err := p.match(CBRACKET); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;UnaryNode{OBRACKET, bexpr}, nil</span>
        case OCURLY:<span class="cov8" title="1">
                p.next()
                node, err := p.expr(false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cexpr := node
                if err := p.match(CCURLY); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;UnaryNode{OCURLY, cexpr}, nil</span>
        case PLUS:<span class="cov8" title="1">
                p.next()
                node, err := p.primary()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;UnaryNode{PLUS, node}, nil</span>
        case MINUS:<span class="cov8" title="1">
                p.next()
                node, err := p.primary()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;UnaryNode{MINUS, node}, nil</span>
        case IDENT:<span class="cov8" title="1">
                v := p.text
                p.next()
                return &amp;IdentifierNode{v}, nil</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func (p *ExpressionParser) factor() (Node, error) <span class="cov8" title="1">{
        node, err := p.primary()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                switch p.token </span>{
                case MULT:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{MULT, node, n}</span>
                case DIV:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{DIV, node, n}</span>
                case SLASH:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{SLASH, node, n}</span>
                case PERIOD:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{PERIOD, node, n}</span>
                case COLON:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{COLON, node, n}</span>
                case QUESTION:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{QUESTION, node, n}</span>
                case EQUAL:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{EQUAL, node, n}</span>
                case TILDE:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{TILDE, node, n}</span>
                case AMPHERSAND:<span class="cov8" title="1">
                        p.next()
                        n, err := p.primary()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{AMPHERSAND, node, n}</span>
                default:<span class="cov8" title="1">
                        return node, nil</span>
                }
        }
}

func (p *ExpressionParser) expr(inFunc bool) (Node, error) <span class="cov8" title="1">{
        node, err := p.factor()
        if node == nil || err != nil </span><span class="cov8" title="1">{
                return &amp;NullNode{}, err
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                switch p.token </span>{
                case PLUS:<span class="cov8" title="1">
                        p.next()
                        f, err := p.factor()
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;NullNode{}, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{PLUS, node, f}</span>
                case MINUS:<span class="cov8" title="1">
                        p.next()
                        f, err := p.factor()
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;NullNode{}, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;BinaryNode{MINUS, node, f}</span>
                case COMMA:<span class="cov8" title="1">
                        if !inFunc </span><span class="cov8" title="1">{
                                p.next()
                                f, err := p.factor()
                                if err != nil </span><span class="cov0" title="0">{
                                        return &amp;NullNode{}, err
                                }</span>
                                <span class="cov8" title="1">node = &amp;BinaryNode{COMMA, node, f}</span>
                        } else<span class="cov8" title="1"> {
                                return node, nil
                        }</span>
                case OPAREN:<span class="cov0" title="0">
                        p.next()
                        node, err := p.expr(false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">expr := node
                        if err := p.match(CPAREN); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return expr, nil</span>
                default:<span class="cov8" title="1">
                        return node, nil</span>
                }
        }
}

func (p *ExpressionParser) function() (Node, error) <span class="cov8" title="1">{
        err := p.match(DOLLAR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">name := p.text
        err = p.match(IDENT)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = p.match(OPAREN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">args := []Node{}
        for p.token != CPAREN </span><span class="cov8" title="1">{
                node, err := p.expr(true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, ok := node.(*NullNode); ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid argument")
                }</span>
                <span class="cov8" title="1">args = append(args, node)
                if p.token == COMMA </span><span class="cov8" title="1">{
                        p.next()
                }</span>
        }
        <span class="cov8" title="1">err = p.match(CPAREN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;FunctionNode{name, args}, nil</span>
}

func EvaluateDeployment(context utils.EvaluationContext) (model.DeploymentSpec, error) <span class="cov8" title="1">{
        if deploymentSpec, ok := context.DeploymentSpec.(model.DeploymentSpec); ok </span><span class="cov8" title="1">{
                for ic, c := range deploymentSpec.Solution.Components </span><span class="cov8" title="1">{

                        val, err := evalProperties(context, c.Metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return deploymentSpec, err
                        }</span>
                        <span class="cov8" title="1">if val != nil </span><span class="cov8" title="1">{
                                metadata, ok := val.(map[string]string)
                                if !ok </span><span class="cov0" title="0">{
                                        return deploymentSpec, fmt.Errorf("metadata must be a map")
                                }</span>
                                <span class="cov8" title="1">stringMap := make(map[string]string)
                                for k, v := range metadata </span><span class="cov8" title="1">{
                                        stringMap[k] = fmt.Sprintf("%v", v)
                                }</span>
                                <span class="cov8" title="1">deploymentSpec.Solution.Components[ic].Metadata = stringMap</span>
                        }

                        <span class="cov8" title="1">val, err = evalProperties(context, c.Properties)
                        if err != nil </span><span class="cov0" title="0">{
                                return deploymentSpec, err
                        }</span>
                        <span class="cov8" title="1">props, ok := val.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return deploymentSpec, fmt.Errorf("properties must be a map")
                        }</span>
                        <span class="cov8" title="1">deploymentSpec.Solution.Components[ic].Properties = props</span>
                }
                <span class="cov8" title="1">return deploymentSpec, nil</span>
        }
        <span class="cov0" title="0">return model.DeploymentSpec{}, errors.New("deployment spec is not found")</span>
}
func compareInterfaces(a, b interface{}) bool <span class="cov8" title="1">{
        if reflect.TypeOf(a) == reflect.TypeOf(b) </span><span class="cov8" title="1">{
                switch a.(type) </span>{
                case int, int8, int16, int32, int64:<span class="cov8" title="1">
                        return a.(int64) == b.(int64)</span>
                case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                        return a.(uint64) == b.(uint64)</span>
                case float32, float64:<span class="cov0" title="0">
                        return math.Abs(a.(float64)-b.(float64)) &lt; 1e-9</span>
                case string:<span class="cov8" title="1">
                        return a.(string) == b.(string)</span>
                case bool:<span class="cov0" title="0">
                        return a.(bool) == b.(bool)</span>
                }
        }
        <span class="cov8" title="1">if aState, ok := a.(v1alpha2.State); ok </span><span class="cov0" title="0">{
                a = int(aState)
        }</span>
        <span class="cov8" title="1">if bState, ok := b.(v1alpha2.State); ok </span><span class="cov0" title="0">{
                b = int(bState)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%v", a) == fmt.Sprintf("%v", b)</span>
}
func andBools(a, b interface{}) (bool, error) <span class="cov8" title="1">{
        if aBool, ok := toBool(a); ok </span><span class="cov8" title="1">{
                if bBool, ok := toBool(b); ok </span><span class="cov8" title="1">{
                        return aBool &amp;&amp; bBool, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("%v is not a boolean value", b)</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("%v is not a boolean value", a)</span>
}
func orBools(a, b interface{}) (bool, error) <span class="cov8" title="1">{
        if aBool, ok := toBool(a); ok </span><span class="cov8" title="1">{
                if bBool, ok := toBool(b); ok </span><span class="cov8" title="1">{
                        return aBool || bBool, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("%v is not a boolean value", b)</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("%v is not a boolean value", a)</span>
}
func notBool(a interface{}) (bool, error) <span class="cov8" title="1">{
        if aBool, ok := toBool(a); ok </span><span class="cov8" title="1">{
                return !aBool, nil
        }</span>
        <span class="cov0" title="0">return false, fmt.Errorf("%v is not a boolean value", a)</span>
}
func toBool(val interface{}) (bool, bool) <span class="cov8" title="1">{
        switch val := val.(type) </span>{
        case bool:<span class="cov8" title="1">
                return val, true</span>
        case string:<span class="cov8" title="1">
                boolVal, err := strconv.ParseBool(val)
                if err == nil </span><span class="cov8" title="1">{
                        return boolVal, true
                }</span>
        }
        <span class="cov0" title="0">return false, false</span>
}
func toNumber(val interface{}) (float64, bool) <span class="cov8" title="1">{
        num, err := strconv.ParseFloat(fmt.Sprintf("%v", val), 64)
        if err == nil </span><span class="cov8" title="1">{
                return num, true
        }</span>
        <span class="cov0" title="0">return 0, false</span>
}
func evalProperties(context utils.EvaluationContext, properties interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch p := properties.(type) </span>{
        case map[string]string:<span class="cov8" title="1">
                for k, v := range p </span><span class="cov8" title="1">{
                        val, err := evalProperties(context, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">p[k] = FormatAsString(val)</span>
                }
        case map[string]interface{}:<span class="cov8" title="1">
                for k, v := range p </span><span class="cov8" title="1">{
                        val, err := evalProperties(context, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">p[k] = val</span>
                }
        case []interface{}:<span class="cov0" title="0">
                for i, v := range p </span><span class="cov0" title="0">{
                        val, err := evalProperties(context, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">p[i] = val</span>
                }
        case string:<span class="cov8" title="1">
                var js interface{}
                err := json.Unmarshal([]byte(p), &amp;js)
                if err == nil </span><span class="cov0" title="0">{
                        modified, err := enumerateProperties(js, context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">jsBytes, err := json.Marshal(modified)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return string(jsBytes), nil</span>
                }
                <span class="cov8" title="1">parser := NewParser(p)
                val, err := parser.Eval(context)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">properties = val</span>
        }
        <span class="cov8" title="1">return properties, nil</span>
}

func enumerateProperties(js interface{}, context utils.EvaluationContext) (interface{}, error) <span class="cov0" title="0">{
        switch v := js.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                for key, val := range v </span><span class="cov0" title="0">{
                        if strVal, ok := val.(string); ok </span><span class="cov0" title="0">{
                                parser := NewParser(strVal)
                                val, err := parser.Eval(context)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">v[key] = val</span>
                        } else<span class="cov0" title="0"> {
                                nestedProps, err := enumerateProperties(val, context)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">v[key] = nestedProps</span>
                        }
                }
        case []interface{}:<span class="cov0" title="0">
                for i, val := range v </span><span class="cov0" title="0">{
                        nestedProps, err := enumerateProperties(val, context)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">v[i] = nestedProps</span>
                }
        }
        <span class="cov0" title="0">return js, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package utils

import (
        "fmt"
        "regexp"
        "strconv"

        coa_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
)

type Rule struct {
        Type       string `json:"type,omitempty"`
        Required   bool   `json:"required,omitempty"`
        Pattern    string `json:"pattern,omitempty"`
        Expression string `json:"expression,omitempty"`
}
type Schema struct {
        Rules map[string]Rule `json:"rules,omitempty"`
}

type RuleResult struct {
        Valid bool   `json:"valid"`
        Error string `json:"error,omitempty"`
}

type SchemaResult struct {
        Valid  bool                  `json:"valid"`
        Errors map[string]RuleResult `json:"errors,omitempty"`
}

func (s *Schema) CheckProperties(properties map[string]interface{}, evaluationContext *coa_utils.EvaluationContext) (SchemaResult, error) <span class="cov8" title="1">{
        context := evaluationContext
        if context == nil </span><span class="cov8" title="1">{
                context = &amp;coa_utils.EvaluationContext{}
        }</span>
        <span class="cov8" title="1">ret := SchemaResult{Valid: true, Errors: make(map[string]RuleResult)}
        for k, v := range s.Rules </span><span class="cov8" title="1">{
                if v.Type != "" </span><span class="cov8" title="1">{
                        if val, ok := properties[k]; ok </span><span class="cov8" title="1">{
                                if v.Type == "int" </span><span class="cov8" title="1">{
                                        if _, err := strconv.Atoi(val.(string)); err != nil </span><span class="cov8" title="1">{
                                                ret.Valid = false
                                                ret.Errors[k] = RuleResult{Valid: false, Error: "property is not an int"}
                                        }</span>
                                } else<span class="cov8" title="1"> if v.Type == "float" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseFloat(val.(string), 64); err != nil </span><span class="cov8" title="1">{
                                                ret.Valid = false
                                                ret.Errors[k] = RuleResult{Valid: false, Error: "property is not a float"}
                                        }</span>
                                } else<span class="cov8" title="1"> if v.Type == "bool" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseBool(val.(string)); err != nil </span><span class="cov8" title="1">{
                                                ret.Valid = false
                                                ret.Errors[k] = RuleResult{Valid: false, Error: "property is not a bool"}
                                        }</span>
                                } else<span class="cov8" title="1"> if v.Type == "uint" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseUint(val.(string), 10, 64); err != nil </span><span class="cov8" title="1">{
                                                ret.Valid = false
                                                ret.Errors[k] = RuleResult{Valid: false, Error: "property is not a uint"}
                                        }</span>
                                } else<span class="cov8" title="1"> if v.Type == "string" </span>{<span class="cov8" title="1">
                                        // Do nothing
                                }</span> else<span class="cov8" title="1"> {
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: "unknown type"}
                                }</span>
                        }
                }
                <span class="cov8" title="1">if v.Required </span><span class="cov8" title="1">{
                        if _, ok := properties[k]; !ok </span><span class="cov8" title="1">{
                                ret.Valid = false
                                ret.Errors[k] = RuleResult{Valid: false, Error: "missing required property"}
                        }</span>
                }
                <span class="cov8" title="1">if v.Pattern != "" </span><span class="cov8" title="1">{
                        if val, ok := properties[k]; ok </span><span class="cov8" title="1">{
                                match, err := s.matchPattern(val.(string), v.Pattern)
                                if err != nil </span><span class="cov0" title="0">{
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: "error matching pattern: " + err.Error()}
                                }</span>
                                <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: fmt.Sprintf("property does not match pattern: %s", v.Pattern)}
                                }</span>
                        }
                }
                <span class="cov8" title="1">if v.Expression != "" </span><span class="cov8" title="1">{
                        if val, ok := properties[k]; ok </span><span class="cov8" title="1">{
                                context.Value = val
                                parser := NewParser(v.Expression)
                                res, err := parser.Eval(*context)
                                if err != nil </span><span class="cov0" title="0">{
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: "error evaluating expression: " + err.Error()}
                                }</span>
                                <span class="cov8" title="1">if res != "true" &amp;&amp; res != "false" &amp;&amp; res != true &amp;&amp; res != false </span><span class="cov0" title="0">{
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: "expression does not evaluate to boolean"}
                                }</span>
                                <span class="cov8" title="1">if res != "true" &amp;&amp; res != true </span><span class="cov8" title="1">{
                                        ret.Valid = false
                                        ret.Errors[k] = RuleResult{Valid: false, Error: fmt.Sprintf("property does not match expression: %s", v.Expression)}
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ret, nil</span>
}
func (s *Schema) matchPattern(value string, pattern string) (bool, error) <span class="cov8" title="1">{
        regexPattern := pattern
        switch pattern </span>{
        case "&lt;email&gt;":<span class="cov8" title="1">
                regexPattern = `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$`</span>
        case "&lt;url&gt;":<span class="cov0" title="0">
                regexPattern = `^https?://.*$`</span>
        case "&lt;uuid&gt;":<span class="cov0" title="0">
                regexPattern = `^[a-f\d]{8}(-[a-f\d]{4}){4}[a-f\d]{8}$`</span>
        case "&lt;dns-label&gt;":<span class="cov0" title="0">
                regexPattern = `^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`</span>
        case "&lt;dns-name&gt;":<span class="cov0" title="0">
                regexPattern = `^([a-z0-9]([-a-z0-9]*[a-z0-9])?\.)+[a-z]{2,}$`</span>
        case "&lt;ip4&gt;":<span class="cov0" title="0">
                regexPattern = `^(\d{1,3}\.){3}\d{1,3}$`</span>
        case "&lt;ip4-range&gt;":<span class="cov0" title="0">
                regexPattern = `^(\d{1,3}\.){3}\d{1,3}-(\d{1,3}\.){3}\d{1,3}$`</span>
        case "&lt;port&gt;":<span class="cov0" title="0">
                regexPattern = `^\d{1,5}$`</span>
        case "&lt;mac-address&gt;":<span class="cov0" title="0">
                regexPattern = `^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$`</span>
        case "&lt;cidr&gt;":<span class="cov0" title="0">
                regexPattern = `^(\d{1,3}\.){3}\d{1,3}/\d{1,2}$`</span>
        case "&lt;ip6&gt;":<span class="cov0" title="0">
                regexPattern = `^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$`</span>
        case "&lt;ip6-range&gt;":<span class="cov0" title="0">
                regexPattern = `^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}-([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$`</span>
        }
        <span class="cov8" title="1">matched, err := regexp.MatchString(regexPattern, value)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return matched, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package utils

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

const (
        SymphonyAPIAddressBase = "http://symphony-service:8080/v1alpha2/"
)

type authRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}
type authResponse struct {
        AccessToken string   `json:"accessToken"`
        TokenType   string   `json:"tokenType"`
        Username    string   `json:"username"`
        Roles       []string `json:"roles"`
}

// We shouldn't use specific error types
// SummarySpecError represents an error that includes a SummarySpec in its message
// field.
// type SummarySpecError struct {
//         Code    string `json:"code"`
//         Message string `json:"message"`
// }

// func (e *SummarySpecError) Error() string {
//         return fmt.Sprintf(
//                 "failed to invoke Symphony API: [%s] - %s",
//                 e.Code,
//                 e.Message,
//         )
// }

var log = logger.NewLogger("coa.runtime")

func GetInstancesForAllScope(context context.Context, baseUrl string, user string, password string) ([]model.InstanceState, error) <span class="cov0" title="0">{
        ret := make([]model.InstanceState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "instances", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func GetInstances(context context.Context, baseUrl string, user string, password string, scope string) ([]model.InstanceState, error) <span class="cov0" title="0">{
        ret := make([]model.InstanceState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">path := "instances?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func GetSites(context context.Context, baseUrl string, user string, password string) ([]model.SiteState, error) <span class="cov0" title="0">{
        ret := make([]model.SiteState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "federation/registry", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}
func SyncActivationStatus(context context.Context, baseUrl string, user string, password string, status model.ActivationStatus) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">jData, _ := json.Marshal(status)
        _, err = callRestAPI(context, baseUrl, "federation/sync", "POST", jData, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func GetCatalogs(context context.Context, baseUrl string, user string, password string) ([]model.CatalogState, error) <span class="cov0" title="0">{
        ret := make([]model.CatalogState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "catalogs/registry", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">return ret, nil</span>
}
func GetCatalog(context context.Context, baseUrl string, catalog string, user string, password string) (model.CatalogState, error) <span class="cov0" title="0">{
        ret := model.CatalogState{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">catalogName := catalog
        if strings.HasPrefix(catalogName, "&lt;") &amp;&amp; strings.HasSuffix(catalogName, "&gt;") </span><span class="cov0" title="0">{
                catalogName = catalogName[1 : len(catalogName)-1]
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "catalogs/registry/"+catalogName, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func GetCampaign(context context.Context, baseUrl string, campaign string, user string, password string) (model.CampaignState, error) <span class="cov0" title="0">{
        ret := model.CampaignState{}
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "campaigns/"+campaign, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func PublishActivationEvent(context context.Context, baseUrl string, user string, password string, event v1alpha2.ActivationData) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">jData, _ := json.Marshal(event)
        _, err = callRestAPI(context, baseUrl, "jobs", "POST", jData, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func GetABatchForSite(context context.Context, baseUrl string, site string, user string, password string) (model.SyncPackage, error) <span class="cov0" title="0">{
        ret := model.SyncPackage{}
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "federation/sync/"+site+"?count=10", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func GetActivation(context context.Context, baseUrl string, activation string, user string, password string) (model.ActivationState, error) <span class="cov0" title="0">{
        ret := model.ActivationState{}
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "activations/registry/"+activation, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func ReportActivationStatus(context context.Context, baseUrl string, name string, user string, password string, activation model.ActivationStatus) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">jData, _ := json.Marshal(activation)
        _, err = callRestAPI(context, baseUrl, "activations/status/"+name, "POST", jData, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func GetInstance(context context.Context, baseUrl string, instance string, user string, password string, scope string) (model.InstanceState, error) <span class="cov0" title="0">{
        ret := model.InstanceState{}
        token, err := auth(context, baseUrl, user, password)

        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">path := "instances/" + instance
        path = path + "?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}
func UpsertCatalog(context context.Context, baseUrl string, catalog string, user string, password string, payload []byte) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = callRestAPI(context, baseUrl, "catalogs/registry/"+catalog, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func CreateInstance(context context.Context, baseUrl string, instance string, user string, password string, payload []byte, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := "instances/" + instance
        path = path + "?scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DeleteCatalog(context context.Context, baseUrl string, catalog string, user string, password string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = callRestAPI(context, baseUrl, "catalogs/registry/"+catalog, "DELETE", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DeleteInstance(context context.Context, baseUrl string, instance string, user string, password string, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "instances/" + instance
        path = path + "?direct=true&amp;scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "DELETE", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DeleteTarget(context context.Context, baseUrl string, target string, user string, password string, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "targets/registry/" + target
        path = path + "?direct=true&amp;scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "DELETE", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetSolutionsForAllScope(context context.Context, baseUrl string, user string, password string) ([]model.SolutionState, error) <span class="cov0" title="0">{
        ret := make([]model.SolutionState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "solutions", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func GetSolutions(context context.Context, baseUrl string, user string, password string, scope string) ([]model.SolutionState, error) <span class="cov0" title="0">{
        ret := make([]model.SolutionState, 0)
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">path := "solution" + "?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func GetSolution(context context.Context, baseUrl string, solution string, user string, password string, scope string) (model.SolutionState, error) <span class="cov0" title="0">{
        ret := model.SolutionState{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">path := "solutions/" + solution
        path = path + "?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func UpsertTarget(context context.Context, baseUrl string, solution string, user string, password string, payload []byte, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "targets/registry/" + solution
        path = path + "?scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func UpsertSolution(context context.Context, baseUrl string, solution string, user string, password string, payload []byte, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "solutions/" + solution
        path = path + "?scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DeleteSolution(context context.Context, baseUrl string, solution string, user string, password string, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "solutions/" + solution
        path = path + "?scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "DELETE", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetTarget(context context.Context, baseUrl string, target string, user string, password string, scope string) (model.TargetState, error) <span class="cov0" title="0">{
        ret := model.TargetState{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">path := "targets/registry/" + target
        path = path + "?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func GetTargetsForAllScope(context context.Context, baseUrl string, user string, password string) ([]model.TargetState, error) <span class="cov0" title="0">{
        ret := []model.TargetState{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">response, err := callRestAPI(context, baseUrl, "targets/registry", "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func GetTargets(context context.Context, baseUrl string, user string, password string, scope string) ([]model.TargetState, error) <span class="cov0" title="0">{
        ret := []model.TargetState{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">path := "targets/registry"
        path = path + "?scope=" + scope
        response, err := callRestAPI(context, baseUrl, path, "GET", nil, token)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(response, &amp;ret)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func UpdateSite(context context.Context, baseUrl string, site string, user string, password string, payload []byte) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = callRestAPI(context, baseUrl, "federation/status/"+site, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CreateTarget(context context.Context, baseUrl string, target string, user string, password string, payload []byte, scope string) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "targets/registry/" + target
        path = path + "?scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Info("&gt;&gt;&gt;&gt;&gt;CreateTarget Succeed: " + target + " " + scope)
        return nil</span>
}

func MatchTargets(instance model.InstanceState, targets []model.TargetState) []model.TargetState <span class="cov8" title="1">{
        ret := make(map[string]model.TargetState)
        if instance.Spec.Target.Name != "" </span><span class="cov8" title="1">{
                for _, t := range targets </span><span class="cov8" title="1">{
                        if matchString(instance.Spec.Target.Name, t.Id) </span><span class="cov8" title="1">{
                                ret[t.Id] = t
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(instance.Spec.Target.Selector) &gt; 0 </span><span class="cov8" title="1">{
                for _, t := range targets </span><span class="cov8" title="1">{
                        fullMatch := true
                        for k, v := range instance.Spec.Target.Selector </span><span class="cov8" title="1">{
                                if tv, ok := t.Spec.Properties[k]; !ok || !matchString(v, tv) </span><span class="cov8" title="1">{
                                        fullMatch = false
                                }</span>
                        }

                        <span class="cov8" title="1">if fullMatch </span><span class="cov8" title="1">{
                                ret[t.Id] = t
                        }</span>
                }
        }

        <span class="cov8" title="1">slice := make([]model.TargetState, 0, len(ret))
        for _, v := range ret </span><span class="cov8" title="1">{
                slice = append(slice, v)
        }</span>

        <span class="cov8" title="1">return slice</span>
}

func CreateSymphonyDeploymentFromTarget(target model.TargetState) (model.DeploymentSpec, error) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s-%s", "target-runtime", target.Id)
        scope := target.Spec.Scope

        ret := model.DeploymentSpec{}
        solution := model.SolutionSpec{
                DisplayName: key,
                Scope:       scope,
                Components:  make([]model.ComponentSpec, 0),
                Metadata:    make(map[string]string, 0),
        }
        for k, v := range target.Spec.Metadata </span><span class="cov8" title="1">{
                solution.Metadata[k] = v
        }</span>

        <span class="cov8" title="1">for _, component := range target.Spec.Components </span><span class="cov8" title="1">{
                var c model.ComponentSpec
                data, _ := json.Marshal(component)
                err := json.Unmarshal(data, &amp;c)

                if err != nil </span><span class="cov0" title="0">{
                        return ret, err
                }</span>
                <span class="cov8" title="1">solution.Components = append(solution.Components, c)</span>
        }

        <span class="cov8" title="1">targets := make(map[string]model.TargetSpec)
        var t model.TargetSpec
        data, _ := json.Marshal(target.Spec)
        err := json.Unmarshal(data, &amp;t)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">targets[target.Id] = t

        instance := model.InstanceSpec{
                Name:        key,
                DisplayName: key,
                Scope:       scope,
                Solution:    key,
                Target: model.TargetSelector{
                        Name: target.Id,
                },
        }

        ret.Solution = solution
        ret.Instance = instance
        ret.Targets = targets
        ret.SolutionName = key
        assignments, err := AssignComponentsToTargets(ret.Solution.Components, ret.Targets)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">ret.Assignments = make(map[string]string)
        for k, v := range assignments </span><span class="cov8" title="1">{
                ret.Assignments[k] = v
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func CreateSymphonyDeployment(instance model.InstanceState, solution model.SolutionState, targets []model.TargetState, devices []model.DeviceState) (model.DeploymentSpec, error) <span class="cov8" title="1">{
        ret := model.DeploymentSpec{}
        ret.Generation = instance.Spec.Generation
        // convert instance
        sInstance := instance.Spec

        sInstance.Name = instance.Id
        sInstance.Scope = instance.Spec.Scope

        // convert solution
        sSolution := solution.Spec

        sSolution.DisplayName = solution.Spec.DisplayName
        sSolution.Scope = solution.Spec.Scope

        // convert targets
        sTargets := make(map[string]model.TargetSpec)
        for _, t := range targets </span><span class="cov8" title="1">{
                sTargets[t.Id] = *t.Spec
        }</span>

        //TODO: handle devices
        <span class="cov8" title="1">ret.Solution = *sSolution
        ret.Targets = sTargets
        ret.Instance = *sInstance
        ret.SolutionName = solution.Id

        assignments, err := AssignComponentsToTargets(ret.Solution.Components, ret.Targets)
        if err != nil </span><span class="cov0" title="0">{
                return ret, err
        }</span>

        <span class="cov8" title="1">ret.Assignments = make(map[string]string)
        for k, v := range assignments </span><span class="cov8" title="1">{
                ret.Assignments[k] = v
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func AssignComponentsToTargets(components []model.ComponentSpec, targets map[string]model.TargetSpec) (map[string]string, error) <span class="cov8" title="1">{
        //TODO: evaluate constraints
        ret := make(map[string]string)
        for key, target := range targets </span><span class="cov8" title="1">{
                ret[key] = ""
                for _, component := range components </span><span class="cov8" title="1">{
                        match := true
                        if component.Constraints != "" </span><span class="cov8" title="1">{
                                parser := NewParser(component.Constraints)
                                val, err := parser.Eval(utils.EvaluationContext{Properties: target.Properties})
                                if err != nil </span><span class="cov0" title="0">{
                                        return ret, err
                                }</span>
                                <span class="cov8" title="1">match = (val == "true" || val == true)</span>
                        }
                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                ret[key] += "{" + component.Name + "}"
                        }</span>
                }
        }

        <span class="cov8" title="1">return ret, nil</span>
}
func GetSummary(context context.Context, baseUrl string, user string, password string, id string, scope string) (model.SummaryResult, error) <span class="cov0" title="0">{
        result := model.SummaryResult{}
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">path := "solution/queue"
        path = path + "?instance=" + id + "&amp;scope=" + scope
        ret, err := callRestAPI(context, baseUrl, path, "GET", nil, token) // TODO: We can pass empty token now because is path is a "back-door", as it was designed to be invoked from a trusted environment, which should be also protected with auth
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">if ret != nil </span><span class="cov0" title="0">{
                err = json.Unmarshal(ret, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}
func CatalogHook(context context.Context, baseUrl string, user string, password string, payload []byte) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "federation/k8shook?objectType=catalog"
        _, err = callRestAPI(context, baseUrl, path, "POST", payload, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func QueueJob(context context.Context, baseUrl string, user string, password string, id string, scope string, isDelete bool, isTarget bool) error <span class="cov0" title="0">{
        token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">path := "solution/queue?instance=" + id
        if isDelete </span><span class="cov0" title="0">{
                path += "&amp;delete=true"
        }</span>
        <span class="cov0" title="0">if isTarget </span><span class="cov0" title="0">{
                path += "&amp;target=true"
        }</span>
        <span class="cov0" title="0">path = path + "&amp;scope=" + scope
        _, err = callRestAPI(context, baseUrl, path, "POST", nil, token) // TODO: We can pass empty token now because is path is a "back-door", as it was designed to be invoked from a trusted environment, which should be also protected with auth
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func Reconcile(context context.Context, baseUrl string, user string, password string, deployment model.DeploymentSpec, scope string, isDelete bool) (model.SummarySpec, error) <span class="cov0" title="0">{
        summary := model.SummarySpec{}
        payload, _ := json.Marshal(deployment)

        path := "solution/reconcile" + "?scope=" + scope
        if isDelete </span><span class="cov0" title="0">{
                path = path + "&amp;delete=true"
        }</span>
        <span class="cov0" title="0">token, err := auth(context, baseUrl, user, password)
        if err != nil </span><span class="cov0" title="0">{
                return summary, err
        }</span>
        <span class="cov0" title="0">ret, err := callRestAPI(context, baseUrl, path, "POST", payload, token) // TODO: We can pass empty token now because is path is a "back-door", as it was designed to be invoked from a trusted environment, which should be also protected with auth
        if err != nil </span><span class="cov0" title="0">{
                return summary, err
        }</span>
        <span class="cov0" title="0">if ret != nil </span><span class="cov0" title="0">{
                err = json.Unmarshal(ret, &amp;summary)
                if err != nil </span><span class="cov0" title="0">{
                        return summary, err
                }</span>
        }
        <span class="cov0" title="0">return summary, nil</span>
}
func auth(context context.Context, baseUrl string, user string, password string) (string, error) <span class="cov0" title="0">{
        request := authRequest{Username: user, Password: password}
        requestData, _ := json.Marshal(request)
        ret, err := callRestAPI(context, baseUrl, "users/auth", "POST", requestData, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var response authResponse
        err = json.Unmarshal(ret, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return response.AccessToken, nil</span>
}
func callRestAPI(context context.Context, baseUrl string, route string, method string, payload []byte, token string) ([]byte, error) <span class="cov0" title="0">{
        context, span := observability.StartSpan("Symphony-API-Client", context, &amp;map[string]string{
                "method":      "callRestAPI",
                "http.method": method,
                "http.url":    baseUrl + route,
        })
        var err error = nil
        defer observ_utils.CloseSpanWithError(span, &amp;err)

        log.Infof("Calling Symphony API: %s %s, spanId: %s, traceId: %s", method, baseUrl+route, span.SpanContext().SpanID().String(), span.SpanContext().TraceID().String())

        client := &amp;http.Client{}
        rUrl := baseUrl + route
        var req *http.Request
        if payload != nil </span><span class="cov0" title="0">{
                req, err = http.NewRequestWithContext(context, method, rUrl, bytes.NewBuffer(payload))
                observ_utils.PropagateSpanContextToHttpRequestHeader(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")</span>
        } else<span class="cov0" title="0"> {
                req, err = http.NewRequestWithContext(context, method, rUrl, nil)
                observ_utils.PropagateSpanContextToHttpRequestHeader(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        bodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                // TODO: Can we remove the following? It doesn't seem right.
                // I'm afraid some downstream logic is expecting this behavior, though.
                // if resp.StatusCode == 404 { // API service is already gone
                //         return nil, nil
                // }
                err = v1alpha2.FromHTTPResponseCode(resp.StatusCode, bodyBytes)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = nil
        log.Infof("Symphony API succeeded: %s %s, spanId: %s, traceId: %s", method, baseUrl+route, span.SpanContext().SpanID().String(), span.SpanContext().TraceID().String())

        return bodyBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package utils

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"

        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        oJsonpath "github.com/oliveagle/jsonpath"
        "k8s.io/client-go/util/jsonpath"
        "sigs.k8s.io/yaml"
)

const (
        Must   = "must"
        Prefer = "prefer"
        Reject = "reject"
        Any    = "any"
)

func matchString(src string, target string) bool <span class="cov8" title="1">{
        if strings.Contains(src, "*") || strings.Contains(src, "%") </span><span class="cov0" title="0">{
                p := strings.ReplaceAll(src, "*", ".*")
                p = strings.ReplaceAll(p, "%", ".")
                re := regexp.MustCompile(p)
                return re.MatchString(target)
        }</span> else<span class="cov8" title="1"> {
                return src == target
        }</span>
}

func ReadInt32(col map[string]string, key string, defaultVal int32) int32 <span class="cov0" title="0">{
        if v, ok := col[key]; ok </span><span class="cov0" title="0">{
                i, e := ParseValue(v)
                if e != nil </span><span class="cov0" title="0">{
                        return defaultVal
                }</span>
                <span class="cov0" title="0">return i.(int32)</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}
func GetString(col map[string]string, key string) (string, error) <span class="cov0" title="0">{
        if v, ok := col[key]; ok </span><span class="cov0" title="0">{
                i, e := ParseValue(v)
                if e != nil </span><span class="cov0" title="0">{
                        return "", e
                }</span>
                <span class="cov0" title="0">return i.(string), nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("key %s is not found", key)</span>
}

func ReadStringFromMapCompat(col map[string]interface{}, key string, defaultVal string) string <span class="cov0" title="0">{
        if v, ok := col[key]; ok </span><span class="cov0" title="0">{
                i, e := ParseValue(fmt.Sprintf("%v", v))
                if e != nil </span><span class="cov0" title="0">{
                        return defaultVal
                }</span>
                <span class="cov0" title="0">return i.(string)</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func ReadString(col map[string]string, key string, defaultVal string) string <span class="cov8" title="1">{
        if v, ok := col[key]; ok </span><span class="cov8" title="1">{
                i, e := ParseValue(v)
                if e != nil </span><span class="cov0" title="0">{
                        return defaultVal
                }</span>
                <span class="cov8" title="1">return i.(string)</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}
func ReadStringWithOverrides(col1 map[string]string, col2 map[string]string, key string, defaultVal string) string <span class="cov8" title="1">{
        val := ReadString(col1, key, defaultVal)
        return ReadString(col2, key, val)
}</span>
func MergeCollection(col1 map[string]string, col2 map[string]string) map[string]string <span class="cov0" title="0">{
        ret := make(map[string]string)
        for k, v := range col1 </span><span class="cov0" title="0">{
                ret[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range col2 </span><span class="cov0" title="0">{
                ret[k] = v
        }</span>
        <span class="cov0" title="0">return ret</span>
}
func CollectStringMap(col map[string]string, prefix string) map[string]string <span class="cov0" title="0">{
        ret := make(map[string]string)
        for k := range col </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        ret[k] = ReadString(col, k, "")
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}

// TODO: we should get rid of this
func ParseValue(v string) (interface{}, error) <span class="cov8" title="1">{ //TODO: make this a generic utiliy
        if v == "$true" </span><span class="cov0" title="0">{
                return true, nil
        }</span> else<span class="cov8" title="1"> if v == "$false" </span><span class="cov0" title="0">{
                return false, nil
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(v, "#") </span><span class="cov0" title="0">{
                ri, e := strconv.Atoi(v[1:])
                return int32(ri), e
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(v, "{") &amp;&amp; strings.HasSuffix(v, "}") </span><span class="cov0" title="0">{
                var objmap map[string]*json.RawMessage
                e := json.Unmarshal([]byte(v), &amp;objmap)
                return objmap, e
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(v, "[") &amp;&amp; strings.HasSuffix(v, "]") </span><span class="cov0" title="0">{
                var objmap []map[string]*json.RawMessage
                e := json.Unmarshal([]byte(v), &amp;objmap)
                return objmap, e
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(v, "$") </span><span class="cov0" title="0">{
                return os.Getenv(v[1:]), nil
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// TODO: This should not be used anymore
func ProjectValue(val string, name string) string <span class="cov0" title="0">{
        if strings.Contains(val, "${{$instance()}}") </span><span class="cov0" title="0">{
                val = strings.ReplaceAll(val, "${{$instance()}}", name)
        }</span>
        <span class="cov0" title="0">return val</span>
}

func FormatObject(obj interface{}, isArray bool, path string, format string) ([]byte, error) <span class="cov8" title="1">{
        jData, _ := json.Marshal(obj)
        if path == "" &amp;&amp; format == "" </span><span class="cov8" title="1">{
                return jData, nil
        }</span>
        <span class="cov8" title="1">var dict interface{}
        if isArray </span><span class="cov0" title="0">{
                dict = make([]map[string]interface{}, 0)
        }</span> else<span class="cov8" title="1"> {
                dict = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">json.Unmarshal(jData, &amp;dict)
        if path != "" </span><span class="cov8" title="1">{
                if path == "first_embedded" </span><span class="cov0" title="0">{
                        path = "$.spec.components[0].properties.embedded"
                }</span>
                <span class="cov8" title="1">if isArray </span><span class="cov0" title="0">{
                        if format == "yaml" </span><span class="cov0" title="0">{
                                ret := make([]byte, 0)
                                for i, item := range dict.([]interface{}) </span><span class="cov0" title="0">{
                                        ob, _ := oJsonpath.JsonPathLookup(item, path)
                                        if s, ok := ob.(string); ok </span><span class="cov0" title="0">{
                                                str, err := strconv.Unquote(strings.TrimSpace(s))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        str = strings.TrimSpace(s)
                                                }</span>
                                                <span class="cov0" title="0">var o interface{}
                                                err = yaml.Unmarshal([]byte(str), &amp;o)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        jData = []byte(s)
                                                }</span> else<span class="cov0" title="0"> {
                                                        jData, _ = yaml.Marshal(o)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                jData, _ = yaml.Marshal(ob)
                                        }</span>
                                        <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                                                ret = append(ret, []byte("---\n")...)
                                        }</span>
                                        <span class="cov0" title="0">ret = append(ret, jData...)</span>
                                }
                                <span class="cov0" title="0">jData = ret</span>
                        } else<span class="cov0" title="0"> {
                                ret := make([]interface{}, 0)
                                for _, item := range dict.([]interface{}) </span><span class="cov0" title="0">{
                                        ob, _ := oJsonpath.JsonPathLookup(item, path)
                                        ret = append(ret, ob)
                                        jData, _ = yaml.Marshal(ob)
                                }</span>
                                <span class="cov0" title="0">jData, _ = json.Marshal(ret)</span>
                        }
                } else<span class="cov8" title="1"> {
                        ob, _ := oJsonpath.JsonPathLookup(dict, path)
                        if format == "yaml" </span><span class="cov8" title="1">{
                                if s, ok := ob.(string); ok </span><span class="cov8" title="1">{
                                        str, err := strconv.Unquote(strings.TrimSpace(s))
                                        if err != nil </span><span class="cov8" title="1">{
                                                str = strings.TrimSpace(s)
                                        }</span>
                                        <span class="cov8" title="1">var o interface{}
                                        err = yaml.Unmarshal([]byte(str), &amp;o)
                                        if err != nil </span><span class="cov0" title="0">{
                                                jData = []byte(str)
                                        }</span> else<span class="cov8" title="1"> {
                                                jData, _ = yaml.Marshal(o)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        jData, _ = yaml.Marshal(ob)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                jData, _ = json.Marshal(ob)
                        }</span>
                }
        }
        <span class="cov8" title="1">return jData, nil</span>
}

func toInterfaceMap(m map[string]string) map[string]interface{} <span class="cov0" title="0">{
        ret := make(map[string]interface{})
        for k, v := range m </span><span class="cov0" title="0">{
                ret[k] = v
        }</span>
        <span class="cov0" title="0">return ret</span>
}
func FormatAsString(val interface{}) string <span class="cov8" title="1">{
        switch tv := val.(type) </span>{
        case string:<span class="cov8" title="1">
                return tv</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(tv)</span>
        case int32:<span class="cov0" title="0">
                return strconv.Itoa(int(tv))</span>
        case int64:<span class="cov0" title="0">
                return strconv.Itoa(int(tv))</span>
        case float32:<span class="cov0" title="0">
                return strconv.FormatFloat(float64(tv), 'f', -1, 32)</span>
        case float64:<span class="cov0" title="0">
                return strconv.FormatFloat(tv, 'f', -1, 64)</span>
        case bool:<span class="cov0" title="0">
                return strconv.FormatBool(tv)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                ret, _ := json.Marshal(tv)
                return string(ret)</span>
        case []interface{}:<span class="cov0" title="0">
                ret, _ := json.Marshal(tv)
                return string(ret)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", tv)</span>
        }
}
func JsonPathQuery(obj interface{}, jsonPath string) (interface{}, error) <span class="cov8" title="1">{
        jPath := jsonPath
        if !strings.HasPrefix(jPath, "{") </span><span class="cov8" title="1">{
                jPath = "{" + jsonPath + "}" // k8s.io/client-go/util/jsonpath requires JsonPath expression to be wrapped in {}
        }</span>

        <span class="cov8" title="1">result, err := jsonPathQuery(obj, jPath)
        if err == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // This is a workaround for filtering by root-level attributes. In this case, we need to
        // wrap the object into an array and then query the array.
        <span class="cov8" title="1">var arr []interface{}
        switch obj.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                // the object is already an array, so the query didn't work
                return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("no matches found by JsonPath query '%s'", jsonPath), v1alpha2.InternalError)</span>
        default:<span class="cov8" title="1">
                arr = append(arr, obj)</span>
        }
        <span class="cov8" title="1">return jsonPathQuery(arr, jPath)</span>
}
func jsonPathQuery(obj interface{}, jsonPath string) (interface{}, error) <span class="cov8" title="1">{
        jpLookup := jsonpath.New("lookup")
        jpLookup.AllowMissingKeys(true)
        jpLookup.EnableJSONOutput(true)

        err := jpLookup.Parse(jsonPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        err = jpLookup.Execute(&amp;buf, obj)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var result []interface{}
        err = json.Unmarshal(buf.Bytes(), &amp;result)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, v1alpha2.NewCOAError(nil, fmt.Sprintf("no matches found by JsonPath query '%s'", jsonPath), v1alpha2.InternalError)
        }</span> else<span class="cov8" title="1"> if len(result) == 1 </span><span class="cov8" title="1">{
                return result[0], nil
        }</span> else<span class="cov0" title="0"> {
                return result, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/activations"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var vLog = logger.NewLogger("coa.runtime")

type ActivationsVendor struct {
        vendors.Vendor
        ActivationsManager *activations.ActivationsManager
}

func (o *ActivationsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Activations",
                Producer: "Microsoft",
        }
}</span>

func (e *ActivationsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*activations.ActivationsManager); ok </span><span class="cov0" title="0">{
                        e.ActivationsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.ActivationsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "activations manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *ActivationsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "activations"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route + "/registry",
                        Version:    o.Version,
                        Handler:    o.onActivations,
                        Parameters: []string{"name?"},
                },
                {
                        Methods:    []string{fasthttp.MethodPost},
                        Route:      route + "/status",
                        Version:    o.Version,
                        Handler:    o.onStatus,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *ActivationsVendor) onStatus(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Activations Vendor", request.Context, &amp;map[string]string{
                "method": "onStatus",
        })
        defer span.End()

        cLog.Info("V (Activations Vendor): onStatus")
        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onStatus-POST", pCtx, nil)
                id := request.Parameters["__name"]
                var status model.ActivationStatus
                err := json.Unmarshal(request.Body, &amp;status)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">err = c.ActivationsManager.ReportStatus(ctx, id, status)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (c *ActivationsVendor) onActivations(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Activations Vendor", request.Context, &amp;map[string]string{
                "method": "onActivations",
        })
        defer span.End()

        cLog.Info("V (Activations Vendor): onActivations")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onActivations-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = c.ActivationsManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = c.ActivationsManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onActivations-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var activation model.ActivationSpec

                err := json.Unmarshal(request.Body, &amp;activation)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov0" title="0">err = c.ActivationsManager.UpsertSpec(ctx, id, activation)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">entry, err := c.ActivationsManager.GetSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">c.Context.Publish("activation", v1alpha2.Event{
                        Body: v1alpha2.ActivationData{
                                Campaign:             activation.Campaign,
                                ActivationGeneration: entry.Spec.Generation,
                                Activation:           id,
                                Stage:                "",
                                Inputs:               activation.Inputs,
                        },
                })
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onActivations-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.ActivationsManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"
        "strconv"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/reference"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var log = logger.NewLogger("coa.runtime")

type AgentVendor struct {
        vendors.Vendor
        ReferenceManager *reference.ReferenceManager
}

func (o *AgentVendor) GetInfo() vendors.VendorInfo <span class="cov8" title="1">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Agent",
                Producer: "Microsoft",
        }
}</span>

func (e *AgentVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov8" title="1">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, m := range e.Managers </span><span class="cov8" title="1">{
                if c, ok := m.(*reference.ReferenceManager); ok </span><span class="cov8" title="1">{
                        e.ReferenceManager = c
                }</span>
        }
        <span class="cov8" title="1">if e.ReferenceManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "reference manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *AgentVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov8" title="1">{
        route := "agent"
        if o.Route != "" </span><span class="cov8" title="1">{
                route = o.Route
        }</span>
        <span class="cov8" title="1">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodGet, fasthttp.MethodPost},
                        Route:   route + "/references",
                        Version: o.Version,
                        Handler: o.onReference,
                },
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/config",
                        Version: o.Version,
                        Handler: o.onConfig,
                },
        }</span>
}
func (c *AgentVendor) onConfig(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        pCtx, span := observability.StartSpan("Agent Vendor", request.Context, &amp;map[string]string{
                "method": "onConfig",
        })
        defer span.End()

        log.Infof("V (Agent): onConfig %s", request.Method)

        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Apply Config", pCtx, nil)
                response := c.doApplyConfig(ctx, request.Parameters, request.Body)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        }

        <span class="cov8" title="1">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (c *AgentVendor) onReference(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        pCtx, span := observability.StartSpan("Agent Vendor", request.Context, &amp;map[string]string{
                "method": "onReference",
        })
        defer span.End()

        log.Infof("V (Agent): onReference %s", request.Method)

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Get References", pCtx, nil)
                response := c.doGet(ctx, request.Parameters)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        case fasthttp.MethodPost:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Report Status", pCtx, nil)
                response := c.doPost(ctx, request.Parameters, request.Body)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        }

        <span class="cov8" title="1">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *AgentVendor) doGet(ctx context.Context, parameters map[string]string) v1alpha2.COAResponse <span class="cov8" title="1">{
        var scope = "default"
        var kind = ""
        var ref = ""
        var group = ""
        var id = ""
        var version = ""
        var fieldSelector = ""
        var labelSelector = ""
        var instance = ""
        var lookup = ""
        var platform = ""
        var flavor = ""
        var iteration = ""
        var alias = ""
        if v, ok := parameters["scope"]; ok </span><span class="cov8" title="1">{
                scope = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["ref"]; ok </span><span class="cov8" title="1">{
                ref = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["kind"]; ok </span><span class="cov8" title="1">{
                kind = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["version"]; ok </span><span class="cov8" title="1">{
                version = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["group"]; ok </span><span class="cov8" title="1">{
                group = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["id"]; ok </span><span class="cov8" title="1">{
                id = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["field-selector"]; ok </span><span class="cov0" title="0">{
                fieldSelector = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["label-selector"]; ok </span><span class="cov0" title="0">{
                labelSelector = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["instance"]; ok </span><span class="cov8" title="1">{
                instance = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["platform"]; ok </span><span class="cov8" title="1">{
                platform = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["flavor"]; ok </span><span class="cov8" title="1">{
                flavor = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["lookup"]; ok </span><span class="cov0" title="0">{
                lookup = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["iteration"]; ok </span><span class="cov8" title="1">{
                iteration = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["alias"]; ok </span><span class="cov8" title="1">{
                alias = v
        }</span>

        <span class="cov8" title="1">var data []byte
        var err error
        if instance != "" </span><span class="cov8" title="1">{
                data, err = c.ReferenceManager.GetExt(ref, scope, id, group, kind, version, instance, model.SolutionGroup, "instances", "v1", "", alias)
        }</span> else<span class="cov8" title="1"> if lookup != "" </span><span class="cov0" title="0">{
                data, err = c.ReferenceManager.GetExt(ref, scope, id, group, kind, version, instance, lookup, platform, flavor, iteration, "")
        }</span> else<span class="cov8" title="1"> {
                data, err = c.ReferenceManager.Get(ref, id, scope, group, kind, version, labelSelector, fieldSelector)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                }
        }</span>
        <span class="cov8" title="1">return v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        data,
                ContentType: "application/json",
        }</span>
}

func (c *AgentVendor) doApplyConfig(ctx context.Context, parameters map[string]string, data []byte) v1alpha2.COAResponse <span class="cov8" title="1">{
        var config managers.ProviderConfig
        err := json.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha2.COAResponse{
                        State: v1alpha2.BadRequest,
                        Body:  []byte(err.Error()),
                }
        }</span>
        // TODO: The following is temporary implementation. A proper mechanism to reconfigure providers/managers/vendors is needed. This doesn't handle scaling out
        // (when multiple vendor instances are behind load balancer), either
        <span class="cov8" title="1">switch config.Type </span>{
        case "providers.reference.customvision":<span class="cov8" title="1">
                for _, p := range c.ReferenceManager.ReferenceProviders </span><span class="cov8" title="1">{
                        err = p.Reconfigure(config.Config)
                        if err != nil </span><span class="cov0" title="0">{
                                return v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                }
                        }</span>
                }
        }
        <span class="cov8" title="1">return v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        []byte("{}"),
                ContentType: "application/json",
        }</span>
}

func (c *AgentVendor) doPost(ctx context.Context, parameters map[string]string, data []byte) v1alpha2.COAResponse <span class="cov8" title="1">{
        var scope = "default"
        var kind = ""
        var group = ""
        var id = ""
        var version = ""
        var overwrite = false
        if v, ok := parameters["scope"]; ok </span><span class="cov8" title="1">{
                scope = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["kind"]; ok </span><span class="cov8" title="1">{
                kind = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["version"]; ok </span><span class="cov8" title="1">{
                version = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["group"]; ok </span><span class="cov8" title="1">{
                group = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["id"]; ok </span><span class="cov8" title="1">{
                id = v
        }</span>
        <span class="cov8" title="1">if v, ok := parameters["overwrite"]; ok </span><span class="cov8" title="1">{
                overwrite, _ = strconv.ParseBool(v)
        }</span>
        <span class="cov8" title="1">properties := make(map[string]string)
        err := json.Unmarshal(data, &amp;properties)
        if err != nil </span><span class="cov8" title="1">{
                return v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                }
        }</span>
        <span class="cov8" title="1">err = c.ReferenceManager.Report(id, scope, group, kind, version, properties, overwrite)
        if err != nil </span><span class="cov8" title="1">{
                return v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                }
        }</span>
        <span class="cov8" title="1">return v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        data,
                ContentType: "application/json",
        }</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/activations"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
)

type BackgroundJobVendor struct {
        vendors.Vendor
        // Add a new manager if you want to add another background job
        ActivationsCleanerManager *activations.ActivationsCleanupManager
}

func (s *BackgroundJobVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  s.Vendor.Version,
                Name:     "BackgroundJob",
                Producer: "Microsoft",
        }
}</span>

func (o *BackgroundJobVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        return []v1alpha2.Endpoint{}
}</span>

func (s *BackgroundJobVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := s.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range s.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*activations.ActivationsCleanupManager); ok </span><span class="cov0" title="0">{
                        s.ActivationsCleanerManager = c
                }</span>
                // Load a new manager if you want to add another background job
        }
        <span class="cov0" title="0">if s.ActivationsCleanerManager != nil </span><span class="cov0" title="0">{
                log.Info("ActivationsCleanupManager is enabled")
        }</span> else<span class="cov0" title="0"> {
                log.Info("ActivationsCleanupManager is disabled")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/campaigns"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var cLog = logger.NewLogger("coa.runtime")

type CampaignsVendor struct {
        vendors.Vendor
        CampaignsManager *campaigns.CampaignsManager
}

func (o *CampaignsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Campaigns",
                Producer: "Microsoft",
        }
}</span>

func (e *CampaignsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*campaigns.CampaignsManager); ok </span><span class="cov0" title="0">{
                        e.CampaignsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.CampaignsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "campaigns manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *CampaignsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "campaigns"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onCampaigns,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *CampaignsVendor) onCampaigns(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Campaigns Vendor", request.Context, &amp;map[string]string{
                "method": "onCampaigns",
        })
        defer span.End()
        cLog.Info("V (Campaigns): onCampaigns")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCampaigns-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = c.CampaignsManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = c.CampaignsManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCampaigns-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var campaign model.CampaignSpec

                err := json.Unmarshal(request.Body, &amp;campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov0" title="0">err = c.CampaignsManager.UpsertSpec(ctx, id, campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCampaigns-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.CampaignsManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/catalogs"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var lLog = logger.NewLogger("coa.runtime")

type CatalogsVendor struct {
        vendors.Vendor
        CatalogsManager *catalogs.CatalogsManager
}

func (e *CatalogsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  e.Vendor.Version,
                Name:     "Catalogs",
                Producer: "Microsoft",
        }
}</span>
func (e *CatalogsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*catalogs.CatalogsManager); ok </span><span class="cov0" title="0">{
                        e.CatalogsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.CatalogsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "catalogs manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">e.Vendor.Context.Subscribe("catalog-sync", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                jData, _ := json.Marshal(event.Body)
                var job v1alpha2.JobData
                err := json.Unmarshal(jData, &amp;job)
                if err == nil </span><span class="cov0" title="0">{
                        var catalog model.CatalogSpec
                        jData, _ = json.Marshal(job.Body)
                        err = json.Unmarshal(jData, &amp;catalog)
                        if err == nil </span><span class="cov0" title="0">{
                                name := fmt.Sprintf("%s-%s", catalog.SiteId, catalog.Name)
                                catalog.Name = name
                                if catalog.ParentName != "" </span><span class="cov0" title="0">{
                                        catalog.ParentName = fmt.Sprintf("%s-%s", catalog.SiteId, catalog.ParentName)
                                }</span>
                                <span class="cov0" title="0">err := e.CatalogsManager.UpsertSpec(context.TODO(), name, catalog)
                                if err != nil </span><span class="cov0" title="0">{
                                        return v1alpha2.NewCOAError(err, "failed to upsert catalog", v1alpha2.InternalError)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                iLog.Errorf("Failed to unmarshal job body: %v", err)
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        iLog.Errorf("Failed to unmarshal job data: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return nil</span>
}
func (e *CatalogsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "catalogs"
        if e.Route != "" </span><span class="cov0" title="0">{
                route = e.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route + "/registry",
                        Version:    e.Version,
                        Handler:    e.onCatalogs,
                        Parameters: []string{"name?"},
                },
                {
                        Methods: []string{fasthttp.MethodGet},
                        Route:   route + "/graph",
                        Version: e.Version,
                        Handler: e.onCatalogsGraph,
                },
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/check",
                        Version: e.Version,
                        Handler: e.onCheck,
                },
        }</span>
}
func (e *CatalogsVendor) onCheck(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        rCtx, span := observability.StartSpan("Catalogs Vendor", request.Context, &amp;map[string]string{
                "method": "onCheck",
        })
        defer span.End()

        lLog.Info("V (Catalogs Vendor): onCheck")
        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                var campaign model.CatalogSpec

                err := json.Unmarshal(request.Body, &amp;campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">res, err := e.CatalogsManager.ValidateSpec(rCtx, campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">if !res.Valid </span><span class="cov0" title="0">{
                        jData, _ := utils.FormatObject(res.Errors, true, "", "")
                        resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.BadRequest,
                                Body:        jData,
                                ContentType: "application/json",
                        })
                        return resp
                }</span>
                <span class="cov0" title="0">resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })
                return resp</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (e *CatalogsVendor) onCatalogsGraph(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        rCtx, span := observability.StartSpan("Catalogs Vendor", request.Context, &amp;map[string]string{
                "method": "onCatalogsGraph",
        })
        defer span.End()

        lLog.Info("V (Catalogs Vendor): onCatalogsGraph")
        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCatalogsGraph-GET", rCtx, nil)
                template := request.Parameters["template"]
                switch template </span>{
                case "config-chains":<span class="cov0" title="0">
                        chains, err := e.CatalogsManager.GetChains(ctx, "config")
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov0" title="0">jData, _ := utils.FormatObject(chains, true, "", "")
                        resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.OK,
                                Body:        jData,
                                ContentType: "application/json",
                        })
                        return resp</span>
                case "asset-trees":<span class="cov0" title="0">
                        trees, err := e.CatalogsManager.GetTrees(ctx, "asset")
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov0" title="0">jData, _ := utils.FormatObject(trees, true, "", "")
                        resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.OK,
                                Body:        jData,
                                ContentType: "application/json",
                        })
                        return resp</span>
                default:<span class="cov0" title="0">
                        resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.BadRequest,
                                Body:        []byte("{\"result\": \"400 - unknown template\"}"),
                                ContentType: "application/json",
                        })
                        return resp</span>
                }
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (e *CatalogsVendor) onCatalogs(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Catalogs Vendor", request.Context, &amp;map[string]string{
                "method": "onCatalogs",
        })
        defer span.End()

        lLog.Info("V (Catalogs Vendor): onCatalogs")
        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCatalogs-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = e.CatalogsManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = e.CatalogsManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if !v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.NotFound,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                }
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCatalogs-POST", pCtx, nil)
                id := request.Parameters["__name"]
                if id == "" </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.BadRequest,
                                Body:  []byte("missing catalog name"),
                        })
                }</span>
                <span class="cov0" title="0">var campaign model.CatalogSpec

                err := json.Unmarshal(request.Body, &amp;campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov0" title="0">err = e.CatalogsManager.UpsertSpec(ctx, id, campaign)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onCatalogs-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := e.CatalogsManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/devices"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var dLog = logger.NewLogger("coa.runtime")

type DevicesVendor struct {
        vendors.Vendor
        DevicesManager *devices.DevicesManager
}

func (o *DevicesVendor) GetInfo() vendors.VendorInfo <span class="cov8" title="1">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Devices",
                Producer: "Microsoft",
        }
}</span>

func (e *DevicesVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov8" title="1">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, m := range e.Managers </span><span class="cov8" title="1">{
                if c, ok := m.(*devices.DevicesManager); ok </span><span class="cov8" title="1">{
                        e.DevicesManager = c
                }</span>
        }
        <span class="cov8" title="1">if e.DevicesManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "devices manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *DevicesVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov8" title="1">{
        route := "devices"
        if o.Route != "" </span><span class="cov8" title="1">{
                route = o.Route
        }</span>
        <span class="cov8" title="1">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onDevices,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *DevicesVendor) onDevices(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        pCtx, span := observability.StartSpan("Devices Vendor", request.Context, &amp;map[string]string{
                "method": "onDevices",
        })
        defer span.End()

        tLog.Info("~ Devices Manager ~ : onDevices")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("onDevices-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov8" title="1">{
                        state, err = c.DevicesManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov8" title="1"> {
                        state, err = c.DevicesManager.GetSpec(ctx, id)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov8" title="1">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov8" title="1">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov8" title="1">return resp</span>
        case fasthttp.MethodPost:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("onDevices-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var device model.DeviceSpec

                err := json.Unmarshal(request.Body, &amp;device)
                if err != nil </span><span class="cov8" title="1">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov8" title="1">err = c.DevicesManager.UpsertSpec(ctx, id, device)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov8" title="1">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("onDevices-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.DevicesManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov8" title="1">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov8" title="1">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov8" title="1">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/valyala/fasthttp"
)

type EchoVendor struct {
        vendors.Vendor
        myMessages []string
}

func (o *EchoVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Echo",
                Producer: "Microsoft",
        }
}</span>

func (e *EchoVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        e.myMessages = make([]string, 0)
        e.Vendor.Context.Subscribe("trace", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                msg := event.Body.(string)
                e.myMessages = append(e.myMessages, msg)
                if len(e.myMessages) &gt; 20 </span><span class="cov0" title="0">{
                        e.myMessages = e.myMessages[1:]
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *EchoVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "greetings"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodGet, fasthttp.MethodPost},
                        Route:   route,
                        Version: o.Version,
                        Handler: o.onHello,
                },
        }</span>
}

func (c *EchoVendor) onHello(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Echo Vendor", request.Context, &amp;map[string]string{
                "method": "onHello",
        })
        defer span.End()

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                message := "Hello from Symphony K8s control plane (S8C)"
                if len(c.myMessages) &gt; 0 </span><span class="cov0" title="0">{
                        for _, m := range c.myMessages </span><span class="cov0" title="0">{
                                message = message + "\r\n" + m
                        }</span>
                }
                <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        []byte(message),
                        ContentType: "application/text",
                }
                return observ_utils.CloseSpanWithCOAResponse(span, resp)</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                c.Vendor.Context.Publish("trace", v1alpha2.Event{
                        Body: string(request.Body),
                })
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"
        "strconv"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/catalogs"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/sites"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/staging"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/sync"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/trails"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var fLog = logger.NewLogger("coa.runtime")

type FederationVendor struct {
        vendors.Vendor
        SitesManager    *sites.SitesManager
        CatalogsManager *catalogs.CatalogsManager
        StagingManager  *staging.StagingManager
        SyncManager     *sync.SyncManager
        TrailsManager   *trails.TrailsManager
}

func (f *FederationVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  f.Vendor.Version,
                Name:     "Federation",
                Producer: "Microsoft",
        }
}</span>
func (f *FederationVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := f.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range f.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*sites.SitesManager); ok </span><span class="cov0" title="0">{
                        f.SitesManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*staging.StagingManager); ok </span><span class="cov0" title="0">{
                        f.StagingManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*catalogs.CatalogsManager); ok </span><span class="cov0" title="0">{
                        f.CatalogsManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*sync.SyncManager); ok </span><span class="cov0" title="0">{
                        f.SyncManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*trails.TrailsManager); ok </span><span class="cov0" title="0">{
                        f.TrailsManager = c
                }</span>
        }
        <span class="cov0" title="0">if f.StagingManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "staging manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">if f.SitesManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "sites manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">if f.CatalogsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "catalogs manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">f.Vendor.Context.Subscribe("catalog", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                sites, err := f.SitesManager.ListSpec(context.TODO())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, site := range sites </span><span class="cov0" title="0">{
                        if site.Spec.Name != f.Vendor.Context.SiteInfo.SiteId </span><span class="cov0" title="0">{
                                event.Metadata["site"] = site.Spec.Name
                                f.StagingManager.HandleJobEvent(context.TODO(), event) //TODO: how to handle errors in this case?
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">f.Vendor.Context.Subscribe("remote", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                _, ok := event.Metadata["site"]
                if !ok </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, "site is not supplied", v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">f.StagingManager.HandleJobEvent(context.TODO(), event) //TODO: how to handle errors in this case?
                return nil</span>
        })
        <span class="cov0" title="0">f.Vendor.Context.Subscribe("report", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                fLog.Debugf("V (Federation): received report event: %v", event)
                jData, _ := json.Marshal(event.Body)
                var status model.ActivationStatus
                err := json.Unmarshal(jData, &amp;status)
                if err == nil </span><span class="cov0" title="0">{
                        err := utils.SyncActivationStatus(
                                context.TODO(),
                                f.Vendor.Context.SiteInfo.ParentSite.BaseUrl,
                                f.Vendor.Context.SiteInfo.ParentSite.Username,
                                f.Vendor.Context.SiteInfo.ParentSite.Password, status)
                        if err != nil </span><span class="cov0" title="0">{
                                fLog.Errorf("V (Federation): error while syncing activation status: %v", err)
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return v1alpha2.NewCOAError(nil, "report is not an activation status", v1alpha2.BadRequest)</span>
        })
        <span class="cov0" title="0">f.Vendor.Context.Subscribe("trail", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                if f.TrailsManager != nil </span><span class="cov0" title="0">{
                        jData, _ := json.Marshal(event.Body)
                        var trails []v1alpha2.Trail
                        err := json.Unmarshal(jData, &amp;trails)
                        if err == nil </span><span class="cov0" title="0">{
                                return f.TrailsManager.Append(context.TODO(), trails)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        //now register the current site
        <span class="cov0" title="0">return f.SitesManager.UpsertSpec(context.TODO(), f.Context.SiteInfo.SiteId, model.SiteSpec{
                Name:       f.Context.SiteInfo.SiteId,
                Properties: f.Context.SiteInfo.Properties,
                IsSelf:     true,
        })</span>
}
func (f *FederationVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "federation"
        if f.Route != "" </span><span class="cov0" title="0">{
                route = f.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodPost, fasthttp.MethodGet},
                        Route:      route + "/sync",
                        Version:    f.Version,
                        Handler:    f.onSync,
                        Parameters: []string{"site?"},
                },
                {
                        Methods:    []string{fasthttp.MethodPost, fasthttp.MethodGet},
                        Route:      route + "/registry",
                        Version:    f.Version,
                        Handler:    f.onRegistry,
                        Parameters: []string{"name?"},
                },
                {
                        Methods:    []string{fasthttp.MethodPost},
                        Route:      route + "/status",
                        Version:    f.Version,
                        Handler:    f.onStatus,
                        Parameters: []string{"name"},
                },
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/trail",
                        Version: f.Version,
                        Handler: f.onTrail,
                },
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/k8shook",
                        Version: f.Version,
                        Handler: f.onK8sHook,
                },
        }</span>
}
func (c *FederationVendor) onStatus(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Federation Vendor", request.Context, &amp;map[string]string{
                "method": "onStatus",
        })
        defer span.End()

        var state model.SiteState
        json.Unmarshal(request.Body, &amp;state)

        err := c.SitesManager.ReportState(pCtx, state)

        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                State: v1alpha2.OK,
        })</span>
}

func (f *FederationVendor) onRegistry(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Federation Vendor", request.Context, &amp;map[string]string{
                "method": "onRegistry",
        })
        defer span.End()

        tLog.Info("V (Federation): onRegistry")
        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = f.SitesManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = f.SitesManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var site model.SiteSpec
                err := json.Unmarshal(request.Body, &amp;site)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                //TODO: generate site key pair as needed
                <span class="cov0" title="0">err = f.SitesManager.UpsertSpec(ctx, id, site)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := f.SitesManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (f *FederationVendor) onSync(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Federation Vendor", request.Context, &amp;map[string]string{
                "method": "onSync",
        })
        defer span.End()

        tLog.Info("V (Federation): onSync")
        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                var status model.ActivationStatus
                err := json.Unmarshal(request.Body, &amp;status)
                if err != nil </span><span class="cov0" title="0">{
                        tLog.Errorf("V (Federation): failed to unmarshal activation status: %v", err)
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.BadRequest,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">err = f.Vendor.Context.Publish("job-report", v1alpha2.Event{
                        Body: status,
                })
                if err != nil </span><span class="cov0" title="0">{
                        tLog.Errorf("V (Federation): failed to publish job report: %v", err)
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">tLog.Debugf("V (Federation): published job report: %v", status)
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSync-GET", pCtx, nil)
                id := request.Parameters["__site"]
                count := request.Parameters["count"]
                if count == "" </span><span class="cov0" title="0">{
                        count = "1"
                }</span>
                <span class="cov0" title="0">intCount, err := strconv.Atoi(count)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.BadRequest,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">batch, err := f.StagingManager.GetABatchForSite(id, intCount)

                pack := model.SyncPackage{
                        Origin: f.Context.SiteInfo.SiteId,
                }

                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">catalogs := make([]model.CatalogSpec, 0)
                jobs := make([]v1alpha2.JobData, 0)
                for _, c := range batch </span><span class="cov0" title="0">{
                        if c.Action == "RUN" </span><span class="cov0" title="0">{ //TODO: I don't really like this
                                jobs = append(jobs, c)
                        }</span> else<span class="cov0" title="0"> {
                                catalog, err := f.CatalogsManager.GetSpec(ctx, c.Id)
                                if err != nil </span><span class="cov0" title="0">{
                                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                                State: v1alpha2.InternalError,
                                                Body:  []byte(err.Error()),
                                        })
                                }</span>
                                <span class="cov0" title="0">catalogs = append(catalogs, *catalog.Spec)</span>
                        }
                }
                <span class="cov0" title="0">pack.Catalogs = catalogs
                pack.Jobs = jobs
                jData, _ := utils.FormatObject(pack, true, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
func (f *FederationVendor) onTrail(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Federation Vendor", request.Context, &amp;map[string]string{
                "method": "onTrail",
        })
        defer span.End()

        resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        return resp
}</span>
func (f *FederationVendor) onK8sHook(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Federation Vendor", request.Context, &amp;map[string]string{
                "method": "onK8sHook",
        })
        defer span.End()

        tLog.Info("V (Federation): onK8sHook")
        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                objectType := request.Parameters["objectType"]
                if objectType == "catalog" </span><span class="cov0" title="0">{
                        var catalog model.CatalogSpec
                        err := json.Unmarshal(request.Body, &amp;catalog)
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.BadRequest,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov0" title="0">err = f.Vendor.Context.Publish("catalog", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": catalog.Type,
                                },
                                Body: v1alpha2.JobData{
                                        Id:     catalog.Name,
                                        Action: "UPDATE", //TODO: handle deletion, this probably requires BetBachForSites return flags
                                        Body:   catalog,
                                },
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.OK,
                        })</span>
                }
        }

        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"
        "strings"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/instances"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var iLog = logger.NewLogger("coa.runtime")

type InstancesVendor struct {
        vendors.Vendor
        InstancesManager *instances.InstancesManager
}

func (o *InstancesVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Instances",
                Producer: "Microsoft",
        }
}</span>

func (e *InstancesVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*instances.InstancesManager); ok </span><span class="cov0" title="0">{
                        e.InstancesManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.InstancesManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "instances manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *InstancesVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "instances"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onInstances,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *InstancesVendor) onInstances(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Instances Vendor", request.Context, &amp;map[string]string{
                "method": "onInstances",
        })
        defer span.End()

        tLog.Info("~ Instances Manager ~ : onInstances")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onInstances-GET", pCtx, nil)
                id := request.Parameters["__name"]
                scope, exist := request.Parameters["scope"]
                if !exist </span><span class="cov0" title="0">{
                        scope = "default"
                }</span>
                <span class="cov0" title="0">var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        // Change partition back to empty to indicate ListSpec need to query all namespaces
                        if !exist </span><span class="cov0" title="0">{
                                scope = ""
                        }</span>
                        <span class="cov0" title="0">state, err = c.InstancesManager.ListSpec(ctx, scope)
                        isArray = true</span>
                } else<span class="cov0" title="0"> {
                        state, err = c.InstancesManager.GetSpec(ctx, id, scope)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onInstances-POST", pCtx, nil)
                id := request.Parameters["__name"]

                solution := request.Parameters["solution"]
                target := request.Parameters["target"]
                target_selector := request.Parameters["target-selector"]
                scope, exist := request.Parameters["scope"]
                if !exist </span><span class="cov0" title="0">{
                        scope = "default"
                }</span>
                <span class="cov0" title="0">var instance model.InstanceSpec

                if solution != "" &amp;&amp; (target != "" || target_selector != "") </span><span class="cov0" title="0">{
                        instance = model.InstanceSpec{
                                DisplayName: id,
                                Name:        id,
                                Solution:    solution,
                        }
                        if target != "" </span><span class="cov0" title="0">{
                                instance.Target = model.TargetSelector{
                                        Name: target,
                                }
                        }</span> else<span class="cov0" title="0"> {
                                parts := strings.Split(target_selector, "=")
                                if len(parts) != 2 </span><span class="cov0" title="0">{
                                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                                State: v1alpha2.InternalError,
                                                Body:  []byte("invalid target selector format. Expected: &lt;property&gt;=&lt;value&gt;"),
                                        })
                                }</span>
                                <span class="cov0" title="0">instance.Target = model.TargetSelector{
                                        Selector: map[string]string{
                                                parts[0]: parts[1],
                                        },
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        err := json.Unmarshal(request.Body, &amp;instance)
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                }
                <span class="cov0" title="0">err := c.InstancesManager.UpsertSpec(ctx, id, instance, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">if c.Config.Properties["useJobManager"] == "true" </span><span class="cov0" title="0">{
                        c.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "instance",
                                        "scope":      scope,
                                },
                                Body: v1alpha2.JobData{
                                        Id:     id,
                                        Action: "UPDATE",
                                },
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onInstances-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                direct := request.Parameters["direct"]
                scope, exist := request.Parameters["scope"]
                if !exist </span><span class="cov0" title="0">{
                        scope = "default"
                }</span>
                <span class="cov0" title="0">if c.Config.Properties["useJobManager"] == "true" &amp;&amp; direct != "true" </span><span class="cov0" title="0">{
                        c.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "instance",
                                        "scope":      scope,
                                },
                                Body: v1alpha2.JobData{
                                        Id:     id,
                                        Action: "DELETE",
                                },
                        })
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.OK,
                        })
                }</span> else<span class="cov0" title="0"> {
                        err := c.InstancesManager.DeleteSpec(ctx, id, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                }
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/jobs"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var jLog = logger.NewLogger("coa.runtime")

type JobVendor struct {
        vendors.Vendor
        myMessages  []string
        JobsManager *jobs.JobsManager
}

func (o *JobVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Job",
                Producer: "Microsoft",
        }
}</span>

func (e *JobVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*jobs.JobsManager); ok </span><span class="cov0" title="0">{
                        e.JobsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.JobsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "jobs manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">e.myMessages = make([]string, 0)
        e.Vendor.Context.Subscribe("trace", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                msg := event.Body.(string)
                e.myMessages = append(e.myMessages, msg)
                if len(e.myMessages) &gt; 20 </span><span class="cov0" title="0">{
                        e.myMessages = e.myMessages[1:]
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">e.Vendor.Context.Subscribe("job", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                err := e.JobsManager.HandleJobEvent(context.Background(), event)
                if err != nil &amp;&amp; v1alpha2.IsDelayed(err) </span><span class="cov0" title="0">{
                        go e.Vendor.Context.Publish(topic, event)
                }</span>
                <span class="cov0" title="0">return err</span>
        })
        <span class="cov0" title="0">e.Vendor.Context.Subscribe("heartbeat", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                return e.JobsManager.HandleHeartBeatEvent(context.Background(), event)
        }</span>)
        <span class="cov0" title="0">e.Vendor.Context.Subscribe("schedule", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                return e.JobsManager.HandleScheduleEvent(context.Background(), event)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o *JobVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "jobs"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route,
                        Version: o.Version,
                        Handler: o.onHello,
                },
        }</span>
}

func (c *JobVendor) onHello(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Job Vendor", request.Context, &amp;map[string]string{
                "method": "onHello",
        })
        defer span.End()

        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                var activationData v1alpha2.ActivationData
                err := json.Unmarshal(request.Body, &amp;activationData)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.BadRequest,
                                Body:        []byte("{\"result\":\"400 - bad request\"}"),
                                ContentType: "application/json",
                        })
                }</span>
                <span class="cov0" title="0">c.Vendor.Context.Publish("activation", v1alpha2.Event{
                        Body: activationData,
                })
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)

        return resp</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/models"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var mLog = logger.NewLogger("coa.runtime")

type ModelsVendor struct {
        vendors.Vendor
        ModelsManager *models.ModelsManager
}

func (o *ModelsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Models",
                Producer: "Microsoft",
        }
}</span>

func (e *ModelsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*models.ModelsManager); ok </span><span class="cov0" title="0">{
                        e.ModelsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.ModelsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "models manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *ModelsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "models"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onModels,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *ModelsVendor) onModels(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Models Vendor", request.Context, &amp;map[string]string{
                "method": "onModels",
        })
        defer span.End()
        tLog.Info("V (Models): onDevices")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onModels-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = c.ModelsManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = c.ModelsManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onModels-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var device model.DeviceSpec

                err := json.Unmarshal(request.Body, &amp;device)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov0" title="0">err = c.ModelsManager.UpsertSpec(ctx, id, device)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onModels-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.ModelsManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"
        "strings"

        api_utils "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/config"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var csLog = logger.NewLogger("coa.runtime")

type SettingsVendor struct {
        vendors.Vendor
        EvaluationContext *utils.EvaluationContext
}

func (e *SettingsVendor) GetInfo() vendors.VendorInfo <span class="cov8" title="1">{
        return vendors.VendorInfo{
                Version:  e.Vendor.Version,
                Name:     "Settings",
                Producer: "Microsoft",
        }
}</span>
func (e *SettingsVendor) Init(cfg vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov8" title="1">{
        err := e.Vendor.Init(cfg, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var configProvider config.IExtConfigProvider
        for _, m := range e.Managers </span><span class="cov8" title="1">{
                if c, ok := m.(config.IExtConfigProvider); ok </span><span class="cov8" title="1">{
                        configProvider = c
                }</span>
        }
        <span class="cov8" title="1">e.EvaluationContext = &amp;utils.EvaluationContext{
                ConfigProvider: configProvider,
        }
        return nil</span>
}
func (e *SettingsVendor) GetEvaluationContext() *utils.EvaluationContext <span class="cov8" title="1">{
        return e.EvaluationContext
}</span>
func (o *SettingsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov8" title="1">{
        route := "settings"
        if o.Route != "" </span><span class="cov8" title="1">{
                route = o.Route
        }</span>
        <span class="cov8" title="1">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet},
                        Route:      route + "/config",
                        Version:    o.Version,
                        Handler:    o.onConfig,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *SettingsVendor) onConfig(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        _, span := observability.StartSpan("Settings Vendor", request.Context, &amp;map[string]string{
                "method": "onConfig",
        })
        defer span.End()
        csLog.Info("V (Settings): onConfig")
        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov8" title="1">
                id := request.Parameters["__name"]
                overrides := request.Parameters["overrides"]
                field := request.Parameters["field"]
                var parts []string
                if overrides != "" </span><span class="cov0" title="0">{
                        parts = strings.Split(overrides, ",")
                }</span>
                <span class="cov8" title="1">if field != "" </span><span class="cov8" title="1">{
                        val, err := c.EvaluationContext.ConfigProvider.Get(id, field, parts, nil)
                        if err != nil </span><span class="cov8" title="1">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov8" title="1">data, _ := json.Marshal(val)
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.OK,
                                Body:        data,
                                ContentType: "text/plain",
                        })</span>
                } else<span class="cov8" title="1"> {
                        val, err := c.EvaluationContext.ConfigProvider.GetObject(id, parts, nil)
                        if err != nil </span><span class="cov8" title="1">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                        <span class="cov8" title="1">jData, _ := api_utils.FormatObject(val, false, "", "")
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.OK,
                                Body:        jData,
                                ContentType: "application/json",
                        })</span>
                }
        }
        <span class="cov8" title="1">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/skills"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var kLog = logger.NewLogger("coa.runtime")

type SkillsVendor struct {
        vendors.Vendor
        SkillsManager *skills.SkillsManager
}

func (o *SkillsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Skills",
                Producer: "Microsoft",
        }
}</span>

func (e *SkillsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*skills.SkillsManager); ok </span><span class="cov0" title="0">{
                        e.SkillsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.SkillsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "skills manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *SkillsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "skills"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onSkills,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *SkillsVendor) onSkills(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Skills Vendor", request.Context, &amp;map[string]string{
                "method": "onSkills",
        })
        defer span.End()
        tLog.Info("V (Skills): onSkills")

        switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSkills-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        state, err = c.SkillsManager.ListSpec(ctx)
                        isArray = true
                }</span> else<span class="cov0" title="0"> {
                        state, err = c.SkillsManager.GetSpec(ctx, id)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSkills-POST", pCtx, nil)
                id := request.Parameters["__name"]

                var device model.SkillSpec

                err := json.Unmarshal(request.Body, &amp;device)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>

                <span class="cov0" title="0">err = c.SkillsManager.UpsertSpec(ctx, id, device)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSkills-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.SkillsManager.DeleteSpec(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/solution"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/valyala/fasthttp"
)

type SolutionVendor struct {
        vendors.Vendor
        SolutionManager *solution.SolutionManager
}

func (o *SolutionVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Solution",
                Producer: "Microsoft",
        }
}</span>

func (e *SolutionVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*solution.SolutionManager); ok </span><span class="cov0" title="0">{
                        e.SolutionManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.SolutionManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "solution manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *SolutionVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "solution"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodPost, fasthttp.MethodGet, fasthttp.MethodDelete},
                        Route:   route + "/instances", //this route is to support ITargetProvider interface via a proxy provider
                        Version: o.Version,
                        Handler: o.onApplyDeployment,
                },
                {
                        Methods:    []string{fasthttp.MethodPost},
                        Route:      route + "/reconcile",
                        Version:    o.Version,
                        Parameters: []string{"delete?"},
                        Handler:    o.onReconcile,
                },
                {
                        Methods: []string{fasthttp.MethodGet, fasthttp.MethodPost},
                        Route:   route + "/queue",
                        Version: o.Version,
                        Handler: o.onQueue,
                },
        }</span>
}
func (c *SolutionVendor) onQueue(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        rContext, span := observability.StartSpan("Solution Vendor", request.Context, &amp;map[string]string{
                "method": "onQueue",
        })
        defer span.End()

        log.Info("V (Solution): onQueue")

        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onQueue-GET", rContext, nil)
                defer span.End()
                instance := request.Parameters["instance"]

                if instance == "" </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.BadRequest,
                                Body:        []byte("{\"result\":\"400 - instance parameter is not found\"}"),
                                ContentType: "application/json",
                        })
                }</span>
                <span class="cov0" title="0">summary, err := c.SolutionManager.GetSummary(ctx, instance, scope)
                data, _ := json.Marshal(summary)
                if err != nil </span><span class="cov0" title="0">{
                        if v1alpha2.IsNotFound(err) </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.NotFound,
                                        Body:  data,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  data,
                                })
                        }</span>
                }
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        data,
                        ContentType: "application/json",
                })</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                _, span := observability.StartSpan("onQueue-POST", rContext, nil)
                defer span.End()
                instance := request.Parameters["instance"]
                delete := request.Parameters["delete"]
                target := request.Parameters["target"]
                if instance == "" </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State:       v1alpha2.BadRequest,
                                Body:        []byte("{\"result\":\"400 - instance parameter is not found\"}"),
                                ContentType: "application/json",
                        })
                }</span>
                <span class="cov0" title="0">action := "UPDATE"
                if delete == "true" </span><span class="cov0" title="0">{
                        action = "DELETE"
                }</span>
                <span class="cov0" title="0">objType := "instance"
                if target == "true" </span><span class="cov0" title="0">{
                        objType = "target"
                }</span>
                <span class="cov0" title="0">c.Vendor.Context.Publish("job", v1alpha2.Event{
                        Metadata: map[string]string{
                                "objectType": objType,
                                "scope":      scope,
                        },
                        Body: v1alpha2.JobData{
                                Id:     instance,
                                Action: action,
                        },
                })
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        []byte("{\"result\":\"200 - instance reconcilation job accepted\"}"),
                        ContentType: "application/json",
                })</span>
        }
        <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        })</span>
}
func (c *SolutionVendor) onReconcile(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        rContext, span := observability.StartSpan("Solution Vendor", request.Context, &amp;map[string]string{
                "method": "onReconcile",
        })
        defer span.End()

        log.Info("V (Solution): onReconcile")
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov8" title="1">{
                scope = "default"
        }</span>
        <span class="cov8" title="1">switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("onReconcile-POST", rContext, nil)
                defer span.End()
                var deployment model.DeploymentSpec
                err := json.Unmarshal(request.Body, &amp;deployment)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov8" title="1">delete := request.Parameters["delete"]
                summary, err := c.SolutionManager.Reconcile(ctx, deployment, delete == "true", scope)
                data, _ := json.Marshal(summary)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  data,
                        })
                }</span>
                <span class="cov8" title="1">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        data,
                        ContentType: "application/json",
                })</span>
        }
        <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        })</span>
}

func (c *SolutionVendor) onApplyDeployment(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        _, span := observability.StartSpan("Solution Vendor", request.Context, &amp;map[string]string{
                "method": "onApplyDeployment",
        })
        defer span.End()

        log.Infof("V (Solution): received request %s", request.Method)
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov8" title="1">{
                scope = "default"
        }</span>
        <span class="cov8" title="1">switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Apply Deployment", request.Context, nil)
                defer span.End()
                deployment := new(model.DeploymentSpec)
                err := json.Unmarshal(request.Body, &amp;deployment)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        }
                }</span>
                <span class="cov8" title="1">response := c.doDeploy(ctx, *deployment, scope)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        case fasthttp.MethodGet:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Get Components", request.Context, nil)
                defer span.End()
                deployment := new(model.DeploymentSpec)
                err := json.Unmarshal(request.Body, &amp;deployment)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        }
                }</span>
                <span class="cov8" title="1">response := c.doGet(ctx, *deployment)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        case fasthttp.MethodDelete:<span class="cov8" title="1">
                ctx, span := observability.StartSpan("Delete Components", request.Context, nil)
                defer span.End()
                var deployment model.DeploymentSpec
                err := json.Unmarshal(request.Body, &amp;deployment)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        }
                }</span>
                <span class="cov8" title="1">response := c.doRemove(ctx, deployment, scope)
                return observ_utils.CloseSpanWithCOAResponse(span, response)</span>
        }

        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *SolutionVendor) doGet(ctx context.Context, deployment model.DeploymentSpec) v1alpha2.COAResponse <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solution Vendor", ctx, &amp;map[string]string{
                "method": "doGet",
        })
        defer span.End()
        _, components, err := c.SolutionManager.Get(ctx, deployment)
        if err != nil </span><span class="cov0" title="0">{
                response := v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                }
                observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
                return response
        }</span>
        <span class="cov8" title="1">data, _ := json.Marshal(components)
        response := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        data,
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
        return response</span>
}
func (c *SolutionVendor) doDeploy(ctx context.Context, deployment model.DeploymentSpec, scope string) v1alpha2.COAResponse <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solution Vendor", ctx, &amp;map[string]string{
                "method": "doDeploy",
        })
        defer span.End()
        summary, err := c.SolutionManager.Reconcile(ctx, deployment, false, scope)
        data, _ := json.Marshal(summary)
        if err != nil </span><span class="cov0" title="0">{
                response := v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  data,
                }
                observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
                return response
        }</span>
        <span class="cov8" title="1">response := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        data,
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
        return response</span>
}
func (c *SolutionVendor) doRemove(ctx context.Context, deployment model.DeploymentSpec, scope string) v1alpha2.COAResponse <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Solution Vendor", ctx, &amp;map[string]string{
                "method": "doRemove",
        })
        defer span.End()

        summary, err := c.SolutionManager.Reconcile(ctx, deployment, true, scope)
        data, _ := json.Marshal(summary)
        if err != nil </span><span class="cov0" title="0">{
                response := v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  data,
                }
                observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
                return response
        }</span>
        <span class="cov8" title="1">response := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        data,
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, response)
        return response</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/solutions"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var uLog = logger.NewLogger("coa.runtime")

type SolutionsVendor struct {
        vendors.Vendor
        SolutionsManager *solutions.SolutionsManager
}

func (o *SolutionsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Solutions",
                Producer: "Microsoft",
        }
}</span>

func (e *SolutionsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*solutions.SolutionsManager); ok </span><span class="cov0" title="0">{
                        e.SolutionsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.SolutionsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "solutions manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *SolutionsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "solutions"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route,
                        Version:    o.Version,
                        Handler:    o.onSolutions,
                        Parameters: []string{"name?"},
                },
        }</span>
}

func (c *SolutionsVendor) onSolutions(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Solutions Vendor", request.Context, &amp;map[string]string{
                "method": "onSolutions",
        })
        defer span.End()
        tLog.Info("V (Solutions): onSolutions")
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSolutions-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        // Change scope back to empty to indicate ListSpec need to query all namespaces
                        if !exist </span><span class="cov0" title="0">{
                                scope = ""
                        }</span>
                        <span class="cov0" title="0">state, err = c.SolutionsManager.ListSpec(ctx, scope)
                        isArray = true</span>
                } else<span class="cov0" title="0"> {
                        state, err = c.SolutionsManager.GetSpec(ctx, id, scope)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSolutions-POST", pCtx, nil)
                id := request.Parameters["__name"]

                embed_type := request.Parameters["embed-type"]
                embed_component := request.Parameters["embed-component"]
                embed_property := request.Parameters["embed-property"]

                var solution model.SolutionSpec

                if embed_type != "" &amp;&amp; embed_component != "" &amp;&amp; embed_property != "" </span><span class="cov0" title="0">{
                        solution = model.SolutionSpec{
                                DisplayName: id,
                                Components: []model.ComponentSpec{
                                        {
                                                Name: embed_component,
                                                Type: embed_type,
                                                Properties: map[string]interface{}{
                                                        embed_property: string(request.Body),
                                                },
                                        },
                                },
                        }
                }</span> else<span class="cov0" title="0"> {
                        err := json.Unmarshal(request.Body, &amp;solution)
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                }
                <span class="cov0" title="0">err := c.SolutionsManager.UpsertSpec(ctx, id, solution, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                // TODO: this is a PoC of publishing trails when an object is updated
                <span class="cov0" title="0">c.Vendor.Context.Publish("trail", v1alpha2.Event{
                        Body: []v1alpha2.Trail{
                                {
                                        Origin:  c.Vendor.Context.SiteInfo.SiteId,
                                        Catalog: solution.Metadata["catalog"],
                                        Type:    "solutions.solution.symphony/v1",
                                        Properties: map[string]interface{}{
                                                "spec": solution,
                                        },
                                },
                        },
                        Metadata: map[string]string{
                                "scope": scope,
                        },
                })
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onSolutions-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                err := c.SolutionsManager.DeleteSpec(ctx, id, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/activations"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/campaigns"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/stage"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/materialize"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/mock"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/providers/stage/wait"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
)

var sLog = logger.NewLogger("coa.runtime")

type StageVendor struct {
        vendors.Vendor
        StageManager       *stage.StageManager
        CampaignsManager   *campaigns.CampaignsManager
        ActivationsManager *activations.ActivationsManager
}

func (s *StageVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  s.Vendor.Version,
                Name:     "Stage",
                Producer: "Microsoft",
        }
}</span>

func (o *StageVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        return []v1alpha2.Endpoint{}
}</span>

func (s *StageVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := s.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range s.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*stage.StageManager); ok </span><span class="cov0" title="0">{
                        s.StageManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*campaigns.CampaignsManager); ok </span><span class="cov0" title="0">{
                        s.CampaignsManager = c
                }</span>
                <span class="cov0" title="0">if c, ok := m.(*activations.ActivationsManager); ok </span><span class="cov0" title="0">{
                        s.ActivationsManager = c
                }</span>
        }
        <span class="cov0" title="0">if s.StageManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "stage manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">if s.CampaignsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "campaigns manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">if s.ActivationsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "activations manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">s.Vendor.Context.Subscribe("activation", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                log.Info("V (Stage): handling activation event")
                var actData v1alpha2.ActivationData
                jData, _ := json.Marshal(event.Body)
                err := json.Unmarshal(jData, &amp;actData)
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha2.NewCOAError(nil, "event body is not an activation job", v1alpha2.BadRequest)
                }</span>
                <span class="cov0" title="0">campaign, err := s.CampaignsManager.GetSpec(context.TODO(), actData.Campaign)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("V (Stage): unable to find campaign: %+v", err)
                        return err
                }</span>
                <span class="cov0" title="0">activation, err := s.ActivationsManager.GetSpec(context.TODO(), actData.Activation)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("V (Stage): unable to find activation: %+v", err)
                        return err
                }</span>

                <span class="cov0" title="0">evt, err := s.StageManager.HandleActivationEvent(context.TODO(), actData, *campaign.Spec, activation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if evt != nil </span><span class="cov0" title="0">{
                        s.Vendor.Context.Publish("trigger", v1alpha2.Event{
                                Body: *evt,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">s.Vendor.Context.Subscribe("trigger", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                log.Info("V (Stage): handling trigger event")
                status := model.ActivationStatus{
                        Stage:        "",
                        NextStage:    "",
                        Outputs:      nil,
                        Status:       v1alpha2.Untouched,
                        ErrorMessage: "",
                        IsActive:     true,
                }
                triggerData := v1alpha2.ActivationData{}
                jData, _ := json.Marshal(event.Body)
                err := json.Unmarshal(jData, &amp;triggerData)
                if err != nil </span><span class="cov0" title="0">{
                        err = v1alpha2.NewCOAError(nil, "event body is not an activation job", v1alpha2.BadRequest)
                        status.Status = v1alpha2.BadRequest
                        status.ErrorMessage = err.Error()
                        status.IsActive = false
                        sLog.Errorf("V (Stage): failed to deserialize activation data: %v", err)
                        err = s.ActivationsManager.ReportStatus(context.TODO(), triggerData.Activation, status)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("V (Stage): failed to report error status: %v (%v)", status.ErrorMessage, err)
                        }</span>
                }
                <span class="cov0" title="0">campaign, err := s.CampaignsManager.GetSpec(context.TODO(), triggerData.Campaign)
                if err != nil </span><span class="cov0" title="0">{
                        status.Status = v1alpha2.BadRequest
                        status.ErrorMessage = err.Error()
                        status.IsActive = false
                        sLog.Errorf("V (Stage): failed to get campaign spec: %v", err)
                        err = s.ActivationsManager.ReportStatus(context.TODO(), triggerData.Activation, status)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("V (Stage): failed to report error status: %v (%v)", status.ErrorMessage, err)
                        }</span>
                }
                <span class="cov0" title="0">status.Stage = triggerData.Stage
                status.ActivationGeneration = triggerData.ActivationGeneration
                status.ErrorMessage = ""
                status.Status = v1alpha2.Running
                if triggerData.NeedsReport </span><span class="cov0" title="0">{
                        sLog.Debugf("V (Stage): reporting status: %v", status)
                        s.Vendor.Context.Publish("report", v1alpha2.Event{
                                Body: status,
                        })
                }</span> else<span class="cov0" title="0"> {
                        err = s.ActivationsManager.ReportStatus(context.TODO(), triggerData.Activation, status)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("V (Stage): failed to report accepted status: %v (%v)", status.ErrorMessage, err)
                                return err
                        }</span>
                }

                <span class="cov0" title="0">status, activation := s.StageManager.HandleTriggerEvent(context.TODO(), *campaign.Spec, triggerData)

                if triggerData.NeedsReport </span><span class="cov0" title="0">{
                        sLog.Debugf("V (Stage): reporting status: %v", status)
                        s.Vendor.Context.Publish("report", v1alpha2.Event{
                                Body: status,
                        })

                }</span> else<span class="cov0" title="0"> {
                        err = s.ActivationsManager.ReportStatus(context.TODO(), triggerData.Activation, status)
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("V (Stage): failed to report status: %v (%v)", status.ErrorMessage, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">if activation != nil &amp;&amp; status.Status != v1alpha2.Done &amp;&amp; status.Status != v1alpha2.Paused </span><span class="cov0" title="0">{
                                s.Vendor.Context.Publish("trigger", v1alpha2.Event{
                                        Body: *activation,
                                })
                        }</span>
                }
                <span class="cov0" title="0">log.Info("V (Stage): Finished handling trigger event")
                return nil</span>
        })
        <span class="cov0" title="0">s.Vendor.Context.Subscribe("job-report", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                sLog.Debugf("V (Stage): handling job report event: %v", event)
                jData, _ := json.Marshal(event.Body)
                var status model.ActivationStatus
                json.Unmarshal(jData, &amp;status)
                if status.Status == v1alpha2.Done || status.Status == v1alpha2.OK </span><span class="cov0" title="0">{
                        campaign, err := s.CampaignsManager.GetSpec(context.TODO(), status.Outputs["__campaign"].(string))
                        if err != nil </span><span class="cov0" title="0">{
                                sLog.Errorf("V (Stage): failed to get campaign spec '%s': %v", status.Outputs["__campaign"].(string), err)
                                return err
                        }</span>
                        <span class="cov0" title="0">if campaign.Spec.SelfDriving </span><span class="cov0" title="0">{
                                activation, err := s.StageManager.ResumeStage(status, *campaign.Spec)
                                if err != nil </span><span class="cov0" title="0">{
                                        status.Status = v1alpha2.InternalError
                                        status.IsActive = false
                                        status.ErrorMessage = fmt.Sprintf("failed to resume stage: %v", err)
                                        sLog.Errorf("V (Stage): failed to resume stage: %v", err)
                                }</span>
                                <span class="cov0" title="0">if activation != nil </span><span class="cov0" title="0">{
                                        s.Vendor.Context.Publish("trigger", v1alpha2.Event{
                                                Body: *activation,
                                        })
                                }</span>
                        }
                }

                //TODO: later site overrides reports from earlier sites
                <span class="cov0" title="0">err = s.ActivationsManager.ReportStatus(context.TODO(), status.Outputs["__activation"].(string), status)
                if err != nil </span><span class="cov0" title="0">{
                        sLog.Errorf("V (Stage): failed to report status: %v (%v)", status.ErrorMessage, err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">s.Vendor.Context.Subscribe("remote-job", func(topic string, event v1alpha2.Event) error </span><span class="cov0" title="0">{
                // Unwrap data package from event body
                jData, _ := json.Marshal(event.Body)
                var job v1alpha2.JobData
                json.Unmarshal(jData, &amp;job)
                jData, _ = json.Marshal(job.Body)
                var dataPackage v1alpha2.InputOutputData
                err := json.Unmarshal(jData, &amp;dataPackage)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // restore schedule
                <span class="cov0" title="0">var schedule *v1alpha2.ScheduleSpec
                if v, ok := dataPackage.Inputs["__schedule"]; ok </span><span class="cov0" title="0">{
                        err = json.Unmarshal([]byte(v.(string)), &amp;schedule)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">triggerData := v1alpha2.ActivationData{
                        Activation:           dataPackage.Inputs["__activation"].(string),
                        ActivationGeneration: dataPackage.Inputs["__activationGeneration"].(string),
                        Campaign:             dataPackage.Inputs["__campaign"].(string),
                        Stage:                dataPackage.Inputs["__stage"].(string),
                        Inputs:               dataPackage.Inputs,
                        Outputs:              dataPackage.Outputs,
                        Schedule:             schedule,
                        NeedsReport:          true,
                }

                triggerData.Inputs["__origin"] = event.Metadata["origin"]

                switch dataPackage.Inputs["operation"] </span>{
                case "wait":<span class="cov0" title="0">
                        triggerData.Provider = "providers.stage.wait"
                        config, err := wait.WaitStageProviderConfigFromVendorMap(s.Vendor.Config.Properties)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">triggerData.Config = config</span>
                case "materialize":<span class="cov0" title="0">
                        triggerData.Provider = "providers.stage.materialize"
                        config, err := materialize.MaterializeStageProviderConfigFromVendorMap(s.Vendor.Config.Properties)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">triggerData.Config = config</span>
                case "mock":<span class="cov0" title="0">
                        triggerData.Provider = "providers.stage.mock"
                        config, err := mock.MockStageProviderConfigFromMap(s.Vendor.Config.Properties)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">triggerData.Config = config</span>
                default:<span class="cov0" title="0">
                        return v1alpha2.NewCOAError(nil, fmt.Sprintf("operation %v is not supported", dataPackage.Inputs["operation"]), v1alpha2.BadRequest)</span>
                }
                <span class="cov0" title="0">status := s.StageManager.HandleDirectTriggerEvent(context.TODO(), triggerData)
                sLog.Debugf("V (Stage): reporting status: %v", status)
                s.Vendor.Context.Publish("report", v1alpha2.Event{
                        Body: status,
                })
                return nil</span>
        })
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var gLog = logger.NewLogger("coa.runtime")

type StagingVendor struct {
        vendors.Vendor
}

func (f *StagingVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  f.Vendor.Version,
                Name:     "Staging",
                Producer: "Microsoft",
        }
}</span>
func (f *StagingVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := f.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (f *StagingVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "federation"
        if f.Route != "" </span><span class="cov0" title="0">{
                route = f.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:   route + "/download",
                        Version: f.Version,
                        Handler: f.onDownload,
                },
        }</span>
}
func (f *StagingVendor) onDownload(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Staging Vendor", request.Context, &amp;map[string]string{
                "method": "onDownload",
        })
        defer span.End()

        resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        return resp
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"
        "strings"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/targets"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/model"
        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/golang-jwt/jwt/v4"
        "github.com/valyala/fasthttp"
)

var tLog = logger.NewLogger("coa.runtime")

type TargetsVendor struct {
        vendors.Vendor
        TargetsManager *targets.TargetsManager
}

func (o *TargetsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Targets",
                Producer: "Microsoft",
        }
}</span>

func (e *TargetsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*targets.TargetsManager); ok </span><span class="cov0" title="0">{
                        e.TargetsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.TargetsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "targets manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *TargetsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "targets"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods:    []string{fasthttp.MethodGet, fasthttp.MethodPost, fasthttp.MethodDelete},
                        Route:      route + "/registry",
                        Version:    o.Version,
                        Handler:    o.onRegistry,
                        Parameters: []string{"name?"},
                },
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/bootstrap",
                        Version: o.Version,
                        Handler: o.onBootstrap,
                },
                {
                        Methods:    []string{fasthttp.MethodGet},
                        Route:      route + "/ping",
                        Version:    o.Version,
                        Handler:    o.onHeartBeat,
                        Parameters: []string{"name"},
                },
                {
                        Methods:    []string{fasthttp.MethodPut},
                        Route:      route + "/status",
                        Version:    o.Version,
                        Handler:    o.onStatus,
                        Parameters: []string{"name", "component?"},
                },
                {
                        Methods:    []string{fasthttp.MethodGet},
                        Route:      route + "/download",
                        Version:    o.Version,
                        Handler:    o.onDownload,
                        Parameters: []string{"doc-type", "name"},
                },
        }</span>
}

type MyCustomClaims struct {
        User string `json:"user"`
        jwt.RegisteredClaims
}
type AuthRequest struct {
        UserName string `json:"username"`
        Password string `json:"password"`
}

func (c *TargetsVendor) onRegistry(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Targets Vendor", request.Context, &amp;map[string]string{
                "method": "onRegistry",
        })
        defer span.End()
        tLog.Info("V (Targets) : onRegistry")
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">switch request.Method </span>{
        case fasthttp.MethodGet:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-GET", pCtx, nil)
                id := request.Parameters["__name"]
                var err error
                var state interface{}
                isArray := false
                if id == "" </span><span class="cov0" title="0">{
                        // Change scope back to empty to indicate ListSpec need to query all namespaces
                        if !exist </span><span class="cov0" title="0">{
                                scope = ""
                        }</span>
                        <span class="cov0" title="0">state, err = c.TargetsManager.ListSpec(ctx, scope)
                        isArray = true</span>
                } else<span class="cov0" title="0"> {
                        state, err = c.TargetsManager.GetSpec(ctx, id, scope)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">jData, _ := utils.FormatObject(state, isArray, request.Parameters["path"], request.Parameters["doc-type"])
                resp := observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State:       v1alpha2.OK,
                        Body:        jData,
                        ContentType: "application/json",
                })
                if request.Parameters["doc-type"] == "yaml" </span><span class="cov0" title="0">{
                        resp.ContentType = "application/text"
                }</span>
                <span class="cov0" title="0">return resp</span>
        case fasthttp.MethodPost:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-POST", pCtx, nil)
                id := request.Parameters["__name"]
                binding := request.Parameters["with-binding"]
                var target model.TargetSpec
                err := json.Unmarshal(request.Body, &amp;target)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">if binding != "" </span><span class="cov0" title="0">{
                        if binding == "staging" </span><span class="cov0" title="0">{
                                target.ForceRedeploy = true
                                if target.Topologies == nil </span><span class="cov0" title="0">{
                                        target.Topologies = make([]model.TopologySpec, 0)
                                }</span>
                                <span class="cov0" title="0">found := false
                                for _, t := range target.Topologies </span><span class="cov0" title="0">{
                                        if t.Bindings != nil </span><span class="cov0" title="0">{
                                                for _, b := range t.Bindings </span><span class="cov0" title="0">{
                                                        if b.Role == "instance" &amp;&amp; b.Provider == "providers.target.staging" </span><span class="cov0" title="0">{
                                                                found = true
                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        newb := model.BindingSpec{
                                                Role:     "instance",
                                                Provider: "providers.target.staging",
                                                Config: map[string]string{
                                                        "inCluster":  "true",
                                                        "targetName": id,
                                                },
                                        }
                                        if len(target.Topologies) == 0 </span><span class="cov0" title="0">{
                                                target.Topologies = append(target.Topologies, model.TopologySpec{})
                                        }</span>
                                        <span class="cov0" title="0">if target.Topologies[len(target.Topologies)-1].Bindings == nil </span><span class="cov0" title="0">{
                                                target.Topologies[len(target.Topologies)-1].Bindings = make([]model.BindingSpec, 0)
                                        }</span>
                                        <span class="cov0" title="0">target.Topologies[len(target.Topologies)-1].Bindings = append(target.Topologies[len(target.Topologies)-1].Bindings, newb)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.BadRequest,
                                        Body:  []byte("invalid binding, supported is: 'staging'"),
                                })
                        }</span>
                }
                <span class="cov0" title="0">err = c.TargetsManager.UpsertSpec(ctx, id, scope, target)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">if c.Config.Properties["useJobManager"] == "true" </span><span class="cov0" title="0">{
                        c.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "target",
                                        "scope":      scope,
                                },
                                Body: v1alpha2.JobData{
                                        Id:     id,
                                        Action: "UPDATE",
                                },
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        case fasthttp.MethodDelete:<span class="cov0" title="0">
                ctx, span := observability.StartSpan("onRegistry-DELETE", pCtx, nil)
                id := request.Parameters["__name"]
                direct := request.Parameters["direct"]

                if c.Config.Properties["useJobManager"] == "true" &amp;&amp; direct != "true" </span><span class="cov0" title="0">{
                        c.Context.Publish("job", v1alpha2.Event{
                                Metadata: map[string]string{
                                        "objectType": "target",
                                        "scope":      scope,
                                },
                                Body: v1alpha2.JobData{
                                        Id:     id,
                                        Action: "DELETE",
                                },
                        })
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.OK,
                        })
                }</span> else<span class="cov0" title="0"> {
                        err := c.TargetsManager.DeleteSpec(ctx, id, scope)
                        if err != nil </span><span class="cov0" title="0">{
                                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                        State: v1alpha2.InternalError,
                                        Body:  []byte(err.Error()),
                                })
                        }</span>
                }
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *TargetsVendor) onBootstrap(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        _, span := observability.StartSpan("Targets Vendor", request.Context, &amp;map[string]string{
                "method": "onBootstrap",
        })
        defer span.End()

        var authRequest AuthRequest
        err := json.Unmarshal(request.Body, &amp;authRequest)
        if err != nil || authRequest.UserName != "symphony-test" </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.Unauthorized,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov0" title="0">mySigningKey := []byte("SymphonyKey")
        claims := MyCustomClaims{
                authRequest.UserName,
                jwt.RegisteredClaims{
                        // A usual scenario is to set the expiration time relative to the current time
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "symphony",
                        Subject:   "symphony",
                        ID:        "1",
                        Audience:  []string{"*"},
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        ss, _ := token.SignedString(mySigningKey)

        resp := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        []byte(`{"accessToken":"` + ss + `", "tokenType": "Bearer"}`),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *TargetsVendor) onStatus(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Targets Vendor", request.Context, &amp;map[string]string{
                "method": "onStatus",
        })
        defer span.End()
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">var dict map[string]interface{}
        json.Unmarshal(request.Body, &amp;dict)

        properties := make(map[string]string)
        if k, ok := dict["status"]; ok </span><span class="cov0" title="0">{
                var insideKey map[string]interface{}
                j, _ := json.Marshal(k)
                json.Unmarshal(j, &amp;insideKey)
                if p, ok := insideKey["properties"]; ok </span><span class="cov0" title="0">{
                        jk, _ := json.Marshal(p)
                        json.Unmarshal(jk, &amp;properties)
                }</span>
        }

        <span class="cov0" title="0">for k, v := range request.Parameters </span><span class="cov0" title="0">{
                if !strings.HasPrefix(k, "__") </span><span class="cov0" title="0">{
                        properties[k] = v
                }</span>
        }

        <span class="cov0" title="0">state, err := c.TargetsManager.ReportState(pCtx, model.TargetState{
                Id: request.Parameters["__name"],
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "targets",
                        "scope":    scope,
                },
                Status: properties,
        })

        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov0" title="0">jData, _ := json.Marshal(state)
        resp := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        jData,
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *TargetsVendor) onDownload(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Targets Vendor", request.Context, &amp;map[string]string{
                "method": "onDownload",
        })
        defer span.End()
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">state, err := c.TargetsManager.GetSpec(pCtx, request.Parameters["__name"], scope)
        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov0" title="0">jData, err := utils.FormatObject(state, false, request.Parameters["path"], request.Parameters["__doc-type"])
        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        jData,
                ContentType: "application/json",
        }

        if request.Parameters["__doc-type"] == "yaml" </span><span class="cov0" title="0">{
                resp.ContentType = "application/text"
        }</span>

        <span class="cov0" title="0">observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}

func (c *TargetsVendor) onHeartBeat(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Targets Vendor", request.Context, &amp;map[string]string{
                "method": "onHeartBeat",
        })
        defer span.End()
        scope, exist := request.Parameters["scope"]
        if !exist </span><span class="cov0" title="0">{
                scope = "default"
        }</span>
        <span class="cov0" title="0">_, err := c.TargetsManager.ReportState(pCtx, model.TargetState{
                Id: request.Parameters["__name"],
                Metadata: map[string]string{
                        "version":  "v1",
                        "group":    model.FabricGroup,
                        "resource": "targets",
                        "scope":    scope,
                },
                Status: map[string]string{
                        "ping": time.Now().UTC().String(),
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.InternalError,
                        Body:  []byte(err.Error()),
                })
        }</span>

        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        []byte(`{}`),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "encoding/json"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/trails"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/valyala/fasthttp"
)

var trLog = logger.NewLogger("coa.runtime")

type TrailsVendor struct {
        vendors.Vendor
        TrailsManager *trails.TrailsManager
}

func (o *TrailsVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Trails",
                Producer: "Microsoft",
        }
}</span>

func (e *TrailsVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov0" title="0">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, m := range e.Managers </span><span class="cov0" title="0">{
                if c, ok := m.(*trails.TrailsManager); ok </span><span class="cov0" title="0">{
                        e.TrailsManager = c
                }</span>
        }
        <span class="cov0" title="0">if e.TrailsManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "trails manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *TrailsVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov0" title="0">{
        route := "trails"
        if o.Route != "" </span><span class="cov0" title="0">{
                route = o.Route
        }</span>
        <span class="cov0" title="0">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route,
                        Version: o.Version,
                        Handler: o.onTrails,
                },
        }</span>
}

func (c *TrailsVendor) onTrails(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov0" title="0">{
        pCtx, span := observability.StartSpan("Trails Vendor", request.Context, &amp;map[string]string{
                "method": "onTrails",
        })
        defer span.End()
        tLog.Info("V (Trails) : onTrails")

        switch request.Method </span>{
        case fasthttp.MethodPost:<span class="cov0" title="0">
                var trails []v1alpha2.Trail
                err := json.Unmarshal(request.Body, &amp;trails)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">err = c.TrailsManager.Append(pCtx, trails)
                if err != nil </span><span class="cov0" title="0">{
                        return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                                State: v1alpha2.InternalError,
                                Body:  []byte(err.Error()),
                        })
                }</span>
                <span class="cov0" title="0">return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.OK,
                        Body:  []byte("{\"result\":\"ok\"}"),
                })</span>
        }
        <span class="cov0" title="0">resp := v1alpha2.COAResponse{
                State:       v1alpha2.MethodNotAllowed,
                Body:        []byte("{\"result\":\"405 - method not allowed\"}"),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/eclipse-symphony/symphony/api/pkg/apis/v1alpha1/managers/users"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/managers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability"
        observ_utils "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/observability/utils"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/providers/pubsub"
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
        "github.com/eclipse-symphony/symphony/coa/pkg/logger"
        "github.com/golang-jwt/jwt/v4"
        "github.com/valyala/fasthttp"
)

var rLog = logger.NewLogger("coa.runtime")

type UsersVendor struct {
        vendors.Vendor
        UsersManager *users.UsersManager
}

func (o *UsersVendor) GetInfo() vendors.VendorInfo <span class="cov0" title="0">{
        return vendors.VendorInfo{
                Version:  o.Vendor.Version,
                Name:     "Users",
                Producer: "Microsoft",
        }
}</span>

func (e *UsersVendor) Init(config vendors.VendorConfig, factories []managers.IManagerFactroy, providers map[string]map[string]providers.IProvider, pubsubProvider pubsub.IPubSubProvider) error <span class="cov8" title="1">{
        err := e.Vendor.Init(config, factories, providers, pubsubProvider)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, m := range e.Managers </span><span class="cov8" title="1">{
                if c, ok := m.(*users.UsersManager); ok </span><span class="cov8" title="1">{
                        e.UsersManager = c
                }</span>
        }
        <span class="cov8" title="1">if e.UsersManager == nil </span><span class="cov0" title="0">{
                return v1alpha2.NewCOAError(nil, "users manager is not supplied", v1alpha2.MissingConfig)
        }</span>
        <span class="cov8" title="1">if config.Properties != nil &amp;&amp; config.Properties["test-users"] == "true" </span><span class="cov8" title="1">{
                e.UsersManager.UpsertUser(context.Background(), "admin", "", nil)
                e.UsersManager.UpsertUser(context.Background(), "reader", "", nil)
                e.UsersManager.UpsertUser(context.Background(), "developer", "", nil)
                e.UsersManager.UpsertUser(context.Background(), "device-manager", "", nil)
                e.UsersManager.UpsertUser(context.Background(), "operator", "", nil)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *UsersVendor) GetEndpoints() []v1alpha2.Endpoint <span class="cov8" title="1">{
        route := "users"
        if o.Route != "" </span><span class="cov8" title="1">{
                route = o.Route
        }</span>
        <span class="cov8" title="1">return []v1alpha2.Endpoint{
                {
                        Methods: []string{fasthttp.MethodPost},
                        Route:   route + "/auth",
                        Version: o.Version,
                        Handler: o.onAuth,
                },
        }</span>
}

func (c *UsersVendor) onAuth(request v1alpha2.COARequest) v1alpha2.COAResponse <span class="cov8" title="1">{
        ctx, span := observability.StartSpan("Users Vendor", request.Context, &amp;map[string]string{
                "method": "onAuth",
        })
        defer span.End()
        log.Debug("V (Users): authenticate user")

        var authRequest AuthRequest
        err := json.Unmarshal(request.Body, &amp;authRequest)
        if err != nil </span><span class="cov0" title="0">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.Unauthorized,
                        Body:  []byte(err.Error()),
                })
        }</span>
        <span class="cov8" title="1">roles, b := c.UsersManager.CheckUser(ctx, authRequest.UserName, authRequest.Password)
        if !b </span><span class="cov8" title="1">{
                return observ_utils.CloseSpanWithCOAResponse(span, v1alpha2.COAResponse{
                        State: v1alpha2.Unauthorized,
                        Body:  []byte("login failed"),
                })
        }</span>

        <span class="cov8" title="1">mySigningKey := []byte("SymphonyKey")
        claims := MyCustomClaims{
                authRequest.UserName,
                jwt.RegisteredClaims{
                        // A usual scenario is to set the expiration time relative to the current time
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "symphony",
                        Subject:   "symphony",
                        ID:        "1",
                        Audience:  []string{"*"},
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        ss, _ := token.SignedString(mySigningKey)

        rolesJSON, _ := json.Marshal(roles)
        resp := v1alpha2.COAResponse{
                State:       v1alpha2.OK,
                Body:        []byte(fmt.Sprintf(`{"accessToken":"%s", "tokenType": "Bearer", "username": "%s", "roles": %s}`, ss, authRequest.UserName, rolesJSON)),
                ContentType: "application/json",
        }
        observ_utils.UpdateSpanStatusFromCOAResponse(span, resp)
        return resp</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * SPDX-License-Identifier: MIT
 */

package vendors

import (
        "github.com/eclipse-symphony/symphony/coa/pkg/apis/v1alpha2/vendors"
)

type SymphonyVendorFactory struct {
}

func (c SymphonyVendorFactory) CreateVendor(config vendors.VendorConfig) (vendors.IVendor, error) <span class="cov0" title="0">{
        switch config.Type </span>{
        case "vendors.echo":<span class="cov0" title="0">
                return &amp;EchoVendor{}, nil</span>
        case "vendors.solution":<span class="cov0" title="0">
                return &amp;SolutionVendor{}, nil</span>
        case "vendors.agent":<span class="cov0" title="0">
                return &amp;AgentVendor{}, nil</span>
        case "vendors.targets":<span class="cov0" title="0">
                return &amp;TargetsVendor{}, nil</span>
        case "vendors.instances":<span class="cov0" title="0">
                return &amp;InstancesVendor{}, nil</span>
        case "vendors.devices":<span class="cov0" title="0">
                return &amp;DevicesVendor{}, nil</span>
        case "vendors.solutions":<span class="cov0" title="0">
                return &amp;SolutionsVendor{}, nil</span>
        case "vendors.campaigns":<span class="cov0" title="0">
                return &amp;CampaignsVendor{}, nil</span>
        case "vendors.catalogs":<span class="cov0" title="0">
                return &amp;CatalogsVendor{}, nil</span>
        case "vendors.activations":<span class="cov0" title="0">
                return &amp;ActivationsVendor{}, nil</span>
        case "vendors.users":<span class="cov0" title="0">
                return &amp;UsersVendor{}, nil</span>
        case "vendors.jobs":<span class="cov0" title="0">
                return &amp;JobVendor{}, nil</span>
        case "vendors.stage":<span class="cov0" title="0">
                return &amp;StageVendor{}, nil</span>
        case "vendors.federation":<span class="cov0" title="0">
                return &amp;FederationVendor{}, nil</span>
        case "vendors.staging":<span class="cov0" title="0">
                return &amp;StagingVendor{}, nil</span>
        case "vendors.models":<span class="cov0" title="0">
                return &amp;ModelsVendor{}, nil</span>
        case "vendors.skills":<span class="cov0" title="0">
                return &amp;SkillsVendor{}, nil</span>
        case "vendors.settings":<span class="cov0" title="0">
                return &amp;SettingsVendor{}, nil</span>
        case "vendors.trails":<span class="cov0" title="0">
                return &amp;TrailsVendor{}, nil</span>
        case "vendors.backgroundjob":<span class="cov0" title="0">
                return &amp;BackgroundJobVendor{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, nil</span> //Can't throw errors as other factories may create it...
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
